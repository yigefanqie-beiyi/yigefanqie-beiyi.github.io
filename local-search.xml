<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>��mit6.s081 XV6ʵ�顱 Lab4 traps</title>
    <link href="/2025/05/02/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2025/05/02/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>�ڽ�������ʵ��ǰ����Ҫ���Ķ��鱾�����µ�����</p><p>���������͵��¼��ᵼ��CPU��������ָ���ִ�У���ǿ�ƽ�����Ȩת�Ƶ�����Ĵ��룺</p><ol><li>ϵͳ���ã��û�ִ��ecallָ��</li><li>������exception������һЩ�Ƿ���ַ�ķ��ʣ���0������</li><li>�豸�ж�<br>��xv6�����Щ�¼�ͳ��Ϊtrap</li></ol><h1 id="RISC-V��trap�йصlJ���"><a href="#RISC-V��trap�йصlJ���" class="headerlink" title="RISC-V��trap�йصļĴ���"></a>RISC-V��trap�йصļĴ���</h1><p>ÿ�� RISC-V CPU ����һ����ƼĴ������ں�д����Щ�Ĵ����Ը��� CPU ��δ������壬�ں˿��Զ�ȡ��Щ�Ĵ������ҳ��ѷ��������塣</p><ul><li>stvec���ں��ڴ˴�дtrap�Ĵ��������ַ</li><li>sepc����trap����ʱ��������������PC��ֵ������trap�������ͨ��sretָ�sepc�Ĵ�����ֵ����PC�Ĵ���</li><li>scause���洢trap������ԭ��</li><li>sscratch��������ֹ�����û��Ĵ���</li><li>sstatus�����е�SIEλ��־�豸�ж��Ƿ�򿪣�SPPλ��־���trap�������û�ģʽ���ǹ���Աģʽ</li></ul><p>�����Ĵ����ڻ���ģʽ��Ҳ����һ��</p><p>������trapʱ��riscv��ִ�����²�����</p><ol><li>���trap��һ���豸�жϣ���sstatus�Ĵ�����SIEλû����λ����ִ�����²���</li><li>���SIEλ����ֹ�ж�</li><li>��pc�Ĵ������Ƶ�sepc�Ĵ���</li><li>���浱ǰ��ģʽ��sstatus��SPPλ</li><li>����scause�Ĵ������Է�ӳtrap��ԭ��</li><li>�л�ģʽ������Աģʽ</li><li>��stvec�Ĵ����д洢��trap���������ַ���Ƶ�pc</li><li>��ʼִ��pc</li></ol><p>ע�⣬CPU�����л����ں�ҳ����Ҳ�����л����ں˵�ջ��Ҳ���ᱣ�����PC֮����κμĴ�����������������һ��ԭ���ǣ�CPU �� trap �ڼ�ִ�����ٹ���Ϊ�����ṩ����ԡ�</p><h1 id="�����u��ռ��trap"><a href="#�����u��ռ��trap" class="headerlink" title="�����û��ռ��trap"></a>�����û��ռ��trap</h1><p>����·����<br>    ����ʱuservec(kernel&#x2F;trampoline.S) -&gt; usertrap(kernel&#x2F;trap.c)<br>    ����ʱusertrapret(kernel&#x2F;trap.c) -&gt; userret(kernel&#x2F;trampoline.S)</p><p>�����û�̬��trap�������ں�̬������ս�ԣ���Ϊ�û�̬����trapʱ��satp�洢��ҳ����Ӧ�Ŀռ����û��ռ�������ں˿ռ䣬����޷������ں˴�������ݡ�����ζ�ţ����������ֶ��л�ҳ�����ұ��뱣֤trap�����������û�ҳ�����ǿɷ��ʵ�</p><p>Ϊ��Ӧ��������ս��xv6ʹ����һ��trampolineҳ�����а����˹ؼ���uservec��userret���룬����ӳ�䵽�û�ҳ�����ں�ҳ������ͬ�������ַ�������������û�ҳ�������ں�ҳ�������Է���trampolineҳ������</p><p>��ʼ����û��ռ�trapʱ��Ҫ�Ĵ��룺<br>trampoline.S</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs arm"><span class="hljs-comment">#include &quot;riscv.h&quot;</span><br><span class="hljs-comment">#include &quot;memlayout.h&quot;</span><br><br><span class="hljs-symbol">.section</span> trampsec<br><span class="hljs-symbol">.globl</span> trampoline<br><span class="hljs-symbol">trampoline:</span><br><span class="hljs-symbol">.align</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">.globl</span> uservec<br><span class="hljs-symbol">uservec:</span>    <br>        <span class="hljs-comment"># ��a0�Ĵ�����ֵ�浽sscratch�Ĵ����б�������</span><br>        <span class="hljs-comment"># �Ȱ�a0��ֵ�ݴ���������Ϊ����Ҫ��a0������ָ��Ľ�ɫ�����ּĴ������ص�trapframe��</span><br>        csrw sscratch, a0<br><br>        <span class="hljs-comment"># liָ���Ǽ�����������αָ����ڽ�һ�����������ص��Ĵ�����</span><br>        <span class="hljs-comment"># ���ｫTRAPFRAME��ֵ���ص�a0�Ĵ�����</span><br>        li a0, TRAPFRAME<br>        <br>        <span class="hljs-comment"># ������ּĴ����� TRAPFRAME �У�trapframe ��һ���ṹ�壬��proc.h�ж���</span><br>        sd ra, <span class="hljs-number">40</span>(a0)<br>        sd <span class="hljs-built_in">sp</span>, <span class="hljs-number">48</span>(a0)<br>        sd gp, <span class="hljs-number">56</span>(a0)<br>        sd tp, <span class="hljs-number">64</span>(a0)<br>        sd t0, <span class="hljs-number">72</span>(a0)<br>        sd t1, <span class="hljs-number">80</span>(a0)<br>        sd t2, <span class="hljs-number">88</span>(a0)<br>        sd <span class="hljs-built_in">s0</span>, <span class="hljs-number">96</span>(a0)<br>        sd <span class="hljs-built_in">s1</span>, <span class="hljs-number">104</span>(a0)<br>        sd <span class="hljs-built_in">a1</span>, <span class="hljs-number">120</span>(a0)<br>        sd <span class="hljs-built_in">a2</span>, <span class="hljs-number">128</span>(a0)<br>        sd <span class="hljs-built_in">a3</span>, <span class="hljs-number">136</span>(a0)<br>        sd <span class="hljs-built_in">a4</span>, <span class="hljs-number">144</span>(a0)<br>        sd a5, <span class="hljs-number">152</span>(a0)<br>        sd a6, <span class="hljs-number">160</span>(a0)<br>        sd a7, <span class="hljs-number">168</span>(a0)<br>        sd <span class="hljs-built_in">s2</span>, <span class="hljs-number">176</span>(a0)<br>        sd <span class="hljs-built_in">s3</span>, <span class="hljs-number">184</span>(a0)<br>        sd <span class="hljs-built_in">s4</span>, <span class="hljs-number">192</span>(a0)<br>        sd <span class="hljs-built_in">s5</span>, <span class="hljs-number">200</span>(a0)<br>        sd <span class="hljs-built_in">s6</span>, <span class="hljs-number">208</span>(a0)<br>        sd <span class="hljs-built_in">s7</span>, <span class="hljs-number">216</span>(a0)<br>        sd <span class="hljs-built_in">s8</span>, <span class="hljs-number">224</span>(a0)<br>        sd <span class="hljs-built_in">s9</span>, <span class="hljs-number">232</span>(a0)<br>        sd <span class="hljs-built_in">s10</span>, <span class="hljs-number">240</span>(a0)<br>        sd <span class="hljs-built_in">s11</span>, <span class="hljs-number">248</span>(a0)<br>        sd t3, <span class="hljs-number">256</span>(a0)<br>        sd t4, <span class="hljs-number">264</span>(a0)<br>        sd t5, <span class="hljs-number">272</span>(a0)<br>        sd t6, <span class="hljs-number">280</span>(a0)<br><br><span class="hljs-comment"># ��sscratch��ֵ����t0�Ĵ����У��ٽ�t0�Ĵ�����ֵ�浽TRAPFRAME�ĵ�ַ��</span><br>        <span class="hljs-comment"># �����sscratch�Ĵ�����һ������Ĵ������洢����һ��ʼ�����a0�Ĵ�����ֵ</span><br>        csrr t0, sscratch<br>        sd t0, <span class="hljs-number">112</span>(a0)<br><br>        <span class="hljs-comment"># initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br>        ld <span class="hljs-built_in">sp</span>, <span class="hljs-number">8</span>(a0)<br><br>        <span class="hljs-comment"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br>        ld tp, <span class="hljs-number">32</span>(a0)<br><br>        <span class="hljs-comment"># load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br>        ld t0, <span class="hljs-number">16</span>(a0)<br><br><br>        <span class="hljs-comment"># fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br>        ld t1, <span class="hljs-number">0</span>(a0)<br><br>        <span class="hljs-comment"># ȷ���л�ҳ��ǰ���е��ڴ���������</span><br>        sfence.vma zero, zero<br><br>        <span class="hljs-comment"># �л�ҳ���ռ�</span><br>        csrw satp, t1<br><br>        <span class="hljs-comment"># ˢ��TLB����ֹ�ɵ�ӳ��Ӱ���µĿռ�Ѱַ</span><br>        sfence.vma zero, zero<br><br>        <span class="hljs-comment"># ����usertrap����ִ��</span><br>        jr t0<br><br><span class="hljs-symbol">.globl</span> userret<br><span class="hljs-symbol">userret:</span><br>        <span class="hljs-comment"># userret(pagetable)</span><br>        <span class="hljs-comment"># called by usertrapret() in trap.c to</span><br>        <span class="hljs-comment"># switch from kernel to user.</span><br>        <span class="hljs-comment"># a0: user page table, for satp.</span><br><br>        <span class="hljs-comment"># ͬ������׼��ҳ���л�����</span><br>        sfence.vma zero, zero<br>        csrw satp, a0<br>        sfence.vma zero, zero<br><br>        li a0, TRAPFRAME<br><br>        <span class="hljs-comment"># restore all but a0 from TRAPFRAME</span><br>        ld ra, <span class="hljs-number">40</span>(a0)<br>        ld <span class="hljs-built_in">sp</span>, <span class="hljs-number">48</span>(a0)<br>        ld gp, <span class="hljs-number">56</span>(a0)<br>        ld tp, <span class="hljs-number">64</span>(a0)<br>        ld t0, <span class="hljs-number">72</span>(a0)<br>        ld t1, <span class="hljs-number">80</span>(a0)<br>        ld t2, <span class="hljs-number">88</span>(a0)<br>        ld <span class="hljs-built_in">s0</span>, <span class="hljs-number">96</span>(a0)<br>        ld <span class="hljs-built_in">s1</span>, <span class="hljs-number">104</span>(a0)<br>        ld <span class="hljs-built_in">a1</span>, <span class="hljs-number">120</span>(a0)<br>        ld <span class="hljs-built_in">a2</span>, <span class="hljs-number">128</span>(a0)<br>        ld <span class="hljs-built_in">a3</span>, <span class="hljs-number">136</span>(a0)<br>        ld <span class="hljs-built_in">a4</span>, <span class="hljs-number">144</span>(a0)<br>        ld a5, <span class="hljs-number">152</span>(a0)<br>        ld a6, <span class="hljs-number">160</span>(a0)<br>        ld a7, <span class="hljs-number">168</span>(a0)<br>        ld <span class="hljs-built_in">s2</span>, <span class="hljs-number">176</span>(a0)<br>        ld <span class="hljs-built_in">s3</span>, <span class="hljs-number">184</span>(a0)<br>        ld <span class="hljs-built_in">s4</span>, <span class="hljs-number">192</span>(a0)<br>        ld <span class="hljs-built_in">s5</span>, <span class="hljs-number">200</span>(a0)<br>        ld <span class="hljs-built_in">s6</span>, <span class="hljs-number">208</span>(a0)<br>        ld <span class="hljs-built_in">s7</span>, <span class="hljs-number">216</span>(a0)<br>        ld <span class="hljs-built_in">s8</span>, <span class="hljs-number">224</span>(a0)<br>        ld <span class="hljs-built_in">s9</span>, <span class="hljs-number">232</span>(a0)<br>        ld <span class="hljs-built_in">s10</span>, <span class="hljs-number">240</span>(a0)<br>        ld <span class="hljs-built_in">s11</span>, <span class="hljs-number">248</span>(a0)<br>        ld t3, <span class="hljs-number">256</span>(a0)<br>        ld t4, <span class="hljs-number">264</span>(a0)<br>        ld t5, <span class="hljs-number">272</span>(a0)<br>        ld t6, <span class="hljs-number">280</span>(a0)<br><br><span class="hljs-comment"># restore user a0</span><br>        ld a0, <span class="hljs-number">112</span>(a0)<br>        <br>        <span class="hljs-comment"># ��sepc��ȡ���û�̬�ĳ�������������ص�pc��</span><br>        <span class="hljs-comment"># ��sstatus�Ĵ����лָ��û�̬�Ĵ�����״̬�����������жϣ��л����û�ģʽ��</span><br>        sret<br></code></pre></td></tr></table></figure><p>trap.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// handle an interrupt, exception, or system call from user space.</span><br><span class="hljs-comment">// called from trampoline.S</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//ȡ��sstatus�Ĵ�����ֵ���ж������SPPλ�Ƿ�Ϊ0��</span><br>  <span class="hljs-comment">//���Ϊ0����˵�����û�̬������trap</span><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// ��Ϊ��ʱ�Ѿ����ں�̬�ˣ�����Ҫ��stvec����Ϊ�ں�̬���жϴ����������������</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-comment">//�����ϵͳ����</span><br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(killed(p))<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepcָ�����ecall����ָ�����������Ҫ���ص���ecall����һ��ָ��</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sepc, scause, and sstatus,</span><br>    <span class="hljs-comment">// so enable only now that we&#x27;re done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125;<br>  <span class="hljs-comment">// ������豸�ж� </span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    setkilled(p);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(killed(p))<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// return to user space</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from</span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until</span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.</span><br>  intr_off();<br><br>  <span class="hljs-comment">// ��uservec�ĵ�ַ���õ�stvec�Ĵ�����</span><br>  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);<br>  w_stvec(trampoline_uservec);<br><br>  <span class="hljs-comment">// set up trapframe values that uservec will need when</span><br>  <span class="hljs-comment">// the process next traps into the kernel.</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table</span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack</span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;<br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()</span><br><br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use</span><br>  <span class="hljs-comment">// to get to user space.</span><br>  <br>  <span class="hljs-comment">// set S Previous Privilege mode to User.</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();<br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode</span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode</span><br>  w_sstatus(x);<br><br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.</span><br>  w_sepc(p-&gt;trapframe-&gt;epc);<br><br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.</span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);<br><br>  <span class="hljs-comment">// jump to userret in trampoline.S at the top of memory, which </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,</span><br>  <span class="hljs-comment">// and switches to user mode with sret.</span><br>  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);<br>  ((<span class="hljs-type">void</span> (*)(uint64))trampoline_userret)(satp);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="�ܽ�һ���u�����trapʱ�l�������"><a href="#�ܽ�һ���u�����trapʱ�l�������" class="headerlink" title="�ܽ�һ���û�����trapʱ�ĺ�������"></a>�ܽ�һ���û�����trapʱ�ĺ�������</h1><ul><li>���ȣ��û�̬����trapʱ��stvec�Ĵ������ľ���trampoline.S�ﶨ���uservec����</li><li>����trap��CPUĬ����ת��stvec��ĵ�ִַ��uservec</li><li>����uservec(trampoline.S)<ul><li>���мĴ���״̬�ı��棬���浽trapframe�ṹ���У�ÿ��������p�ﶼ��һ���ṹ��trapframeԪ�أ�</li><li>���ҳ���ռ���滻������trapframe��洢���ں�ҳ���ռ���ص�satp�Ĵ����У� </li><li>��ת��usertrap��ִ��</li></ul></li><li>����usertrap(trap.c)<ul><li>����sstatus�ж�SPP�Ƿ�Ϊ0��Ϊ0˵�����û�̬������trap���Լ���ִ�У�Ϊ1˵�����ں�̬������trap������panic</li><li><strong>��ʱstvec���ŵ���uservec�����û�̬����trap����ں��������ǽ���usertrap��CPU���Զ��޸���Ȩ��Ϊ�ں�̬����˽���uservec��CPU�����ں�̬������������</strong>����л���������Ӳ���Զ���ɵģ������Ҫ��stvec��洢��trap��ڸ�Ϊ�ں�̬�´���trap�����kernelvec�����������ʱ�ٴδ���trap���򻹻����ִ��usertrap���ǾͲ����ˣ��ͱ�����ں�̬��trapִ�е��û�̬trap��ڣ�SPPλ��1���޷�ͨ���û�̬trap����SPPλΪ0���������</li><li>Ȼ������ж�scause����ϵͳ���þ�ִ��syscall����Ӳ���жϾ�ִ��Ӳ���ж�</li></ul></li><li>ִ��usertrapret���з���<ul><li>��Ϊ��Ҫ�����û�̬����˴�ʱ��Ҫ��stvec�Ĵ������ó��û�̬��trap���</li><li>Ҫ�ٴ�����SPPΪ0��ȷ��SPPΪ0</li><li>ִ��userret(pagetable)����ҳ���ռ��л����û�̬�����ָ��û�̬��uservec�ﱣ��ĸ��ּĴ���</li><li>����sret��sepc��ȡ���û�̬�ĳ�������������ص�pc�У���sstatus�Ĵ����лָ��û�̬�Ĵ�����״̬�����������жϣ��л����û�ģʽ��</li></ul></li></ul><h1 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace(moderate)"></a>Backtrace(moderate)</h1><p>ԭ�⣺<br><img src="/../img/xv6.4.1.png"></p><p>��Ŀ������</p><ol><li>дһ��backtrace����������ͨ������backtrace�������е�ǰ����ջ֡�Ļ������</li><li>��kernel&#x2F;printf.c��ʵ��backtrace()</li><li>��sys_sleep�м���backtrace�ĺ������ã�Ȼ��ִ��bttest����</li><li>��ǰ������ջָ֡������s0�Ĵ����У�ͨ��<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> uint64<br><span class="hljs-title function_">r_fp</span><span class="hljs-params">()</span><br>&#123;<br>  uint64 x;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mv %0, s0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (x) )</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>���s0�Ĵ���������ݡ�</li><li>Ҫ��defs.h�����Ӻ���ԭ��</li><li>ջ֡�Ļ����ܵ��и���ֹ�����������ں�ջ���趨����һ��page�ڣ���˿���ͨ���ж��Ƿ���һ��ҳ�����ж�ջ֡�����Ƿ�Ӧ�ý�ֹ������ PGROUNDDOWN(fp)����</li></ol><p>˼·��</p><ol><li>ץס��Ŀ����hints�Ĺؼ��㣺���ص�ַ ��ջ֡�� ָ֡�루frame pointer�� ���� �̶�ƫ���� -8 ���ڣ��� �������һ��ָ֡�� �� �̶�ƫ���� -16 ������ָ֡�봦��</li><li>������kernel&#x2F;riscv.h�ж������������r_fp��Ȼ����defs.h������backtrace����ԭ��<code>void backtrace(void)</code>��Ȼ����sys_sleep����������Ҹ��ط����Ӻ����ĵ���backtrace()</li><li>��printf.c��д����backtrace<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Backtrace:\n&quot;</span>);<br>  uint64* fp = (uint64*)r_fp(); <span class="hljs-comment">// ��ȡ��ǰջָ֡��</span><br>  uint64 page = PGROUNDDOWN((uint64)fp); <span class="hljs-comment">// ��ǰҳ����ʼ��ַ</span><br><br>  <span class="hljs-keyword">while</span> (fp != <span class="hljs-number">0</span> &amp;&amp; PGROUNDDOWN((uint64)fp) == page) &#123;<br>    uint64* ra = fp - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, *ra);<br>    fp = (uint64*)*(fp - <span class="hljs-number">2</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>����ͨ��r_fp��ȡ��ǰջָ֡�룬������PGROUNDDOWN������ȡ��ǰpage��ʼ��ַ�����жϽ�ֹ����</li><li>Ȼ��ѭ���ж���ʱ��ָ��fp��Ӧ��page�Ƿ���һ��ʼ��page</li><li>ѭ�����У�����ƫ���������ݣ���ӡ���ص�ַ��������ջָ֡��</li><li>����Ҫע����ֱ������͵�ת������ͬ�����Ĵ��κͷ���ֵ��ͬ����ʱ����uint64����ʱ����uint64*����������ǿ������ת��Ҫ�õıȽ�С��</li><li>ע�⣬����Ƕ�ָ����мӼ�����Ҫע��Ӽ���ֵ�����磬�������uint64* fp����ôƫ��-8�ֽڵĻ���Ӧ��д��fp &#x3D; fp - 1�����������uint64 fp����Ӧ��д��fp &#x3D; fp - 8��</li></ol><p>�����<br><img src="/../img/xv6.4.2.png"><br><img src="/../img/xv6.4.3.png"></p><h1 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm(hard)"></a>Alarm(hard)</h1><p>��Ŀ̫���������ܽ�һ�£���ž���д����ϵͳ���ã�һ��sigalarm ��һ��sigreturn ��Ȼ�����һ���û�����alarmtest��������û�����ͨ���˾ͽ���ˣ�ΪʲôҪд������ϵͳ������ʱû˼����ԭ�򣬾͵�Ϊ�˲��԰�<br>��������������ɣ�<br><img src="/../img/xv6.4.4.png"></p><p>���ȵ���makefile���alarmtest���ӽ�ȥ��Ϊ�û�����Ȼ���sigalarm��sigreturn��ϵͳ���ýӿ����Ӻã�����Ͳ�׸���ˡ�<br>alarmtest���ĸ�test</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  test0();<br>  test1();<br>  test2();<br>  test3();<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>�Ƚ��test0������test0�Ĵ���</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">periodic</span><span class="hljs-params">()</span><br>&#123;<br>  count = count + <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alarm!\n&quot;</span>);<br>  sigreturn();<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">test0</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test0 start\n&quot;</span>);<br>  count = <span class="hljs-number">0</span>;<br>  sigalarm(<span class="hljs-number">2</span>, periodic);<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>*<span class="hljs-number">500000</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>((i % <span class="hljs-number">1000000</span>) == <span class="hljs-number">0</span>)<br>      write(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  sigalarm(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test0 passed\n&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\ntest0 failed: the kernel never called the alarm handler\n&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>�������ʵ����߼���</p><ul><li>ϵͳ����sigalarmֻ���������ò����ģ�Ҫ���ʱ���ж�һ�������ɡ�</li><li>test0����Ĭ������£�����forѭ��������֪���<code>.</code>ֱ�����޻��߾�̬����count&gt;0.</li><li>ʱ���ж��ڳ�ʼ��ʱ�ͱ����ˣ����ʱ���ж�һֱ�ڽ����š�</li><li>���ǵ�����sigalarm�����󣬾ͻ���Ϊ����Ĳ������ƣ���ʼ���㷢���˼���ʱ���жϣ��ﵽ��ֵ���һ������periodic���������alarm!��ͬʱ�������Ҳ���þ�̬����count++������test0���forѭ����ֹͣ</li><li>test0����ʱ������sigreturn</li></ul><p>������</p><ol><li><p>�����ڽ��̽ṹ����������һЩԪ��</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  ...<br>  <span class="hljs-type">int</span> alarmticks;   <span class="hljs-comment">//�洢����Ķ�ʱ</span><br>  <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">void</span>);    <span class="hljs-comment">//��ʱ�������Ҫִ�еĺ���</span><br>  <span class="hljs-type">int</span> ticks;    <span class="hljs-comment">//�����ж��Ƿ񵽴ﶨʱ</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>���ǰ���test0�ĺ�����һ��һ����</p></li><li><p>ִ��<code>sigalarm(2, periodic);</code>,��ִ��ecall��Ȼ���Ǵ�sevec���ҵ�����uservec��������ת��usertrap���������ж�scause��������ϵͳ���ã�����ִ��syscall</p></li><li><p>����ϵͳ�����ҵ���Ӧ��sys_sisalarm����ʱ����Ҫд�������</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  uint64 handler_addr;<br>  argint(<span class="hljs-number">0</span>, &amp;(p-&gt;alarmticks));<br>  argaddr(<span class="hljs-number">1</span>, &amp;handler_addr);<br>  p-&gt;ticks = p-&gt;alarmticks;<br>  p-&gt;handler = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))handler_addr;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>������һ���״�����argaddr������ʹ�ã����洫�δ�����uint64*�ͣ��������Ƕ�����Ǻ���ָ��handler������ֱ����handlerȥ���أ������׳��ֲ���Ԥ��Ĵ�������������ת����ʱ��ҪС��</p></li><li><p>���������������ֻҪ���������ʱ����<code>sigalarm(0, 0);</code>����ô���̽ṹ����ͻ�洢��ʱ��ʱ��Ͷ�ʱ�Ĵ�������</p></li><li><p>Ȼ��ϵͳ���÷��أ���trap.c�����<code>p-&gt;trapframe-&gt;epc += 4;</code>����ص��û�̬���ص�ַ����һ��</p></li><li><p>Ȼ��test0���forѭ�����’.’</p></li><li><p>�����forѭ���Ĺ����У�ʱ���ж�Ҳ��������У���������Ҫȥдʱ���жϣ���Ϊ��ʱ���û�̬������Ҫ��usertrap��дʱ���жϵ�����</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ��ʱ�ж�</span><br><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>  yield();<br>  <span class="hljs-keyword">if</span>(p-&gt;ticks != <span class="hljs-number">0</span>)&#123;<br>    p-&gt;ticks--;<br>    <span class="hljs-keyword">if</span>(p-&gt;ticks == <span class="hljs-number">0</span>)&#123;<br>      p-&gt;ticks = p-&gt;alarmticks;<br>      p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>���������Ŀ��ʾ����Ҫ�Դ����tick�Ƿ�Ϊ0���ж��Ƿ�����ʱ���ؼ������ǣ�<code>p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</code></p></li><li><p>��Ϊ��p-&gt;handler�������û�̬�µĴ�������periodic��������ʱ���жϴ�������ʱCPU���ں�̬��ҳ���ռ䲻һ�������һ��ʼ��ֱ��<code>p-&gt;handler()</code>��ֱ��panic��</p></li><li><p>����Ҫ��ʱ���жϴﵽ���޺�ȥִ���û�̬�µ�periodic��������Ҫ����sepc����Ĵ����������trap����ʱӦ�õ�����PC���û�̬�µĵ�ַ</p></li><li><p>�����и�ϸ�ڣ���ʱ��ֱ�Ӱ�periodic�����ĵ�ַͨ��sretָ���pcִ�еģ����������ĺ������ã������ĺ������÷��ص�ַ�ᱻ���浽 ra �Ĵ����С�������ִ����Ϻ�ret ָ���� ra �Ĵ�����ȡ�����ص�ַ������ת���õ�ַ����ִ�С�</p></li><li><p>����������ҪȥѰ�Ҵ�ʱra�Ĵ��������ʲô�ģ���periodic���������һ����<code>sigreturn</code>ϵͳ���ã�������ǻ��ٴ�ִ��ϵͳ����</p></li><li><p>�������ǰ�<code>sigreturn</code>ϵͳ����ֻд��<code>return 0</code>����˻��ǻ᷵�ص���һ��ȥִ��retָ���������Ҫȥ��ra�Ĵ��������ʲô������gdb���ԣ�����ra�Ĵ�����Ӧ�ĵ�ַ������<code>if(count &gt; 0)</code><br><img src="/../img/xv6.4.5.png"></p></li><li><p>ִ���ж�count&gt;0���������forѭ������������ִ��</p></li><li><p>��Ŀ����ʾ����Ҫ�Ѵ��������ĵ�ַΪ0�����ж�������һ��ʼû������ʲô��˼������ŷ���periodic�ĵ�ַΪ0����Ϊ0����������ɺϣ����Ҫ��tick�Ƿ�Ϊ0�����ж�����</p></li></ol><p>������ʽ����ͨ��test0�����ǻ������Ե����⣬������ķ�����</p><ul><li>���ȣ�sigalarm���ϵͳ����ֻ������������ʱ���������ö�ʱʱ��Ͷ�ʱ�����ģ����ǵĹ�ע��Ӧ����Ҫ��ʱ���жϺ���</li><li>�������û�̬ʱ���ж����̣�<ul><li>���е�ĳһ�д���ʱ��ʱ���ص���������ʱ���ж�</li><li>����stvec�Ĵ���������uservec����������״̬��trapframe</li><li>����usertrap���������ʱ���жϵĴ���</li><li>����usertrapret������Ȼ�����userret�������ָ�trapframe�б����״̬</li><li>sepc����֮ǰ���д���ĵ�ַ��ͨ��sretָ��ָ��ж�ǰϵͳ��״̬</li></ul></li><li>������������sigreturnϵͳ���ã����̱�Ϊ��<ul><li>���е�ĳһ�д���ʱ��ʱ���ص���������ʱ���ж�</li><li>����stvec�Ĵ���������uservec����������״̬��trapframe</li><li>����usertrap���������ʱ���жϵĴ���</li><li>�жϴ���ʱ���޸���sepc��ַΪperiodic������ַ</li><li>����usertrapret������Ȼ�����userret�������ָ�trapframe�б����״̬</li><li>sretָ����cpuȥִ�е���periodic�Ĵ��룬�������жϷ���ǰ�Ĵ���</li><li>periodic����ִ���꣬ͨ��retָ�ra�Ĵ�����ֵ����pc������ʱra�Ĵ�����ֵ��֮ǰĳһ���������µľ�ֵ����˿��ܻ���������Ԥ֪������</li></ul></li><li>������Ҫ��periodic����ִ����֮�󣬲�ͨ��ret������ͨ������ĳ�ַ�ʽ�ص�ʱ���ж�ǰ��״̬</li><li>���Ҫ����sigreturnϵͳ���ã�<ul><li>���е�ĳһ�д���ʱ��ʱ���ص���������ʱ���ж�</li><li>����stvec�Ĵ���������uservec����������״̬��trapframe</li><li>����usertrap���������ʱ���жϵĴ���</li><li>�жϴ���ʱ������ж϶�ʱ�ﵽ��ֵ������һ��trapframe��save_trapframe�У������������Ҫ����Ϊ��һ����Ҫ�޸�trapframe-&gt;epc��ֵ����������֮ǰ����״̬</li><li>�޸���sepc��ַΪperiodic������ַ</li><li>����usertrapret������Ȼ�����userret�������ָ�trapframe�б����״̬</li><li>sretָ����cpuȥִ�е���periodic�Ĵ���</li><li>periodic����ĩβ��ִ��sigreturnϵͳ����</li><li>�ֽ��뵽uservec�����ʱ��״̬</li><li>Ȼ��usertrap������ϵͳ���ã��ڸ�ϵͳ�����У���֮ǰ�����ʱ���жϴ���ǰ��save_trapframe�ָ�����ʱ��p-&gt;trapframe��</li><li>��ʱ��p-&gt;trapframe����ľ���ʱ���ж�ǰ��״̬</li><li>Ȼ�����usertrapret������Ȼ�����userret�������ָ�trapframe�б����״̬</li></ul></li></ul><p>�˽�������˼·������������test1��test1����Ҫ������������ʱ���жϺ����ݿ�����ȷ������Ӧ�ĵ�ַ</p><ol><li>��usertrap������memmove��������״̬<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ��ʱ�ж�</span><br><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>  yield();<br>  <span class="hljs-keyword">if</span>(p-&gt;ticks != <span class="hljs-number">0</span> &amp;&amp; p-&gt;alarm_flag == <span class="hljs-number">1</span>)&#123;<br>    p-&gt;ticks--;<br>    <span class="hljs-keyword">if</span>(p-&gt;ticks == <span class="hljs-number">0</span>)&#123;<br>      memmove(p-&gt;save_trapframe, p-&gt;trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe)); <span class="hljs-comment">//����һ��</span><br>      p-&gt;alarm_flag = <span class="hljs-number">0</span>;<br>      p-&gt;ticks = p-&gt;alarmticks;<br>      p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Ϊ�˱���״̬����proc�м���save_trapframe����ṹ��ָ����б��ݣ�����ֻ�Ǹ�ָ�룬Ҫע����allocprocʱ����ռ䣬ҲҪע�⿽��ʱӦ�������������ǳ����</li><li>��sys_sigreturn����memmove�����ݵ�״̬�Żص�ǰ��trapframe��֮����ͨ��userret�ָ�״̬<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  memmove(p-&gt;trapframe, p-&gt;save_trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));       <span class="hljs-comment">//����һ��</span><br>  p-&gt;alarm_flag = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>��test2��ʵ��������������һ�����ܣ�������Ƕ�׶�ʱ�жϴ���������Ҳ���Ǵﵽ��ʱ��ֵ��ص��û�̬����ʱ���ڴ����Ĺ�����ʱ���жϻ��ǲ��Ϸ����ģ�����Ӧ�ô�����ʱ�����γ�Ƕ�ף����˼·���Ƕ�ʱ�жϴ�����ɺ�ᴥ��sigreturn�������ϵͳ����û����ǰ��ͨ����־λ���趨��ֹ��ʱ�ж�</p><ol><li>��proc�ṹ��������һ��alarm_flag����ʼ��Ϊ0</li><li>��sigalarm������Ϊ1���򿪶�ʱ�ж�<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  uint64 handler_addr;<br>  argint(<span class="hljs-number">0</span>, &amp;(p-&gt;alarmticks));<br>  argaddr(<span class="hljs-number">1</span>, &amp;handler_addr);<br>  p-&gt;ticks = p-&gt;alarmticks;<br>  p-&gt;alarm_flag = <span class="hljs-number">1</span>;        <span class="hljs-comment">//����һ��</span><br>  p-&gt;handler = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))handler_addr;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>��ʱ�жϴ���ʱ����alarm_flag��Ϊ0���رն�ʱ�жϣ������������ж����alarm_flag��Ϊ1�򲻽��붨ʱ�ж�<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ��ʱ�ж�</span><br><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>  yield();<br>  <span class="hljs-keyword">if</span>(p-&gt;ticks != <span class="hljs-number">0</span> &amp;&amp; p-&gt;alarm_flag == <span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">//����һ��</span><br>    p-&gt;ticks--;<br>    <span class="hljs-keyword">if</span>(p-&gt;ticks == <span class="hljs-number">0</span>)&#123;<br>      memmove(p-&gt;save_trapframe, p-&gt;trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>      p-&gt;alarm_flag = <span class="hljs-number">0</span>;              <span class="hljs-comment">//����һ��</span><br>      p-&gt;ticks = p-&gt;alarmticks;<br>      p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>��sigreturn��������ʱ���񣬽�alarmticks�޸�Ϊ1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  memmove(p-&gt;trapframe, p-&gt;save_trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>  p-&gt;alarm_flag = <span class="hljs-number">1</span>;    <span class="hljs-comment">//����һ��</span><br>  <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>��test3����ʵ��������ע��һ����<br>������sys_sigreturnʱ������ͨ��save_trapframe�ָ���CPU״̬��������Ҫ��֤���治Ҫ���޸�trapframe���������<br>��ˣ�ϵͳ����sys_sigreturn����ʱ����ѷ���ֵ�ŵ�a0�Ĵ����У�׼ȷ��˵��Ĭ�Ϸŵ�p-&gt;trapframe-&gt;a0�У�����sys_sigreturnִ�����p-&gt;trapframe-&gt;a0 &#x3D; ����ֵ<br>�����������ָı䣬���sys_sigreturn�ķ���ֵӦ�þ��Ǳ��ݵ�a0�����������ͻ���p-&gt;trapframe-&gt;a0 &#x3D; p-&gt;trapframe-&gt;a0��Ч������Ӱ��a0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  memmove(p-&gt;trapframe, p-&gt;save_trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>  p-&gt;alarm_flag = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;  <span class="hljs-comment">//����һ��</span><br>&#125;<br></code></pre></td></tr></table></figure><p>����Ч����<br><img src="/../img/xv6.4.6.png"><br><img src="/../img/xv6.4.7.png"></p>]]></content>
    
    
    <categories>
      
      <category>Xv6 Lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“mit6.s081 XV6实验” Lab3 page tables</title>
    <link href="/2025/04/30/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2025/04/30/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>在开始这章实验前，需要阅读xv6 book的第三章，同时阅读kernel目录下的memlayout.h文件，vm.c文件，kalloc.c文件</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p><img src="/../img/xv6.3.1.png"></p><ul><li>xv6运行在Sv39 RISC-V上，意思是64位虚拟地址只有低39位才被使用，高25位暂时没有使用；低39位中，高27位用来找到对应的PTEs，每个PTE占64位，但只用到了低54位，其中的低54位中，高44位用来表示物理地址页号(physical address number PPN)，低12位是一些标志位。</li><li>xv6可寻址范围是2^39&#x3D;512GB</li><li>一个页表以及一个页都是占4KB，一个页表项PTE占8B，因此一个页表有512个页表项</li><li>xv6采用三级页表的方式映射内存，以上图所示，对于一个64位虚拟地址：<ul><li>高25位EXT暂未使用</li><li>首先在satp寄存器中存放了根目录物理地址</li><li>9位可以表示512个下标，通过satp存储的根目录物理地址找到一级页表的位置，根据L2找到一级页表对应的PTE，通过该PTE的高44位PPN找到对应二级页表的物理地址</li><li>通过上一步找到了二级页表的物理地址，再根据L1找到二级页表对应的PTE，通过该PTE的高44位PPN找到对应三级页表的物理地址</li><li>通过上一步找到了三级页表的物理地址，再根据L0找到三级页表对应的PTE，通过该PTE的高44位PPN找到对应页的物理地址</li><li>通过上一步找到了对应物理页，再根据虚拟地址低12位的Offest找到对应的字节(一个物理页占4KB，12位可表示的正好是4KB的大小)</li></ul></li><li>三级页表的寻址有时候还是很麻烦，所以CPU会提供一个页表高速缓存TLB，加速虚拟地址到物理地址的转换，俗称快表</li></ul><h2 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h2><p><img src="/../img/xv6.3.2.png"></p><ul><li>xv6内核的地址空间采用直接映射，从0x80000000到0x88000000(PHYSTOP)，总共128MB</li><li>还有trampoline页和内核栈映射到了内核的物理地址空间，但具体为什么要做这样的映射，这一节没有细讲</li><li>trampoline页设置的标志位为PTE_R和PTE_X</li><li>和之前做的基于x86的myos搭建不一样，这里对于物理内存并没有划分内核物理内存池和用户物理内存池，而是直接用户内核可用物理内存统一用了从0x80000000到0x88000000(PHYSTOP)</li></ul><h1 id="内核页表启动前关于内核内存的init"><a href="#内核页表启动前关于内核内存的init" class="headerlink" title="内核页表启动前关于内核内存的init"></a>内核页表启动前关于内核内存的init</h1><p><img src="/../img/xv6.3.3.png"></p><h2 id="kinit，完成内核物理地址的分配-kalloc-c"><a href="#kinit，完成内核物理地址的分配-kalloc-c" class="headerlink" title="kinit，完成内核物理地址的分配(kalloc.c)"></a>kinit，完成内核物理地址的分配(kalloc.c)</h2><ul><li>-&gt;调用initlock初始化kmem的锁</li><li>-&gt;调用freerange对于每个可用的内核page，都调用kfree清空，并假如到kmem的空闲链表中，free的范围是内核数据代码段的结束地址之后一个字节到PHYSTOP<ul><li>-&gt;将起始地址向上关于4KB取整</li><li>-&gt;循环遍历每个page，调用kfree函数<ul><li>-&gt;释放一个page，将此时的page作为空闲链表kmem.freelist的头部</li></ul></li></ul></li></ul><h2 id="kvminit，创建内核页表-vm-c"><a href="#kvminit，创建内核页表-vm-c" class="headerlink" title="kvminit，创建内核页表(vm.c)"></a>kvminit，创建内核页表(vm.c)</h2><ul><li>执行<code>kernel_pagetable = kvmmake();</code>将创建好的内核根目录地址存入kernel_pagetable变量中<ul><li>-&gt;调用kalloc函数从内核空闲链表中分配一个page给临时变量kpgtbl，<code>kpgtbl = (pagetable_t) kalloc();</code></li><li>利用memset清空kpgtbl</li><li>-&gt;调用kvmmap函数完成uart寄存器，disk接口，PLIC，内核代码段，内核数据段，内核可用内存，trampoline页的虚拟地址到物理地址的映射<ul><li>-&gt;kvmmap函数本质是调用mappages函数完成映射，因此介绍kvmmap实际就是介绍mappages函数</li><li>-&gt;mappages传入5个参数分别为页表地址pagetable，虚拟地址va，大小size，物理地址pa，设置映射页的标志位</li><li>-&gt;将va向下关于4KB取整赋给a，将va向上关于4KB取整赋给last，因此要操作的范围就是a到last</li><li>-&gt;在a到last中循环遍历每一页</li><li>-&gt;调用walk函数，查找或者创建虚拟地址a对应的页表项，存入pte，注意这里walk的第三个参数要设为1<ul><li>-&gt;walk函数传入三个参数，分别是pagetable，虚拟地址va，以及标志位alloc</li><li>-&gt;当alloc为1时，如果在映射的过程中某一级页表不存在，则会调用kalloc分配一页作为该级页表</li><li>-&gt;初始时pagetable是一级页表地址，通过PX(2,va)获得高9位，并在pagetable中找到对应的pte，通过PTE2PA获得该PTE对应的二级页表的物理地址，更新pagetable为二级页表的物理地址</li><li>-&gt;通过PX(1,va)获得中9位，并在pagetable中找到对应的pte，通过PTE2PA获得该PTE对应的三级页表的物理地址，更新pagetable为三级页表的物理地址</li><li>-&gt;<code>return &amp;pagetable[PX(0, va)]</code>返回三级页表中对应的pte</li></ul></li><li>-&gt;如果页表项的PTE_V位已经置位，说明发生了重复映射，触发panic remmap</li><li>-&gt;将物理地址pa与标志位perm，存在位PTE_V组合成一个PTE项赋给pte</li><li>-&gt;继续循环迭代直到处理的page范围超过last</li></ul></li><li>-&gt;调用proc_mapstacks函数为每个进程分配和映射内核栈，相当于是提前做映射，xv6中进程最大数量是确定的，这里提前分配了所有进程的内核栈<ul><li>-&gt;调用宏<code>#define KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</code>，从内核顶部一路向下分配内核栈，每个内核栈占一页，同时还会有一页的未做映射的页作为保护页，防止栈溢出</li><li>-&gt;这个宏要有-3*PGSIZE，是因为TRAMPOLINE-PGSIZE是TRAPFRAME，再-PGSIZE是USYSCALL，再-PGSIZE是第一个进程的内核栈</li></ul></li><li>-&gt;返回kpgtbl</li></ul></li></ul><h2 id="kvminithart，打开分页机制"><a href="#kvminithart，打开分页机制" class="headerlink" title="kvminithart，打开分页机制"></a>kvminithart，打开分页机制</h2><ul><li>刷新快表，防止旧的快表影响系统</li><li>加载satp寄存器，启动分页机制</li><li>再次刷新快表</li></ul><h2 id="整个内核内存空间设计和页表启动流程总结"><a href="#整个内核内存空间设计和页表启动流程总结" class="headerlink" title="整个内核内存空间设计和页表启动流程总结"></a>整个内核内存空间设计和页表启动流程总结</h2><ul><li>整体的内核是加载到物理内存地址为0x8000000处执行的(2GB),设置内核的大小不超过128MB，因此PHYSTOP设置为了2GB+128MB</li><li>调用kinit函数，将内核本身大小之后 到 PHYSTOP之间的空间设为内核空间，并添加到kmem的空闲链表中</li><li>注意，此时没有启动页表，所有操作都是直接操作物理地址，因此kmem.freelist存储的都是物理地址</li><li>调用kalloc分配一页物理地址，作为一级页表</li><li>完成一级页表中，内核空间的各个直接映射</li><li>调用kvminitart打开分页机制</li><li>不用纠结各个地方是虚拟地址还是物理地址，因为是直接映射</li></ul><p>有一个困扰我很久的点，就是找到了PTE后，对应中间44位的地址是下一级页表的地址，那么这个地址到底是虚拟地址还是物理地址，书上说是虚拟地址，可是打开页表机制后，对内存的访问不就是要完成虚拟地址到物理地址的映射吗，就算是对页表的查询，本质也是要访问内存，那这44位应该是作为虚拟地址被访问的才对<br>想了很久，有两种解释：</p><ol><li>对于其他的地址访问，肯定是虚拟地址，但对于页表查询这种中间44位的内存访问，因为属于页表机制，所以risc-v会自动识别为物理地址</li><li>或者说，对于页表查询这种中间44位的内存访问，说是虚拟地址或者物理地址都可以，因为页表肯定在内核里，内核是direct map的，所以两者相等</li></ol><p>目前还没找到具体这两种解释哪个是对的，但我认为应该是第二种，并且虽然两者相等，但中间44位应该作为虚拟地址</p><h1 id="Speed-up-system-calls-easy"><a href="#Speed-up-system-calls-easy" class="headerlink" title="Speed up system calls (easy)"></a>Speed up system calls (easy)</h1><p>原题：<br><img src="/../img/xv6.3.4.png"></p><p>题目分析：</p><ol><li>os会利用在用户空间和内核空间共享一些只读区域，完成对一些系统调用的加速，减少系统调用中跨越内核的需要，根据这个原理，尝试修改getpid系统调用</li><li>在创建每个进程时，都映射一个只读页在USYSCALL上，在memlayout.h中定义，同时放一个结构体struct usyscall在这一页，并初始化</li><li>用户程序ugetpid已经写好</li><li>在proc.c的proc_pagetable函数中完成mapping</li><li>要记得设置只读位</li><li>利用mappages函数</li><li>不要忘了完成页的初始化和分配在allocproc函数中</li><li>确保在freeproc中这一页被正确释放</li></ol><p>解题思路：</p><ol><li>先打开memlayout.h，可以看到内核虚拟地址从上到下的前三页被设计成了TRAMPOLINE，TRAPFRAME，USYSCALL；前两页都已经有映射，那么我们只需要模仿前两页，完成USYSCALL的映射就行<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span><br></code></pre></td></tr></table></figure></li><li>首先需要在proc结构体中加入<code>struct usyscall *usyscall;</code>定义，因为是所有进程都要利用SYSCALL这一页进行一些只读操作的加速，因此每个进程体都拥有一个元素去处理这一页的数据会方便操作</li><li>在proc.c的allocproc函数中，加入代码，分配一个内核物理页存入进程的usyscall指针中<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>((p-&gt;usyscall = (<span class="hljs-keyword">struct</span> usyscall *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc usyscall page fail!\n&quot;</span>);<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>直接将进程的pid同时写入这一页(！！为什么可以直接通过指针操作？因为是在内核空间，内核是直接映射的)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;usyscall-&gt;pid = p-&gt;pid;<br></code></pre></td></tr></table></figure></li><li>完成虚拟地址USYSCALL到物理地址(uint64)(p-&gt;usyscall)的映射，这里关键点：标志位一定要记得设置PTE_U！因为这是要用户态也能访问的页<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE,<br>             (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>  uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmfree(pagetable, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在freeproc函数里，也要记得添加释放USYSCALL页的操作，不然就会出现内存泄漏了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;trapframe)<br>    kfree((<span class="hljs-type">void</span>*)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;usyscall)<br>    kfree((<span class="hljs-type">void</span>*)p-&gt;usyscall);<br>  p-&gt;usyscall = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable)<br>    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  p-&gt;sz = <span class="hljs-number">0</span>;<br>  p-&gt;pid = <span class="hljs-number">0</span>;<br>  p-&gt;parent = <span class="hljs-number">0</span>;<br>  p-&gt;name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  p-&gt;chan = <span class="hljs-number">0</span>;<br>  p-&gt;killed = <span class="hljs-number">0</span>;<br>  p-&gt;xstate = <span class="hljs-number">0</span>;<br>  p-&gt;state = UNUSED;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>结果输出：<br><img src="/../img/xv6.3.5.png"></p><h1 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h1><p>原题如下：<br><img src="/../img/xv6.3.6.png"></p><p>题目分析：</p><ol><li>编写一个功能，可以打印当前页表的内容</li><li>定义一个函数vmprint()，接收一个pagetable_t类型的参数，并且按照上图格式打印信息，第一行打印接收的参数，之后的每个pte行，打印页表树的深度(用..表示一层深度)，pte的对应index，pte的值，从pte中提取的物理地址pa的值。</li><li>在exec.c的<code>return argc</code>前插入<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，这样在xv6启动时会打印第一个进程的页表</li><li>可以在kernel&#x2F;vm.c中写vmprint函数</li><li>使用kernel&#x2F;riscv.h末尾的宏</li><li>阅读freewalk函数，可能会带来灵感</li><li>定义vmprint的原型在kernel&#x2F;defs.h中，以在exec.c中可以调用</li><li>要用到printf函数，使用%p来打印64bit的十六进制数</li></ol><p>解决思路：</p><ol><li>稍微小改了一下，因为想要直接通过一个函数就递归遍历，所以加了个参数depth，函数原型变成<code>void vmprint(pagetable_t pagetable, int depth)</code>，然后按照要求先设置好各个接口</li><li>在exec.c的<code>return argc</code>前插入<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable， 0)</code>，在kernel&#x2F;defs.h中完成函数声明</li><li>其他没啥好说的，就写个递归算法<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">int</span> depth)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(depth &lt; <span class="hljs-number">0</span> || depth &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//首行打印传入的pagetable</span><br>  <span class="hljs-keyword">if</span>(depth == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, (uint64)pagetable);<br>  <span class="hljs-comment">//递归遍历</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)<br>  &#123;<br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span> (pte &amp; PTE_V)<br>    &#123;<br>      uint64 child = PTE2PA(pte);<br>      <span class="hljs-keyword">if</span>(depth == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(depth == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. ..&quot;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);<br>      vmprint((<span class="hljs-type">pagetable_t</span>)child, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>结果输出：<br><img src="/../img/xv6.3.7.png"></p><h1 id="Detect-which-pages-have-been-accessed-hard"><a href="#Detect-which-pages-have-been-accessed-hard" class="headerlink" title="Detect which pages have been accessed (hard)"></a>Detect which pages have been accessed (hard)</h1><p>原题如下：<br><img src="/../img/xv6.3.78.png"></p><p>题目分析：</p><ol><li>实现一个系统调用pgaccess，报告哪些pages被访问，接收三个参数，第一个用户page的起始虚拟地址，需要检查的page的数量，一个用户空间的buffer以位图的形式映射每一页是否有被访问</li><li>阅读user&#x2F;pgtlbtest.c中和pgaccess有关的部分</li><li>在sysproc.c中实现sys_pgaccess</li><li>通过argaddr() 和 argint()传递参数</li><li>利用copyout函数将内核的临时缓冲区的数复制到用户传入的buffer</li><li>可以设置一个扫描页数的上限</li><li>vm.c中的walk函数可以帮助找到正确的PTES</li><li>在riscv.h中定义PTE_A</li><li>检查PTE_A设置后，请务必清除PTE_A。否则，将无法确定自上次调用pgaccess（）以来是否访问了该页（即，该位将永远设置）。</li><li>可以利用vmprint函数进行debug</li></ol><p>解决思路：</p><ol><li>查看<code>pgaccess_test</code>函数，发现里面已经写好了调用的代码，我们只要写好pgaccess这个系统调用即可</li><li>可以知道，用户态的函数原型是<code>int pgaccess(void *base, int len, void *mask);</code>，因此要利用argaddr() 和 argint()在内核态接收参数</li><li>根据用户传入的要检查的page的起始虚拟地址，通过walk函数找到对应的PTE</li><li>要记得在riscv.h文件中添加<code>#define PTE_A (1L &lt;&lt; 6)</code></li><li>要记得在检查完后清除PTE_A的标志位，这样才能在下一次检查的时候，获得最新的访问状态</li><li>利用for循环就可以很简单的实现循环检查了，最后利用copyout函数复制mask回用户空间<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// lab pgtbl: your code here.</span><br>  uint64 base, mask_user;<br>  uint64 mask_kernel = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> len;<br>  argaddr(<span class="hljs-number">0</span>, &amp;base);<br>  argint(<span class="hljs-number">1</span>, &amp;len);<br>  argaddr(<span class="hljs-number">2</span>, &amp;mask_user);<br>  <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">64</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-keyword">if</span>((pte = walk(p-&gt;pagetable, base, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">//循环检查</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_A)&#123;<br>      mask_kernel |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>    &#125;<br>    *pte &amp;= ~PTE_A;<br>    pte++;<br>  &#125;<br>  <span class="hljs-comment">//利用copyout复制回用户空间</span><br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, mask_user, (<span class="hljs-type">char</span>*)&amp;mask_kernel, <span class="hljs-keyword">sizeof</span>(uint64)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>调试过程中，出现了Page Fault错误，利用gdb调试检查，发现是运行到copyout函数时，gdb提示传入的源地址参数是0x01，检查后发现问题是一开始我的函数调用写成了<code>copyout(p-&gt;pagetable, mask_user, (char*)mask_kernel, sizeof(uint64))</code>，但起始mask_kernel是uint64类型的数据，传入的参数应该是char<em>，应该把mask_kernel的地址转为char</em>而不是mask_kernel的值转为char*，修改为<code>copyout(p-&gt;pagetable, mask_user, (char*)&amp;mask_kernel, sizeof(uint64))</code>后问题解决</p><p>结果输出：<br><img src="/../img/xv6.3.9.png"></p><p>对整个Lab3执行make grade<br><img src="/../img/xv6.3.10.png"></p>]]></content>
    
    
    <categories>
      
      <category>Xv6 Lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“mit6.s081 XV6实验” Lab2 system calls</title>
    <link href="/2025/04/25/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2025/04/25/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Using-gdb-easy"><a href="#Using-gdb-easy" class="headerlink" title="Using gdb(easy)"></a>Using gdb(easy)</h1><p>这个小实验就是教学gdb调试的入门，这里总结一点经验：</p><ol><li>在ubuntu上要用gdb-multiarch，好像用不了教学官网提到的riscv64-unknown-elf-gdb</li><li>要开两个控制台，一个运行<code>make qemu-gdb&#39; 另一个运行</code>gdb-multiarch<code>，并绑定端口25000，同时打开</code>file kernel&#x2F;kernel&#96;<br><img src="/../img/xv6.2.1.png"></li><li>为了避免每次打开都要手动绑定架构，绑定监测的端口，并打开可执行文件，直接在初始化文件中写命令在初始化时完成这些操作<br><code>vim ~/.gdbinit</code><br><img src="/../img/xv6.2.2.png"></li><li>执行<code>b syscall</code>，在syscall函数调用处打断点，执行<code>c</code>单步执行<br><img src="/../img/xv6.2.3.png"></li><li>执行<code>layout src</code>将屏幕分为上下两个部分，上面可以看源码，下面是控制台，执行<code>backtrace</code>或者<code>bt</code>可以看此时函数的调用栈帧<br><img src="/../img/xv6.2.4.png"></li><li>问题：Looking at the backtrace output, which function called syscall?</li></ol><ul><li>从bt命令中可以看出是usertrap()函数调用的syscall</li></ul><ol start="7"><li>问题：What is the value of p-&gt;trapframe-&gt;a7 and what does that value represent? (Hint: look user&#x2F;initcode.S, the first user program xv6 starts.</li></ol><ul><li>利用&#96;p &#x2F;x *p-&gt;trapframe’可以看出a7寄存器里存的数值是7</li></ul><ol start="8"><li>问题：What was the previous mode that the CPU was in?</li></ol><ul><li>值是0x22，说明trap前的模式为用户模式</li></ul><h1 id="x86与riscv关于特权级，系统调用，中断，内存的区别"><a href="#x86与riscv关于特权级，系统调用，中断，内存的区别" class="headerlink" title="x86与riscv关于特权级，系统调用，中断，内存的区别"></a>x86与riscv关于特权级，系统调用，中断，内存的区别</h1><p>RISC-V 架构下的用户模式（User Mode）和监督模式（Supervisor Mode）与 x86 架构下的特权级 3（Ring 3）和特权级 0（Ring 0）在概念上非常相似<br><strong>(1)特权级设计</strong></p><ul><li>x86架构：<ul><li>x86 使用 4 个特权级（Ring 0 到 Ring 3），但通常只使用 Ring 0（内核）和 Ring 3（用户程序）。</li><li>Ring 1 和 Ring 2 很少使用，通常被保留给驱动程序或中间层软件。</li></ul></li><li>RISC-V架构：<ul><li>RISC-V 的设计更简洁，通常只定义了 3 种模式：</li></ul><ol><li>用户模式（User Mode，U）：运行用户程序。</li><li>监督模式（Supervisor Mode，S）：运行操作系统内核。</li><li>机器模式（Machine Mode，M）：运行固件或引导程序，权限最高。</li></ol><ul><li>没有类似 x86 的中间特权级（Ring 1 和 Ring 2）。<br><strong>(2)系统调用机制</strong></li></ul></li><li>x86架构：<ul><li>使用 int 指令（如 int 0x80）或更高效的 syscall&#x2F;sysret 指令来实现系统调用。</li><li>系统调用会从 Ring 3 切换到 Ring 0。</li></ul></li><li>RISC-V架构：<ul><li>使用 ecall 指令发起系统调用。</li><li>系统调用会从用户模式（U）切换到监督模式（S）。<br><strong>(3)中断和异常处理</strong></li></ul></li><li>x86架构：<ul><li>中断和异常处理通过中断描述符表（IDT）实现，IDT 包含每个中断或异常的处理程序入口。</li><li>CPU 会根据中断向量号查找 IDT 中的对应条目。</li></ul></li><li>RISC-V架构：<ul><li>中断和异常处理通过陷入向量表（Trap Vector Table）实现。</li><li>RISC-V 的陷入机制更简洁，直接跳转到指定的陷入处理程序。<br><strong>(4)内存管理</strong></li></ul></li><li>x86架构：<ul><li>使用段式内存管理（Segmentation）和分页（Paging）结合的方式</li><li>虽然现代操作系统通常只使用分页，但段寄存器（如 cs、ds）仍然存在。</li></ul></li><li>RISC-V架构：<ul><li>仅支持分页（Paging），没有段式内存管理。</li><li>页表的设计更灵活，支持多级页表（如 Sv39、Sv48）。</li></ul></li></ul><h1 id="RISC-V-中的-scause、sepc-和-stval-寄存器作用"><a href="#RISC-V-中的-scause、sepc-和-stval-寄存器作用" class="headerlink" title="RISC-V 中的 scause、sepc 和 stval 寄存器作用"></a>RISC-V 中的 <code>scause</code>、<code>sepc</code> 和 <code>stval</code> 寄存器作用</h1><p><strong>1. <code>scause</code>（Supervisor Cause Register）</strong></p><ul><li><strong>作用</strong>：记录导致陷入（Trap）的原因，包括中断或异常的类型。</li><li><strong>关键字段</strong>：<ul><li><strong>位 63（Interrupt 位）</strong>：<ul><li>如果为 <code>1</code>，表示陷入是由中断引起的。</li><li>如果为 <code>0</code>，表示陷入是由异常引起的。</li></ul></li><li><strong>位 0-62（Exception Code 或 Interrupt Code）</strong>：<ul><li>如果是中断，表示中断的类型（如外部中断、定时器中断等）。</li><li>如果是异常，表示异常的类型（如非法指令、页错误等）。</li></ul></li></ul></li><li><strong>用途</strong>：<ul><li>操作系统通过读取 <code>scause</code>，确定陷入的具体原因，并跳转到相应的中断或异常处理程序。</li></ul></li></ul><hr><p><strong>2. <code>sepc</code>（Supervisor Exception Program Counter Register）</strong></p><ul><li><strong>作用</strong>：保存发生异常或中断时的程序计数器（PC）的值。</li><li><strong>用途</strong>：<ul><li>当异常或中断处理完成后，操作系统可以通过 <code>sret</code> 指令将控制权返回到 <code>sepc</code> 指定的地址，继续执行被中断的程序。</li><li>如果需要跳过导致异常的指令（如非法指令），操作系统可以修改 <code>sepc</code> 的值。</li></ul></li></ul><hr><p><strong>3. <code>stval</code>（Supervisor Trap Value Register）</strong></p><ul><li><strong>作用</strong>：保存与陷入相关的附加信息，具体内容取决于异常的类型。</li><li><strong>用途</strong>：<ul><li><strong>地址相关异常</strong>（如页错误）：<ul><li><code>stval</code> 保存导致异常的虚拟地址。</li></ul></li><li><strong>非法指令异常</strong>：<ul><li><code>stval</code> 保存导致异常的非法指令编码。</li></ul></li><li><strong>其他异常</strong>：<ul><li>如果没有附加信息需要保存，<code>stval</code> 的值为 <code>0</code>。</li></ul></li></ul></li></ul><hr><h1 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h1><p>题目分析：</p><ol><li>添加一个系统调用trace，用来跟踪当前进程的系统调用情况，接收一个参数mask，mask对应的第x个位置一，就说明系统调用号为x的系统调用被跟踪，在该系统调用即将返回时打印一行信息，内容包括进程ID，系统调用名称和返回值，同时，对于调用trace的进程所创建的所有子进程也需要进行跟踪，并保持mask不变。</li><li>完成后的输出如下：<br><img src="/../img/xv6.2.5.png"></li><li>在makefile中添加$U&#x2F;_trace</li><li>在用户空间user&#x2F;trace.c中存在已经存在了用户态的接口，但是直接make qemu无法通过编译，因为里面的trace函数还没定义，即要添加好系统调用的一系列接口。</li><li>修改kernel&#x2F;proc.c中的fork函数，将mask从父进程复制到子进程</li></ol><p>解决思路：</p><ol><li>首先需要定义好添加一个系统调用的一系列接口，按照下列顺序添加“</li></ol><ul><li>user&#x2F;trace.c中的trace函数没有声明，因此在user&#x2F;user.h中添加<code>int trace(int);</code>声明；</li><li>在usys.pl中添加<code>entry(&quot;trace&quot;);</code>，该脚本文件可以帮助生成的usys.S文件中生成关键的汇编trace函数的代码，其实就是把系统调用号传入a7并执行ecall；</li><li>在kernel&#x2F;syscall.c中的syscalls函数数组中添加sys_trace元素，以支持通过系统调用号SYS_trace找到对应的执行函数sys_trace；</li><li>在kernel&#x2F;sysproc.c中加入sys_trace函数的定义；</li></ul><ol start="2"><li>mask传入后需要在整个进程的所有系统调用过程中都可见，因此应该是个全局变量，利用proc这个结构体，我们直接在进程控制体proc中新添加一个变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  ...<br>  uint64 mask;                 <span class="hljs-comment">// Trace mask</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>在sysproc.c的sys_trace函数中完成定义，由于用户态中<code>int trace(int)</code>只传入了一个参数就是mask，因此通过函数<code>argint</code>就可以在a0寄存器中获得传入的参数，并把该值赋给p-&gt;mask即可。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  argint(<span class="hljs-number">0</span>, &amp;mask);<br>  p -&gt; mask = mask;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>输出的跟踪信息，是在系统调用返回时才进行的，因此思路就是，在系统调用返回处的接口，加一个判断此时的系统调用是否是mask中设定好的，如果是的话就输出跟踪信息。系统调用的入口和返回口其实都是syscall.c的syscall函数，为了在输出时能够输出对应的名字，创建了一个新的静态数组完成名字的映射<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> name[<span class="hljs-number">30</span>][<span class="hljs-number">10</span>] = &#123;<br>  <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;fork&quot;</span>,<br>  <span class="hljs-string">&quot;exit&quot;</span>,<br>  <span class="hljs-string">&quot;wait&quot;</span>,<br>  <span class="hljs-string">&quot;pipe&quot;</span>,<br>  <span class="hljs-string">&quot;read&quot;</span>,<br>  <span class="hljs-string">&quot;kill&quot;</span>,<br>  <span class="hljs-string">&quot;exec&quot;</span>,<br>  <span class="hljs-string">&quot;fstat&quot;</span>,<br>  <span class="hljs-string">&quot;chdir&quot;</span>,<br>  <span class="hljs-string">&quot;dup&quot;</span>,<br>  <span class="hljs-string">&quot;getpid&quot;</span>,<br>  <span class="hljs-string">&quot;sbrk&quot;</span>,<br>  <span class="hljs-string">&quot;sleep&quot;</span>,<br>  <span class="hljs-string">&quot;uptime&quot;</span>,<br>  <span class="hljs-string">&quot;open&quot;</span>,<br>  <span class="hljs-string">&quot;write&quot;</span>,<br>  <span class="hljs-string">&quot;mknod&quot;</span>,<br>  <span class="hljs-string">&quot;unlink&quot;</span>,<br>  <span class="hljs-string">&quot;link&quot;</span>,<br>  <span class="hljs-string">&quot;mkdir&quot;</span>,<br>  <span class="hljs-string">&quot;close&quot;</span>,<br>  <span class="hljs-string">&quot;trace&quot;</span>,<br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">//num = * (int *) 0; </span><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    <span class="hljs-comment">// Use num to lookup the system call function for num, call it,</span><br>    <span class="hljs-comment">// and store its return value in p-&gt;trapframe-&gt;a0</span><br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    <span class="hljs-keyword">if</span>(p -&gt; mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p -&gt; pid, name[num], p-&gt;trapframe-&gt;a0);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>为了将mask的有效值拷贝传递给每个子进程，需要修改fork函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  np -&gt; mask = p -&gt; mask;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>测试结果：<br><img src="/../img/xv6.2.6.png"><br><img src="/../img/xv6.2.7.png"></p><h1 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (moderate)</h1><p>原题如下：<br><img src="/../img/xv6.2.8.png"></p><p>题目分析：</p><ol><li>程序中已经存在了sysinfotest.c这个文件，稍微看了一下，没必要研究里面的程序，只需要知道是用来测试的就行。</li><li>需要在makefile里面添加<code> $U/_sysinfotest</code>，运行<code>make qemu</code>会出现编译错误，是因为没有添加系统调用sysinfo的接口，因此需要添加sysinfo系统调用的接口</li><li>sysinfo中需要将struct sysinfo复制回用户空间，参考sys_fstat() （ kernel&#x2F;sysfile.c ）和 filestat() （ kernel&#x2F;file.c ）中如何使用 copyout() 来完成此操作的示例。</li><li>在kernel&#x2F;kalloc.c中添加一个函数，收集空闲内存的大小</li><li>在kernel&#x2F;proc.c中添加一个函数，收集进程数量</li></ol><p>解决思路：</p><ol><li>首先需要解决编译问题，还是老样子需要添加系统调用的一系列接口，具体参考之前的实验</li><li>在user&#x2F;user.h中要声明sysinfo()的原型，需要预先声明struct sysinfo的存在<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sysinfo *)</span>;<br></code></pre></td></tr></table></figure></li><li>sysinfo系统调用接收一个参数struct sysinfo，通过sysinfo系统调用将系统信息填入传入的参数，因此需要利用copyout函数将struct sysinfo复制回用户空间</li><li>阅读kernel&#x2F;kalloc.c，可以发现有一个全局变量kmem，里面的freelist元素是个链表，以链表的形式存储空闲节点的数量，每个节点映射为4KB的内存，因此可以遍历这个链表，统计节点的数量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">getfreemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  r = kmem.freelist;<br>  uint64 count = <span class="hljs-number">0</span>;<br>  acquire(&amp;kmem.lock);<br>  <span class="hljs-keyword">while</span>(r)&#123;<br>    count++;<br>    r = r -&gt; next;<br>  &#125;<br>  release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> (count * <span class="hljs-number">4096</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>阅读kernel&#x2F;proc.c，发现有一个proc数组，里面存储了当前所有进程，通过遍历数组每个元素的状态判断是不是UNUSED，获取当前进程的数量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">getnproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  uint count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NPROC; i++)&#123;<br>    <span class="hljs-keyword">if</span>(proc[i].state != UNUSED)&#123;<br>      count++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>最终代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">si</span>;</span><br>  si.freemem = getfreemem();<br>  si.nproc = getnproc();<br>  uint64 addr;<br>  argaddr(<span class="hljs-number">0</span>, &amp;addr);<br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;si, <span class="hljs-keyword">sizeof</span>(si)) &lt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>运行结果：<br><img src="/../img/xv6.2.9.png"><br><img src="/../img/xv6.2.10.png"></p>]]></content>
    
    
    <categories>
      
      <category>Xv6 Lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“mit6.s081 XV6实验” Lab1 Xv6 and Unix utilities</title>
    <link href="/2025/04/18/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2025/04/18/%E2%80%9Cmit6.s081%20XV6%E5%AE%9E%E9%AA%8C%E2%80%9D%20%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep(easy)"></a>sleep(easy)</h1><p>原题如下：<br><img src="/../img/xv6.1.1.png"></p><p>分析题目：</p><ol><li>在xv6上实现一个用户能调用的sleep功能，可以在指定时间内进行睡眠，应该在user&#x2F;sleep.c中提供解决方案。</li><li>阅读user&#x2F;里的文件，例如user&#x2F;echo.c user&#x2F;grep.c user&#x2F;rm.c，了解如何将命令行的输入参数传输到程序里</li><li>如果用户没有传递参数，sleep应该输出错误信息</li><li>命令行参数传入的是字符串，应该利用atoi函数转为int</li><li>使用已有的系统调用sleep</li><li>在kernel&#x2F;sysproc.c文件中了解sleep系统调用的实现sys_sleep，在user&#x2F;user.h里有sleep调用的定义，user&#x2F;usys.S有用户态到内核态的sleep接口</li><li>main函数运行完应该调用exit(0)</li><li>在makefile里添加sleep.c才可以编译</li></ol><p>思路：</p><ol><li>先来看如何将命令行参数传入程序，C提供标准格式<code>int main(int argc, char *argv[])</code>，argc是传入参数的个数，argv是字符串数组，以echo为例，当命令行输入<code>echo hello</code>时，argc &#x3D; 2, argv[0] &#x3D; “echo”, argv[1] &#x3D; “hello”；</li><li>在kernel&#x2F;sysproc.c user&#x2F;user.h user&#x2F;usys.S中都已经定义好了sleep的接口，不需要我们修改</li><li>直接在user里创建一个sleep.c：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">1</span> || argc &gt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]);<br>    sleep(ticks);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在makefile添加sleep</li></ol><p>结果：<br><img src="/../img/xv6.1.2.png"><br><img src="/../img/xv6.1.3.png"></p><h1 id="用户添加系统调用的过程"><a href="#用户添加系统调用的过程" class="headerlink" title="用户添加系统调用的过程"></a>用户添加系统调用的过程</h1><p>sleep实验的代码很简单，但是我们需要搞清楚为什么用户可以这样写程序，也就是搞懂用户是怎么使用内核提供的系统调用的<br>以在user&#x2F;sleep.c的代码为例：</p><p>在控制台输入<code>sleep 10</code>，会传入字符串”sleep 10”给shell，shell进行解析、fork、exec等（属于shell的知识，暂不详述），因此我们直接从CPU开始执行user&#x2F;sleep.c的代码开始理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">1</span> || argc &gt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]);<br>    sleep(ticks);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键在这一行代码<code>sleep(ticks);</code>，执行到这句的时候，需要去找<code>int sleep(int)</code>的定义<br>执行user&#x2F;usys.pl文件（一个脚本）</p><figure class="highlight pl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">entry</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> <span class="hljs-variable">$name</span> = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;.global <span class="hljs-variable">$name</span>\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>:\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; li a7, SYS_<span class="hljs-subst">$&#123;name&#125;</span>\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ecall\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ret\n&quot;</span>;<br>&#125;<br>entry(<span class="hljs-string">&quot;sleep&quot;</span>);<br></code></pre></td></tr></table></figure><p>可以帮助我们生成一个usys.S的汇编文件，里面存在语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">.global sleep   //导出sleep符号，声明为全局符号，可以被链接，因此外部可以使用sleep函数<br>sleep:<br> li a7, SYS_sleep       //将系统调用号 SYS_sleep 加载到寄存器 a7 中。<br> ecall          //调用ecall执行将控制权从用户态切换到内核态，内核根据 a7 中的系统调用号执行对应的系统调用。<br> ret            //系统调用完成后，返回到用户态程序的下一条指令。<br></code></pre></td></tr></table></figure><p>因此，我们在执行<code>sleep(ticks);</code>这句话时，由于在user.h中声明了<code>int sleep(int)</code>，因此编译是可以通过的，按照RISC-V的约定，函数参数ticks存在a0寄存器中（这个过程和x86架构不同），然后CPU去寻找外部sleep的定义，即sleep的符号，找到usys.S生成的sleep符号并执行，将系统调用号 SYS_sleep 加载到寄存器 a7 中，切换到内核态。</p><p>内核里kernel&#x2F;syscall.c文件中，注册了系统调用表syscalls</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br>[SYS_fork]    sys_fork,<br>[SYS_exit]    sys_exit,<br>[SYS_wait]    sys_wait,<br>[SYS_pipe]    sys_pipe,<br>[SYS_read]    sys_read,<br>[SYS_kill]    sys_kill,<br>[SYS_exec]    sys_exec,<br>[SYS_fstat]   sys_fstat,<br>[SYS_chdir]   sys_chdir,<br>[SYS_dup]     sys_dup,<br>[SYS_getpid]  sys_getpid,<br>[SYS_sbrk]    sys_sbrk,<br>[SYS_sleep]   sys_sleep,<br>[SYS_uptime]  sys_uptime,<br>[SYS_open]    sys_open,<br>[SYS_write]   sys_write,<br>[SYS_mknod]   sys_mknod,<br>[SYS_unlink]  sys_unlink,<br>[SYS_link]    sys_link,<br>[SYS_mkdir]   sys_mkdir,<br>[SYS_close]   sys_close,<br>&#125;;<br></code></pre></td></tr></table></figure><p>转到内核态后，会执行syscall函数，根据a7寄存器的系统调用号找到对应的系统调用函数，以及a0寄存器的参数传入对应系统调用函数，进而去执行sys_sleep</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    <span class="hljs-comment">// Use num to lookup the system call function for num, call it,</span><br>    <span class="hljs-comment">// and store its return value in p-&gt;trapframe-&gt;a0</span><br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>系统调用函数都在kernel&#x2F;sysproc.c中存储，在里面我们可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sleep</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> n;<br>  uint ticks0;<br><br>  argint(<span class="hljs-number">0</span>, &amp;n);<br>  acquire(&amp;tickslock);<br>  ticks0 = ticks;<br>  <span class="hljs-keyword">while</span>(ticks - ticks0 &lt; n)&#123;<br>    <span class="hljs-keyword">if</span>(killed(myproc()))&#123;<br>      release(&amp;tickslock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;ticks, &amp;tickslock);<br>  &#125;<br>  release(&amp;tickslock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此执行这个函数，可以完成<code>sleep 10</code>的效果，然后一步一步return，回到usys.S中ecall返回用户态，再执行ret回到shell。</p><h1 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong(easy)"></a>pingpong(easy)</h1><p>原题如下：<br><img src="/../img/xv6.1.4.png"></p><p>分析题目：</p><ol><li>写一个类似UNIX系统调用的功能，在两个进程中”ping pong”一个字节通过一对管道pipe，父进程发送一个字节给子进程，子进程应该打印 “<pid>: received ping”，其中pid是子进程的pid，同时子进程应该发送一个字节给父进程，然后退出；父进程读取到子进程发送的字节后应该打印”<pid>: received pong”然后退出。</li><li>解决方案应该写在user&#x2F;pingpong.c。</li><li>使用pipe函数去创建一个pipe，使用fork函数创建一个子进程，使用read函数读取从pipe读取数据，使用write函数往pipe里写入数据</li><li>使用getpid函数获得进程的pid</li><li>在makefile中添加pingpong的文件编译条件</li></ol><p>思路：</p><ol><li>先阅读教材的1.2和1.3小节，熟悉文件描述符和pipes的概念，了解一些系统调用例如write和read的用法。</li><li>利用子进程的exit和父进程的wait保证输出同步<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>    pipe(p);<br>    <span class="hljs-type">int</span> pid  = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//子进程</span><br>        <span class="hljs-keyword">if</span>(read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">4</span>))&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\r\n&quot;</span>, getpid(), buf);<br>            write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">4</span>);<br>            close(p[<span class="hljs-number">1</span>]);<br>            close(p[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//父进程</span><br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">4</span>))&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\r\n&quot;</span>, getpid(), buf);<br>            close(p[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>结果：<br><img src="/../img/xv6.1.5.png"><br><img src="/../img/xv6.1.6.png"></p><p>要注意，想要通过实验的test需要保证输出和实验要求里一致，在做这一小节的实验时，因为把received误拼读成了reveived，导致我的test一直无法通过，找了半天的错误最后才发现是拼写问题</p><p>网上有人是通过创建两个pipe，第一个pipe用来完成父进程向子进程传输数据，第二个pipe用来完成子进程向父进程传输数据，这样做我觉得复杂化了，其实利用exit和wait就能保证实验的效果</p><h1 id="primes-hard"><a href="#primes-hard" class="headerlink" title="primes(hard)"></a>primes(hard)</h1><p>原题如下：<br><img src="/../img/xv6.1.7.png"></p><p>分析题目：</p><ol><li>通过pipes写一个筛选素数的并发版本，具体算法逻辑要参考<a href="https://swtch.com/~rsc/thread/">这里</a>，解决方案应该写在user&#x2F;primes.c中</li><li>一个生成过程可以输入数字2,3,4，…, 1000的左端管道:第一个过程线消除了2的倍数,第二个消除了3的倍数,第三个消除了5的倍数</li><li>当管道的写端关闭时，read会返回0</li><li>要小心关闭进程不需要的文件描述符，否则程序将在第一个进程达到35之前耗尽xv6的资源。<br><img src="/../img/xv6.1.8.png"></li></ol><p>思路：</p><ol><li>利用fork和pipe作为核心功能</li><li>父进程要等待子进程的关闭后再关闭，子进程要再去创建子进程，然后本身作为父进程去完成关闭文件描述符等操作，因此这里面用到了递归的思想</li><li>之所以要用到递归函数作为子进程的处理函数，是因为最开始的生产进程和后面的筛选打印进程处理的逻辑不太一致，没办法统一，并且main函数本身也不适合做递归，当然除了用函数递归也可以用栈递归，就是麻烦了不止一点</li><li>在递归的过程中，要随时注意，如果有接下来用不到的文件描述符要及时关闭，否则会耗尽内核的资源，最重要的是！不关闭管道的写端的话，调用read的函数时会一直阻塞！！</li><li>递归也需要有终止条件，因此要构造好终止条件。</li><li>这个实验主要是加深对fork、pipe的理解的实验，再考验一点算法功底<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//筛选进程并打印</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> p[<span class="hljs-number">2</span>])</span>&#123;<br>    <span class="hljs-type">int</span> nextp[<span class="hljs-number">2</span>];<br>    pipe(nextp);<br>    <span class="hljs-type">int</span> primenum;<br>    <span class="hljs-comment">//先关闭左边管道的写端，这样读取左边管道的数据到结尾时，才不会一直阻塞</span><br>    close(p[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//递归结束条件，当左边管道没数据时，说明所有数据处理完了，最底层的子进程开始exit</span><br>    <span class="hljs-keyword">if</span>(read(p[<span class="hljs-number">0</span>], &amp;primenum, <span class="hljs-keyword">sizeof</span>(primenum)) == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, primenum);<br>    <span class="hljs-comment">//处理数据，先将左边管道的数据一个一个读出来，处理后一个一个写到右边管道</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-keyword">while</span>(read(p[<span class="hljs-number">0</span>], &amp;num, <span class="hljs-keyword">sizeof</span>(num)) &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(num % primenum != <span class="hljs-number">0</span>)&#123;<br>            write(nextp[<span class="hljs-number">1</span>], &amp;num, <span class="hljs-keyword">sizeof</span>(num));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//写完后，左边管道就不会再被用到了，因此要记得关闭左边管道的描述符</span><br>    close(p[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">//创建子进程</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//子进程递归</span><br>        sieve(nextp);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//父进程要将该进程下剩余的pipe的描述符关闭</span><br>        close(nextp[<span class="hljs-number">0</span>]);<br>        close(nextp[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">//通过wait保证同步</span><br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">//作为生成进程，将数据全部写入第一个管道</span><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++)&#123;<br>        write(p[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(i));<br>    &#125;<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//子进程,迭代</span><br>        sieve(p);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//父进程</span><br>        close(p[<span class="hljs-number">1</span>]);<br>        close(p[<span class="hljs-number">0</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>结果：<br><img src="/../img/xv6.1.9.png"><br>注意，如果没有正常退出primes回到shell，说明要么死锁，要么递归卡在某个地方了，尤其要检查read是否一直在阻塞<br><img src="/../img/xv6.1.10.png"></p><h1 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find(moderate)"></a>find(moderate)</h1><p>原题如下：<br><img src="/../img/xv6.1.11.png"></p><p>题目分析：</p><ol><li>写一个find程序，找到目录树下所有特定名字的文件，该程序写在user&#x2F;find.c中</li><li>查看user&#x2F;ls.c的代码，了解如何获取目录</li><li>使用递归去查找子目录</li><li>不要迭代“.”和“..”</li><li>不要使用&#x3D;&#x3D;对字符串进行比较，应该使用strcmp函数</li><li>要看课本1.4小节文件系统的描述，主要需要了解xv6中文件系统的各个关键结构体是怎么定义的</li></ol><p>解决思路：</p><ol><li>需要看书或者其它资源，了解文件系统里是怎么存储的，明白inode的概念，以及目录和普通文件都是怎么样的形式</li><li>认真去看ls.c的代码，尤其是其中处理目录的代码，这里讲一下片段<br><img src="/../img/xv6.1.12.png"></li><li>了解了上述知识后，其实接下来的工作就是算法的问题了，我构建了一个本质上的dfs的算法逻辑框架<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span>* dir, <span class="hljs-type">char</span>* filename)</span>&#123;<br>    <span class="hljs-comment">//局部变量创建</span><br>    <span class="hljs-comment">//打开当前目录</span><br>    <span class="hljs-comment">//获取当前目录的绝对路径</span><br>    <span class="hljs-keyword">while</span>(循环内容)&#123;<br>        ...<br>        <span class="hljs-keyword">if</span>(是文件且是目标名字)&#123;<br>            <span class="hljs-comment">//输出</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(是目录)&#123;<br>            <span class="hljs-comment">//迭代</span><br>            find();<br>        &#125;<br>    &#125;<br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>整体代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span>* dir, <span class="hljs-type">char</span>* filename)</span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-comment">//打开当前目录</span><br>    <span class="hljs-keyword">if</span>((fd = open(dir, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//获取当前的绝对路径</span><br>    <span class="hljs-built_in">strcpy</span>(buf, dir);<br>    p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-comment">//循环读取当前目录文件的一个目录项</span><br>    <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>        <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//获取当前目录项对应文件的绝对路径，存在buf中，每个循环都会覆盖，因为大小被限定为了DIRSIZ</span><br>        memmove(p, de.name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取当前目录项的文件状态</span><br>        <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断是否是目标文件</span><br>        <span class="hljs-keyword">if</span>(st.type == <span class="hljs-number">2</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>(de.name, filename))&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>        &#125;<br>        <span class="hljs-comment">//判断是否是目录</span><br>        <span class="hljs-keyword">if</span>(st.type == <span class="hljs-number">1</span>)&#123;<br>            find(buf, filename);<br>        &#125;<br>    &#125;<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>结果如下：<br><img src="/../img/xv6.1.13.png"><br><img src="/../img/xv6.1.14.png"></p><h1 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs(moderate)"></a>xargs(moderate)</h1><p>原题如下：<br><img src="/../img/xv6.1.15.png"></p><p>题目分析：</p><ol><li>写一个程序xargs，它的参数描述要运行的命令，它从标准输入中读取行，并为每一行运行命令，将该行附加到命令的参数中。</li><li>看起来很抽象，其实以这个命令来看<code>echo hello too | xargs echo bye</code>，管道符左边的标准输出是<code>hellp too</code>，这个标准输出的结果添加到右边的参数末尾变成<code>xargs echo bye help too</code>，最终执行<code>echo bye help too</code></li><li>使用fork和exec对每一行的输入调用命令，利用wait函数等待子进程结束</li><li>想要读取输入的每一个独立行，需要逐个字节读数据，以’\n’为分界线</li></ol><p>思路：</p><ol><li>这题很复杂，首先我们需要知道整体的数据流向，就要去看sh.c文件，以<code>echo hello too | xargs echo bye</code>为例，sh首先会识别到管道符，然后通过创建两个子进程执行<br><img src="/../img/xv6.1.16.png"></li><li>只有搞懂了数据流向，才能明白到底要做什么，现在我们知道了，sh里面会把管道符左边的输出作为输入到管道符右边的进程里，因此右边的进程只需要读取标准输入里面的数据就可以了</li><li>xargs是将左边命令的输出，当做参数放到右边命令参数列表后面</li><li>左边的输出可能有很多行，每一行都要对应执行一次右边的命令，因此需要每次读取一个字节，按照换行符’\n’为界限进行处理</li><li>了解exec系统调用后，发现只需要准备好参数列表argv就可以了，因此问题变成，如何将左边输出的字符串，按照空格为界限，添加到右边进程的参数列表argv后方，成为一个新的参数列表<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个函数的作用是把buf里的字符串按照空格分隔成子字符串并存到argv里</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dividestring</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">char</span> *p = buf;  <span class="hljs-comment">// 指向 buf 的当前字符</span><br>    <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 记录参数个数</span><br>    <span class="hljs-keyword">while</span> (*p != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; *p != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;  <span class="hljs-comment">// 遍历直到换行符或字符串结束</span><br>        <span class="hljs-comment">// 如果不是空格，记录子字符串的起始地址</span><br>        <span class="hljs-keyword">if</span> (*p != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; *p != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            argv[argc++] = p;  <span class="hljs-comment">// 保存当前子字符串的起始地址</span><br>        &#125;<br>        <span class="hljs-comment">// 移动到下一个空格或换行符</span><br>        <span class="hljs-keyword">while</span> (*p != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; *p != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; *p != <span class="hljs-string">&#x27;\0&#x27;</span>) p++;<br>        <span class="hljs-comment">// 将空格或换行符替换为 &#x27;\0&#x27;，标记子字符串结束</span><br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27; &#x27;</span> || *p == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            p++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后一个参数设置为 NULL</span><br>    argv[argc] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 打开标准输入，此时输入其实是管道符的输出</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span>* p = buf;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-comment">//循环每次读取一个字节</span><br>    <span class="hljs-keyword">while</span>(read(<span class="hljs-number">0</span>, &amp;ch, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//遇到换行</span><br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            *p++ = ch;<br>            <span class="hljs-type">int</span> pid = fork();<br>            <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//子进程</span><br>                <span class="hljs-comment">//构造参数列表</span><br>                <span class="hljs-type">char</span>* newargv[MAXARG];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;<br>                    newargv[i - <span class="hljs-number">1</span>] = argv[i];<br>                &#125;<br>                dividestring(buf, &amp;newargv[argc - <span class="hljs-number">1</span>]);<br>                exec(newargv[<span class="hljs-number">0</span>], newargv);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//父进程</span><br>                wait(<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>                p = buf;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//还没遇到换行</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            *p++ = ch;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在上述代码的处理过程中，要注意每次处理完成后都需要清空buf以及让指针p指向初始位置，以避免影响下一次处理。</li></ol><p>结果：<br><img src="/../img/xv6.1.17.png"><br><img src="/../img/xv6.1.18.png"></p>]]></content>
    
    
    <categories>
      
      <category>Xv6 Lab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“TinyWebserver项目学习” 第三章</title>
    <link href="/2025/04/09/%E2%80%9CTinyWebserver%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E2%80%9D%20%E4%B8%89/"/>
    <url>/2025/04/09/%E2%80%9CTinyWebserver%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E2%80%9D%20%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="头文件locker-h解读"><a href="#头文件locker-h解读" class="headerlink" title="头文件locker.h解读"></a>头文件locker.h解读</h2><p>这个头文件设定了线程同步机制有关的包装类，负责多线程同步，确保任一时刻只能有一个线程能进入关键代码段<br>包括信号量，互斥锁，条件变量</p><h3 id="sem类（信号量）"><a href="#sem类（信号量）" class="headerlink" title="sem类（信号量）"></a>sem类（信号量）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//信号量有关的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sem</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sem</span>()<br>    &#123;<br>        <span class="hljs-comment">//pshared参数设定为0，pshared用于指定信号量的共享范围</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_init</span>(&amp;m_sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sem</span>(<span class="hljs-type">int</span> num)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sem_init</span>(&amp;m_sem, <span class="hljs-number">0</span>, num) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">sem</span>()<br>    &#123;<br>        <span class="hljs-built_in">sem_destroy</span>(&amp;m_sem);<br>    &#125;<br>    <span class="hljs-comment">//申请信号量，P操作</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sem_wait</span>(&amp;m_sem) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//释放信号量，V操作</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">post</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sem_post</span>(&amp;m_sem) == <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">sem_t</span> m_sem;    <span class="hljs-comment">//定义私有成员：信号量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>信号量：把信号量对应的值看成是可用资源数<br>主要是利用了POSIX标准库里的函数，部分内容介绍：</p><ul><li><code>sem_t</code>是POSIX标准中的核心结构体，表明信号量</li><li><code>int sem_wait (sem_t *__sem)</code>申请信号量，相当于P操作</li><li><code>int sem_post (sem_t *__sem)</code>释放信号量，相当于V操作</li><li><code>int sem_init (sem_t *__sem, int __pshared, unsigned int __value)</code>初始化信号量，其中__pshared为0时代表信号量仅在同一进程的​​线程间共享​​，需放置在进程内所有线程可见的地址（如全局变量或动态分配的内存），为非零时表明信号量可在​​进程间共享​​，需放置在共享内存区域（如通过 shm_open、mmap 创建的共享内存）；__value表示初始化的信号量数值，可以理解为可用资源数量。</li></ul><h3 id="locker类（互斥锁）"><a href="#locker类（互斥锁）" class="headerlink" title="locker类（互斥锁）"></a>locker类（互斥锁）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">locker</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">locker</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">locker</span>()<br>    &#123;<br>        <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;m_mutex);<br>    &#125;<br>    <span class="hljs-comment">//获取锁</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;m_mutex) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;m_mutex) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//通过调用公有方法去获取私有成员</span><br>    <span class="hljs-function"><span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> &amp;m_mutex;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><p>互斥锁，以互斥的形式访问共享资源<br>主要是利用了POSIX标准库里的函数，部分内容介绍：</p><ul><li><code>pthread_mutex_t</code>是POSIX标准库里互斥锁的核心结构体</li><li><code>pthread_mutex_lock</code>进行锁的获取</li><li><code>pthread_mutex_unlock</code>进行锁的释放</li></ul><h3 id="cond类（条件变量）"><a href="#cond类（条件变量）" class="headerlink" title="cond类（条件变量）"></a>cond类（条件变量）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cond</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">cond</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;m_cond, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//pthread_mutex_destroy(&amp;m_mutex);</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">cond</span>()<br>    &#123;<br>        <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;m_cond);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *m_mutex)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//pthread_mutex_lock(&amp;m_mutex);</span><br>        ret = <span class="hljs-built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);<br>        <span class="hljs-comment">//pthread_mutex_unlock(&amp;m_mutex);</span><br>        <span class="hljs-keyword">return</span> ret == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">timewait</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *m_mutex, <span class="hljs-keyword">struct</span> timespec t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//pthread_mutex_lock(&amp;m_mutex);</span><br>        ret = <span class="hljs-built_in">pthread_cond_timedwait</span>(&amp;m_cond, m_mutex, &amp;t);<br>        <span class="hljs-comment">//pthread_mutex_unlock(&amp;m_mutex);</span><br>        <span class="hljs-keyword">return</span> ret == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">broadcast</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_broadcast</span>(&amp;m_cond) == <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//static pthread_mutex_t m_mutex;</span><br>    <span class="hljs-type">pthread_cond_t</span> m_cond;<br>&#125;;<br></code></pre></td></tr></table></figure><p>条件变量：允许线程在特定条件不满足时主动挂起，直到其他线程通过信号或广播唤醒它<br>主要是利用了POSIX标准库里的函数，部分内容介绍：</p><ul><li><code>pthread_cond_t</code>是POSIX标准库里条件变量的核心结构体</li><li><code>int pthread_cond_wait (pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex)</code>线程通过调用此函数​​挂起自身​​，直到其他线程通过 pthread_cond_signal() 或 pthread_cond_broadcast() 发出条件成立的信号。</li><li><code>pthread_cond_timedwait</code>是 POSIX 线程库中用于​​带超时的条件变量等待函数​​，允许线程在指定时间内等待条件满足，超时后自动唤醒</li><li><code>pthread_cond_signal</code>通过条件变量（pthread_cond_t）向等待的线程发送信号，唤醒至少一个因条件不满足而阻塞的线程</li><li><code>pthread_cond_broadcast</code>唤醒所有等待特定条件变量的线程​​，使其从阻塞状态恢复执行</li></ul><p>这段函数的问题：在对条件变量进行操作时没有加锁保证原子性，同时也没有用while防止虚假唤醒，为什么不用？？？</p>]]></content>
    
    
    <categories>
      
      <category>TinyWebserver</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“TinyWebserver项目学习” 第二章 文件编译和命令行参数读取</title>
    <link href="/2025/04/09/%E2%80%9CTinyWebserver%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E2%80%9D%20%E4%BA%8C/"/>
    <url>/2025/04/09/%E2%80%9CTinyWebserver%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E2%80%9D%20%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="文件编译链接"><a href="#文件编译链接" class="headerlink" title="文件编译链接"></a>文件编译链接</h2><p>从最开始的输入读起，首先需要运行.sh的脚本，脚本内容很简单，只是执行<code>make server</code>这个语句，很鸡肋</p><p>看makefile文件，通过编译链接，利用动态的线程库和mysql库生成了ELF格式的可执行文件server</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CXX ?= g++ <span class="hljs-comment">#条件赋值，若未在外部环境或者命令行中定义CXX，则默认使用g++编译器</span><br><br>DEBUG ?= 1<span class="hljs-comment">#条件赋值，若未在外部环境或者命令行中定义DEBUG，则默认DEBUG为1</span><br><br><span class="hljs-comment">#如果DEBUG为1，则CXXFLAGS为-g，即开启gdb，否则为启用优化级别02</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(DEBUG)</span>, 1)<br>    CXXFLAGS += -g<br><span class="hljs-keyword">else</span><br>    CXXFLAGS += -O2<br><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-section">server: \</span><br>main.cpp \<br>./timer/lst_timer.cpp \<br>./http/http_conn.cpp \<br>./log/log.cpp \<br>./CGImysql/sql_connection_pool.cpp  \<br>webserver.cpp \<br>config.cpp<br><br><span class="hljs-comment">#链接动态线程库和动态mysql库，编译链接生成ELF格式的可执行文件server文件</span><br><span class="hljs-variable">$(CXX)</span> -o server  <span class="hljs-variable">$^</span> <span class="hljs-variable">$(CXXFLAGS)</span> -lpthread -lmysqlclient<br><br><span class="hljs-section">clean:</span><br>rm  -r server<br></code></pre></td></tr></table></figure><h2 id="命令行参数读取"><a href="#命令行参数读取" class="headerlink" title="命令行参数读取"></a>命令行参数读取</h2><p>支持用户进行个性化运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">./server [-p port] [-l LOGWrite] [-m TRIGMode] [-o OPT_LINGER] [-s sql_num] [-t thread_num] [-c close_log] [-a actor_model]<br></code></pre></td></tr></table></figure><p>温馨提示:以上参数不是非必须，不用全部使用，根据个人情况搭配选用即可.</p><ul><li>-p，自定义端口号<ul><li>默认9006</li></ul></li><li>-l，选择日志写入方式，默认同步写入<ul><li>0，同步写入</li><li>1，异步写入</li></ul></li><li>-m，listenfd和connfd的模式组合，默认使用LT + LT<ul><li>0，表示使用LT + LT</li><li>1，表示使用LT + ET</li><li>2，表示使用ET + LT</li><li>3，表示使用ET + ET</li></ul></li><li>-o，优雅关闭连接，默认不使用<ul><li>0，不使用</li><li>1，使用</li></ul></li><li>-s，数据库连接数量<ul><li>默认为8</li></ul></li><li>-t，线程数量<ul><li>默认为8</li></ul></li><li>-c，关闭日志，默认打开<ul><li>0，打开日志</li><li>1，关闭日志</li></ul></li><li>-a，选择反应堆模型，默认Proactor<ul><li>0，Proactor模型</li><li>1，Reactor模型</li></ul></li></ul><p>通过命令行的输入，把各个参数传入到main函数里，例如：假设命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./server -p 8080 -l 1<br></code></pre></td></tr></table></figure><p>那么，操作系统会将这行参数读到main函数里，main函数的形式为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br></code></pre></td></tr></table></figure><p>此时，argc为5，代表有5个参数<br>argv是一个数组，数组元素为char*，其实就是个字符指针，代表着以NULL为结尾的字符串，此时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;./server&quot;</span>, argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-p&quot;</span>, argv[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;8080&quot;</span>, argv[<span class="hljs-number">3</span>] = <span class="hljs-literal">NULL</span>, argv[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;-l&quot;</span>, argv[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;1&quot;</span>;<br></code></pre></td></tr></table></figure><p>上述过程是几乎所有进程执行的时候，会使用到的参数传递过程，要牢记</p><h3 id="Config类"><a href="#Config类" class="headerlink" title="Config类"></a>Config类</h3><p>设计了一个Config类，这个类的作用是存储命令行解析后得到的各个个性化参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Config</span>();<br>    ~<span class="hljs-built_in">Config</span>()&#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_arg</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>*argv[])</span></span>;<br><br>    <span class="hljs-comment">//端口号</span><br>    <span class="hljs-type">int</span> PORT;<br><br>    <span class="hljs-comment">//日志写入方式</span><br>    <span class="hljs-type">int</span> LOGWrite;<br><br>    <span class="hljs-comment">//触发组合模式</span><br>    <span class="hljs-type">int</span> TRIGMode;<br><br>    <span class="hljs-comment">//listenfd触发模式</span><br>    <span class="hljs-type">int</span> LISTENTrigmode;<br><br>    <span class="hljs-comment">//connfd触发模式</span><br>    <span class="hljs-type">int</span> CONNTrigmode;<br><br>    <span class="hljs-comment">//优雅关闭链接</span><br>    <span class="hljs-type">int</span> OPT_LINGER;<br><br>    <span class="hljs-comment">//数据库连接池数量</span><br>    <span class="hljs-type">int</span> sql_num;<br><br>    <span class="hljs-comment">//线程池内的线程数量</span><br>    <span class="hljs-type">int</span> thread_num;<br><br>    <span class="hljs-comment">//是否关闭日志</span><br>    <span class="hljs-type">int</span> close_log;<br><br>    <span class="hljs-comment">//并发模型选择</span><br>    <span class="hljs-type">int</span> actor_model;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类中定义了一个解析函数<code>Config::parse_arg(int argc, char*argv[])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Config::parse_arg</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>*argv[])</span></span>&#123;<br>    <span class="hljs-type">int</span> opt;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;p:l:m:o:s:t:c:a:&quot;</span>;<br>    <span class="hljs-keyword">while</span> ((opt = <span class="hljs-built_in">getopt</span>(argc, argv, str)) != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (opt)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:<br>        &#123;<br>            PORT = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:<br>        &#123;<br>            LOGWrite = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;m&#x27;</span>:<br>        &#123;<br>            TRIGMode = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>        &#123;<br>            OPT_LINGER = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>        &#123;<br>            sql_num = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>        &#123;<br>            thread_num = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>        &#123;<br>            close_log = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>        &#123;<br>            actor_model = <span class="hljs-built_in">atoi</span>(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过标准库里的函数<code>getopt</code>，是 Linux&#x2F;Unix 环境下用于解析命令行参数的 C 语言标准库函数，支持短选项（如 -a、-b 100）的灵活解析，然后再利用<code>atoi</code>函数将字符串转为int，存入到Config类对象中</p><p>Config的默认构造函数中对各个参数进行了设定默认值</p>]]></content>
    
    
    <categories>
      
      <category>TinyWebserver</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“TinyWebserver项目学习” 第一章 环境部署</title>
    <link href="/2025/04/08/%E2%80%9CTinyWebserver%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E2%80%9D%20%E4%B8%80/"/>
    <url>/2025/04/08/%E2%80%9CTinyWebserver%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E2%80%9D%20%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>这是一个非常常见的项目，我想通过这个项目加深自己c++、网络通信这一块的基础，在正式学习之前，先花点时间直接把源码下载下来并完成部署，跑一遍看看整体情况.<br>同时，因为自己已经有c++，网络通信，操作系统，计网等基础，所以这次不想借助别人已有的教程，更多的尽量只依靠自己和ai去完成这个项目的学习。</p><p><strong>1.基础环境与源码准备</strong><br>虚拟机的Ubuntu作为服务端，同时打开浏览器作为客户端</p><p>创建一个文件夹存放工程，终端执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/qinguoyi/TinyWebServer.git<br></code></pre></td></tr></table></figure><p>下载源码</p><p><strong>2.安装mysql</strong><br>执行安装mysql-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install mysql-server<br></code></pre></td></tr></table></figure><p>顺便再执行安装mysql-client</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install mysql-client<br></code></pre></td></tr></table></figure><p>检查mysql状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysql.service<br></code></pre></td></tr></table></figure><p><img src="/../img/webserver1.png"></p><p><strong>3.登录mysql并新建数据库</strong><br>以root登录mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql -u root -p<br></code></pre></td></tr></table></figure><p>根据原作者提供的readme创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 建立mydb库<br><span class="hljs-keyword">create</span> database mydb;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 创建<span class="hljs-keyword">user</span>表<br>USE mydb;<br><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span>(<br>    username <span class="hljs-type">char</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span>,<br>    passwd <span class="hljs-type">char</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NULL</span><br>)ENGINE<span class="hljs-operator">=</span>InnoDB;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 添加数据<br><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-keyword">user</span>(username, passwd) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;passwd&#x27;</span>);<br></code></pre></td></tr></table></figure><p>可以根据以下命令查看表和表的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>可以查看当前的数据库<br>USE yourdb; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>选择新建的数据库<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看用户<br></code></pre></td></tr></table></figure><p><strong>4.修改main.cpp的代码</strong><br>根据原作者的readme，打开main.cpp修改与数据库有关的信息，改为自己创建的数据库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-comment">//需要修改的数据库信息,登录名,密码,库名</span><br>    string user = <span class="hljs-string">&quot;root&quot;</span>;<br>    string passwd = <span class="hljs-string">&quot;*********&quot;</span>;<br>    string databasename = <span class="hljs-string">&quot;mydb&quot;</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5.编译运行</strong><br>cd到webserver目录，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh ./build.sh<br></code></pre></td></tr></table></figure><p>这行代码用bash脚本执行.sh文件，文件内容很简单，其实就是执行make server语句<br><img src="/../img/webserver.png"><br>对应去看makefile文件<br><img src="/../img/webserver3.png"></p><p>在这里可能会出现编译失败的问题，尤其是找不到mysql.h这个文件，是因为没有装对应的API，执行下面的命令可以解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install libmysqlclient-dev<br></code></pre></td></tr></table></figure><p>上述顺利完成后，此时应该已经编译得到了server文件，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ./server<br></code></pre></td></tr></table></figure><p>运行后无反应卡住，说明服务端正在运行。</p><p><strong>6.客户端连接</strong><br>直接在另一台电脑，或者本地电脑的浏览器上输入ip:9006即可<br>注意：如果是本机作为客户端，ip要写回环地址127.0.0.1<br><img src="/../img/webserver4.png"><br>出现上述页面，说明部署成功，此时可以按照readme上的提示进行一些功能验证以及压测</p>]]></content>
    
    
    <categories>
      
      <category>TinyWebserver</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VScode + CMake 编译C++</title>
    <link href="/2025/04/07/%E2%80%9CVScode%20+%20CMake%E7%BC%96%E8%AF%91c++%E2%80%9D/"/>
    <url>/2025/04/07/%E2%80%9CVScode%20+%20CMake%E7%BC%96%E8%AF%91c++%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>网上利用vscode进行c&#x2F;c++编程有一大堆教程，但我觉得太复杂，这里开始学习利用vscode+cmake进行c++工程的编写，同时加深自己对cmake的了解</p><h2 id="前期必备的一些工具"><a href="#前期必备的一些工具" class="headerlink" title="前期必备的一些工具"></a>前期必备的一些工具</h2><ul><li>vscode</li><li>cmake（自行百度下载）</li><li>vscode扩展包括C++三件套，CMake，CMake Tools</li></ul><h2 id="举例利用cmake创建一个新的工程"><a href="#举例利用cmake创建一个新的工程" class="headerlink" title="举例利用cmake创建一个新的工程"></a>举例利用cmake创建一个新的工程</h2><ol><li><p>创建一个新的文件夹CmakeStudy</p></li><li><p>利用CMake:Quick Start命令创建一个CMake工程project1，选择自己电脑合适的编译器，结果如下：<br><img src="/../img/cmake1.png"></p></li><li><p>利用左下角三个按钮可以分别进行编译链接build，debug，和运行<br><img src="/../img/cmake2.png"></p></li><li><p>此时总的CMakeLists如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>.<span class="hljs-number">0</span>) <br><span class="hljs-keyword">project</span>(project1 VERSION <span class="hljs-number">0.1</span>.<span class="hljs-number">0</span> LANGUAGES C CXX)<br><br><span class="hljs-keyword">add_executable</span>(project1 main.cpp)<br><br><span class="hljs-keyword">include</span>(CTest)<br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-keyword">set</span>(CPACK_PROJECT_NAME <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><span class="hljs-keyword">set</span>(CPACK_PROJECT_VERSION <span class="hljs-variable">$&#123;PROJECT_VERSION&#125;</span>)<br><span class="hljs-keyword">include</span>(CPack)<br><br></code></pre></td></tr></table></figure></li><li><p>创建一个新的同级文件夹lesson1，里面添加add.cpp add.h main.cpp三个文件，执行一个简单的利用add函数完成相加的功能</p></li><li><p>在lesson1目录下创建一个新的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(lesson1 main.cpp add.cpp)<br></code></pre></td></tr></table></figure></li><li><p>将整个工程的CMakeLists中的内容改为</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>.<span class="hljs-number">0</span>) <br><span class="hljs-keyword">project</span>(project1 VERSION <span class="hljs-number">0.1</span>.<span class="hljs-number">0</span> LANGUAGES C CXX)<br><br><span class="hljs-keyword">add_subdirectory</span>(lesson1)       //修改这里为添加子目录<br><br><span class="hljs-keyword">include</span>(CTest)<br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-keyword">set</span>(CPACK_PROJECT_NAME <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><span class="hljs-keyword">set</span>(CPACK_PROJECT_VERSION <span class="hljs-variable">$&#123;PROJECT_VERSION&#125;</span>)<br><span class="hljs-keyword">include</span>(CPack)<br></code></pre></td></tr></table></figure></li><li><p>编译，运行：<br><img src="/../img/cmake3.png"></p></li><li><p>可以在最外层的工程CMakeLists中加入语句从而支持c++11</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">True</span>)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“Effective Modern C++” 第一章 类型推导</title>
    <link href="/2025/04/03/%E2%80%9CEffective%20Modern%20C++%E2%80%9D%20%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2025/04/03/%E2%80%9CEffective%20Modern%20C++%E2%80%9D%20%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="base1-不同位置的const"><a href="#base1-不同位置的const" class="headerlink" title="base1 : 不同位置的const"></a>base1 : 不同位置的const</h2><p>通过下述代码进行解析，从访问权限和内存地址角度出发</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = a;  <span class="hljs-comment">//通过，a相当于是在常量区的某一个位置的10，允许将其拷贝给b</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//p是一个具有const属性的指针，指针指向的内容是具有const属性的int类型数据区域</span><br>    <span class="hljs-type">int</span> *p1 = p;    <span class="hljs-comment">//不通过！只看指针，p的内容拷贝给p1没有问题</span><br>                    <span class="hljs-comment">//但是看指针指向的区域，p1指向的区域没有const属性，与p指向的区域冲突，存在通过p1修改p指向的具有const属性区域的风险</span><br>    <br>    <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p2 = p;  <span class="hljs-comment">//不通过！const修饰p2，只是让p2指针具有const，但p2指向的区域依旧不是const，与p1的错误一致</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> *p3 = p;  <span class="hljs-comment">//通过，可以将p的内容拷贝给p3，只是p3不能再修改，同时p3指向的区域也具有const，不会和p产生冲突</span><br><br>    <span class="hljs-type">int</span> *p4 = &amp;a;   <span class="hljs-comment">//不通过！a在常量区，存在通过p4指针修改常量区的风险</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = <span class="hljs-number">20</span>; <span class="hljs-comment">//通过，const 引用可绑定临时对象，编译器隐式生成匿名对象并延长生命周期</span><br>    <span class="hljs-type">int</span> &amp;r2 = a;    <span class="hljs-comment">//不通过！a在常量区，存在通过r2引用修改常量区的风险</span><br>    <span class="hljs-type">int</span> &amp;r3 = r1;   <span class="hljs-comment">//不通过，r1在常量区，存在通过r3引用修改常量区的风险</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="base2-左右值"><a href="#base2-左右值" class="headerlink" title="base2 : 左右值"></a>base2 : 左右值</h2><p>这一块代码默认禁止编译器进行返回值优化<br><strong>1. 判断以下代码执行了几次拷贝</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">geta</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//正常赋值</span><br>    <span class="hljs-keyword">return</span> a;   <span class="hljs-comment">//创建临时匿名变量如int tmp = a，执行一次拷贝</span><br>&#125;<br><br><span class="hljs-type">int</span> x = <span class="hljs-built_in">geta</span>(); <span class="hljs-comment">//将上述的tmp赋值给x，即x = tmp，执行一次拷贝，然后释放tmp</span><br></code></pre></td></tr></table></figure><p>两次，如注释。返回值是int、double等，其实影响不大，因为很小，但是如果返回值是一个很大的自定义的结构体或者类对象等，那这两次拷贝就很浪费时间和空间。</p><p><strong>2. 为什么拷贝构造函数的输入参数一般是常引用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass &amp;other)&#123;<br>    <span class="hljs-comment">//完成拷贝操作</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>必须是引用：如果不是引用，那么传参的形式就会是值传递，需要把other拷贝后传入参数，这个拷贝的过程又会触发拷贝构造函数，从而造成无限循环</li><li>一般加const：因为常量参数可以接收非常量和常量输入，但是非常量参数无法接收常量输入</li></ul><p><strong>3. 左值和右值</strong><br>左值：可以直接取地址<br>右值：不能直接取地址，例如临时变量等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *x = &amp;a++;   <span class="hljs-comment">//错误，不能存右值的地址，与下述fun1函数类似</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;<br>    <span class="hljs-type">int</span> b = a;<br>    a = a + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-type">int</span> *x = &amp;++a;   <span class="hljs-comment">//通过，与下述fun2函数类似</span><br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;<br>    a = a + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. 右值引用和移动语义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp;x = <span class="hljs-built_in">move</span>(a);<br></code></pre></td></tr></table></figure><p>move函数将左值a转换为右值，再用右值引用x进行绑定，右值引用x是个左值，可以取地址，右值引用绑定的右值，会延长生命周期与右值引用的生命周期保持一致<br>move的本质类似于一个类型转换，例如static_ccast&lt;int &amp;&amp;&gt;</p><p>移动语义实际是指移动构造函数里，将原对象指向的资源剥夺给新对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">MyClass <span class="hljs-title">get_class</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass &amp;a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a;       <span class="hljs-comment">//这里会创建一个临时变量tmp，即MyClass tmp = a；发生一次拷贝构造</span><br>&#125;<br><br><span class="hljs-function">MyClass <span class="hljs-title">make_class</span><span class="hljs-params">()</span></span>&#123;<br>    MyClass b;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_class</span>(b);    <span class="hljs-comment">//这里会创建一个临时变量tmp2，将上面的临时变量tmp赋给tmp2，即MyClass tmp2 = tmp; 由于tmp是右值，所以调用移动构造</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MyClass c = <span class="hljs-built_in">make_class</span>();   <span class="hljs-comment">//这里会利用上述的临时变量tmp2，赋值给c，由于tmp2是右值，调用移动构造</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会发生一次拷贝构造，两次移动构造</p><p><strong>5. 函数指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(*funPtr)</span> <span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>   <span class="hljs-comment">//funPtr是函数指针，输入参数是两个int，返回类型是bool</span></span><br><span class="hljs-function"><span class="hljs-comment">//等价于</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> funPtr </span>= <span class="hljs-built_in">bool</span> (*) (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h2 id="条款1：理解模板类型的推导"><a href="#条款1：理解模板类型的推导" class="headerlink" title="条款1：理解模板类型的推导"></a>条款1：理解模板类型的推导</h2><h2 id="条款7：区别使用-和-创建对象"><a href="#条款7：区别使用-和-创建对象" class="headerlink" title="条款7：区别使用()和{}创建对象"></a>条款7：区别使用()和{}创建对象</h2><p>先看传统()初始化的使用会带来的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-comment">//有自己的带参构造函数</span><br>    <span class="hljs-comment">//有自己的拷贝构造函数</span><br>&#125;;<br><br>A a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//只能接收一个参数，同时会发生一次额外的拷贝</span><br>            <span class="hljs-comment">//这里会把10先进行一个隐式转换成类A对象，然后执行一次拷贝构造，浪费空间时间</span><br><br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-comment">//这样子构造不会发生额外的拷贝，但是如果是作为函数参数或者返回值时，还是会发生拷贝</span><br><span class="hljs-comment">//例如</span><br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>);   <span class="hljs-comment">//在没开启返回值优化时，会创建一个临时变量 A tmp = A(10)，这里发生拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><p>出现问题：</p><ul><li>只能接收一个参数，同时会发生一次额外的拷贝</li><li>可能额外发生拷贝，或者有些类不允许拷贝的话还会报错</li><li>作为函数参数或者返回值时，可能还是会发生拷贝</li></ul><p>如果使用{}列表初始化，可以完美解决上述问题</p><ul><li>允许接收多个参数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2.0</span>&#125;;<br></code></pre></td></tr></table></figure></li><li>不允许缩窄转换<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//假设类A的构造函数传入参数是两个int</span><br>A a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>&#125;; <span class="hljs-comment">//报错！不允许将double转为int</span><br></code></pre></td></tr></table></figure></li><li>大大简化了聚合类的初始化，聚合类是指没有构造函数的类，且没有私有成员</li><li>不会出现C++令人头疼的解析问题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//假设我们想利用一个函数returnA返回的值进行初始化</span><br>A a = <span class="hljs-built_in">returnA</span>();    <span class="hljs-comment">//通过</span><br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(returnA())</span></span>;     <span class="hljs-comment">//也能通过，但是这不是初始化，c++会把它识别为函数声明，一个输入参数为函数指针，返回类型为A的函数声明</span><br><br>A a&#123;<span class="hljs-built_in">returnA</span>()&#125;;     <span class="hljs-comment">//列表初始化就不会出现这个问题</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="条款2：理解auto类型推导（与模板推导有很多重叠的地方）"><a href="#条款2：理解auto类型推导（与模板推导有很多重叠的地方）" class="headerlink" title="条款2：理解auto类型推导（与模板推导有很多重叠的地方）"></a>条款2：理解auto类型推导（与模板推导有很多重叠的地方）</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统命令</title>
    <link href="/2025/04/03/hello-world/"/>
    <url>/2025/04/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“C++ Primer Plus” 第十二章 类和动态内存分配</title>
    <link href="/2025/01/26/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <url>/2025/01/26/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“C++ Primer Plus” 第十一章 运算符重载和友元函数</title>
    <link href="/2025/01/23/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <url>/2025/01/23/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>运算符重载是一种形式的c++多态</p><h2 id="11-1-运算符重载"><a href="#11-1-运算符重载" class="headerlink" title="11.1 运算符重载"></a>11.1 运算符重载</h2><p>例如，对于两个数组元素相加，一般只能通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>    <span class="hljs-type">int</span> a[i] = b[i] + c[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>但是在c++中，可以通过设计一个类表示数组，并重载+运算符，便可以有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">classname a = b + c;<br></code></pre></td></tr></table></figure><p>重载运算符，需使用被称为运算符函数的特殊函数形式，格式为：<br><code>operatorop(args-list)</code></p><h2 id="11-2-通过一个运算符重载的实例来详细了解"><a href="#11-2-通过一个运算符重载的实例来详细了解" class="headerlink" title="11.2 通过一个运算符重载的实例来详细了解"></a>11.2 通过一个运算符重载的实例来详细了解</h2><p>假设定义了一个类，用来表示时间，私有变量有minutes，seconds，如果想将两个时间类对象相加，则成员函数中需要定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Time <span class="hljs-title">Time::Sum</span><span class="hljs-params">(<span class="hljs-type">const</span> Time&amp; t)</span> <span class="hljs-type">const</span></span>&#123;<br>    Time sum;<br>    sum.minutes = minutes + t.minutes;<br>    sum.seconds = seconds + t.seconds;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//假设有Time a, Time b, 下述两个语句都可以</span><br>a.<span class="hljs-built_in">Sum</span>(b);<br>b.<span class="hljs-built_in">Sum</span>(a);<br></code></pre></td></tr></table></figure><p>在没有运算符重载时，只能通过上述方式完成，有了运算符重载后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在类声明中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        ...<br>        Time <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Time&amp; t) <span class="hljs-type">const</span>;<br>&#125;<br><br><span class="hljs-comment">//在类定义中</span><br>Time Time::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Time&amp; t) <span class="hljs-type">const</span>&#123;<br>    Time sum;<br>    sum.minutes = minutes + t.minutes;<br>    sum.seconds = seconds + t.seconds;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">//完成上述对+运算符重载后，便可以</span><br>Time c = a + b;         <span class="hljs-comment">//对运算符重载的隐式调用</span><br><span class="hljs-comment">//其实等价于</span><br>Time c = a.<span class="hljs-keyword">operator</span>+(b);        <span class="hljs-comment">//对运算符重载的显式调用</span><br><br>Time d = a + b + c;     <span class="hljs-comment">//等价于 Time d = (a.operator+(b)).operator+(c)</span><br></code></pre></td></tr></table></figure><p>运算符重载也有限制：</p><ol><li>重载后的运算符必须至少有一个操作数是用户定义的类型，防止用户为标准类型重载运算符</li><li>使用运算符时不能违反运算符本来的句法规则，例如%重载为使用一个操作数： %a;</li><li>不能创建新的运算符，例如operator**()，不存在**运算符</li><li>不能重载的运算符：<ul><li>成员访问运算符    .</li><li>成员指针访问运算符    .*</li><li>域运算符      ::</li><li>长度运算符        sizeof</li><li>条件运算符        ?   :</li></ul></li><li>大多数运算符都可以通过成员函数或者非成员函数重载，但下面运算符只能通过成员函数进行重载<ul><li>赋值运算符    &#x3D;</li><li>函数调用运算符    ()</li><li>下标运算符    []</li><li>指针访问类运算符      -&gt;</li></ul></li></ol><p>我们继续改进上述代码，对Time类添加乘法*运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类声明</span><br>Time <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n) <span class="hljs-type">const</span>;<br><br><span class="hljs-comment">//类定义</span><br>Time Time::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n) <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-comment">//省略代码，大概意思就是让时间乘以一个倍数，再将结果换算为分，秒</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-3-友元"><a href="#11-3-友元" class="headerlink" title="11.3 友元"></a>11.3 友元</h2><p>c++控制对类对象私有部分的访问，通常是能通过公有类方法访问私有部分，但其实c++还提供了另外一种形式的访问权限：友元。</p><p>友元有3中：</p><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul><p>通过让函数称为类的友元，可以赋予该函数与类的成员函数相同的访问权限，下面先介绍友元函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//假设有两个Time类，Time A 和 Time B</span><br><span class="hljs-comment">//根据上一小节的最后，我们定义的乘法*运算符重载，可以执行：</span><br>A = B * <span class="hljs-number">2.65</span>;<br><br><span class="hljs-comment">//但是不能执行</span><br>A = <span class="hljs-number">2.65</span> * B;<br><br><span class="hljs-comment">//因为</span><br>A = B * <span class="hljs-number">2.65</span> 等价于 A = B.<span class="hljs-keyword">operator</span>*(<span class="hljs-number">2.65</span>)<br><span class="hljs-comment">//但是</span><br>A = <span class="hljs-number">2.65</span> * B 无法等价于 A = <span class="hljs-number">2.65</span>.<span class="hljs-keyword">operator</span>*(B)<br></code></pre></td></tr></table></figure><p>从概念上，B * 2.65 与 2.65 * B一致，但是由于重载函数的特性，无法从语法上完成编译，因此改进为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//再定义一个重载函数，但是这个重载函数与Time无关，即该函数声明在Time类外，不在Time类方法里</span><br>Time <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> m, <span class="hljs-type">const</span> Time&amp; t);<br><br>A = B * <span class="hljs-number">2.65</span>;       <span class="hljs-comment">//执行Time类里重载的函数</span><br>A = <span class="hljs-number">2.65</span> * B;       <span class="hljs-comment">//执行Time类外重载的函数</span><br></code></pre></td></tr></table></figure><p>上述流程看起来很好，但其实很致命的问题是，在Time类外定义的重载函数，传递了Time类对象，并且由于函数特性要用到私有变量（乘法即要用到里面的minutes和seconds），也就是说，通过类外的函数访问了类对象的私有变量，这是不被允许的。</p><p>如何将该类外的重载函数赋予能访问类对象私有变量的权限，就是通过友元函数</p><p>友元函数创建：</p><ol><li>将函数声明放在类声明中，并在原型声明前加上关键字friend</li><li>编写函数定义，因为不属于成员函数，所以不能使用Time::限定符</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类声明</span><br><span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Time&amp; t) <span class="hljs-type">const</span>;<br><br><span class="hljs-comment">//类定义</span><br>Time <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Time&amp; t) <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-comment">//省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，才能完成A &#x3D; B * 2.65 与 A &#x3D; 2.65 * B 的互换</p><p><strong>友元函数是否有悖于OOP？</strong>     没有，因为实质上还是要在类声明中决定哪个函数是友元，既然最终掌控权在类声明中，那么友元函数就变成相当于另一种形式的类方法</p><p>实际上，如果只是想完成上述乘法，可以不通过友元函数，只要将类外面声明且定义的重载函数改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Time <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Time&amp; t)&#123;<br>    <span class="hljs-keyword">return</span> t * n;       <span class="hljs-comment">//调用类内的重载，即t.operator*(n)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码没有触及类的私有成员，只涉及类对象本身，因此可以正常编译</p><p>下面介绍更常用的运算符重载&lt;&lt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>cout &lt;&lt; x;      <span class="hljs-comment">//cout是ostream类，里面有&lt;&lt;运算符重载，相当于cout.operator&lt;&lt;(x)</span><br><br>Time a;<br>cout &lt;&lt; a;      <span class="hljs-comment">//无法执行，因为Time是用户自定义的类，但是ostream里没有重载&lt;&lt;使之可以输出Time类</span><br></code></pre></td></tr></table></figure><p>为了解决上述问题，我们可以直接修改ostream类标准文件里的重载，把对Time类的重载添加上去，但是这种操作太危险了。因此我们最好是通过，在Time类里重载&lt;&lt;运算符，让Time知道如何用cout</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类声明</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; a);<br><span class="hljs-comment">//类声明</span><br><span class="hljs-type">void</span> Time::<span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; a)&#123;<br>    a &lt;&lt; <span class="hljs-keyword">this</span>.minutes;<br>&#125;<br><br><span class="hljs-comment">//有了这个类定义，就可以直接利用&lt;&lt;输出Time</span><br>Time a;<br>a &lt;&lt; cout;      <span class="hljs-comment">//相当于a.operator&lt;&lt;(cout)</span><br></code></pre></td></tr></table></figure><p>但是这种重载非常奇怪，不符合我们使用的形式<code>cout&lt;&lt;a</code>，因此利用友元函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类内对友元函数声明</span><br><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; a, <span class="hljs-type">const</span> Time&amp; t);<br><br><span class="hljs-comment">//类外定义友元函数</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; a, <span class="hljs-type">const</span> Time&amp; t)&#123;<br>    a &lt;&lt; t.minutes;<br>&#125;<br><br><span class="hljs-comment">//有了友元后</span><br>Time x;<br>cout &lt;&lt; x;      <span class="hljs-comment">//调用标识为友元函数的&lt;&lt;重载函数，相当于执行了operator&lt;&lt;(cout, x)</span><br></code></pre></td></tr></table></figure><p>第一次看的时候不理解，其实可以这么去记：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">Time a;<br><span class="hljs-comment">//对于类内定义的运算符重载函数</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; a);<br><span class="hljs-comment">//执行时</span><br>a &lt;&lt; cout;  <span class="hljs-comment">//相当于a.operator&lt;&lt;(cout);</span><br><br><span class="hljs-comment">//对于类外定义的友元运算符重载函数</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; a, <span class="hljs-type">const</span> Time&amp; t);<br><span class="hljs-comment">//执行时</span><br>cout &lt;&lt; a;  <span class="hljs-comment">//相当于operator&lt;&lt;(cout, a)，即运算符左边默认对应函数第一个参数，右边默认对应函数第二个参数</span><br></code></pre></td></tr></table></figure><h2 id="11-4-类的自动转换和强制类型转换"><a href="#11-4-类的自动转换和强制类型转换" class="headerlink" title="11.4 类的自动转换和强制类型转换"></a>11.4 类的自动转换和强制类型转换</h2><p>直接用代码介绍概念：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//自动转换</span><br><span class="hljs-type">long</span> count = <span class="hljs-number">8</span>;     <span class="hljs-comment">//将int类型的8自动转换为long类型的8</span><br><span class="hljs-type">double</span> time = <span class="hljs-number">11</span>;   <span class="hljs-comment">//将int类型的11自动转换为double类型的11</span><br><span class="hljs-type">int</span> side = <span class="hljs-number">3.13</span>;    <span class="hljs-comment">//将double类型的3.13自动转换为int类型，舍去精度变为3</span><br><br><span class="hljs-comment">//强制类型转换</span><br><span class="hljs-type">int</span>* p = <span class="hljs-number">10</span>;    <span class="hljs-comment">//不合法，不允许将int类型10自动转换为指针</span><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*) <span class="hljs-number">10</span>;     <span class="hljs-comment">//合法，利用强制转换，将int类型的10转换为以10为地址</span><br></code></pre></td></tr></table></figure><p>对于类而言，也可以用强制类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//假设有一个类叫做Stonewt</span><br><span class="hljs-comment">//类的构造函数为</span><br>Stonewt::<span class="hljs-built_in">Stonewt</span>(<span class="hljs-type">int</span> weight);<br><br><span class="hljs-comment">//可以利用构造函数创建一个类对象</span><br><span class="hljs-function">Stonewt <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;   <br><span class="hljs-comment">//也可以利用类型转换</span><br>Stonewt test2;<br>test2 = <span class="hljs-number">5</span>;      <span class="hljs-comment">//这样相当于是隐式的类型转换，但这样容易出问题</span><br>test2 = (Stonewt) <span class="hljs-number">5</span>;    <span class="hljs-comment">//也可以显式转换</span><br><br><span class="hljs-comment">//如果类的构造函数为</span><br>Stonewt::<span class="hljs-built_in">Stonewt</span>(<span class="hljs-type">int</span> weight, <span class="hljs-type">int</span> num);<br><span class="hljs-comment">//那么将不能使用类型转换，除非把后面的参数都设置了默认值</span><br><br></code></pre></td></tr></table></figure><p>只有接受一个参数的构造函数才能作为转换函数</p><p>类的隐式自动转换容易出问题，因此c++新增了关键字explicit，用于关闭这种自动特性，也就是说可以声明构造函数为<br><code>explicit Stonewt::Stonewt(int weight);</code><br>这将关闭上述的隐式转换，即不允许<br><code>test2 = 5; </code><br>但还允许显示转换，即强制类型转换<br><code>test2 = (Stonewt) 5;  </code></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“C++ Primer Plus” 第十章 对象和类</title>
    <link href="/2025/01/21/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <url>/2025/01/21/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>面向对象编程OOP最重要的特性：抽象；封装和数据隐藏；多态；继承；代码的可重用性；</p><p>这一章介绍的内容主要体现了OOP的抽象、封装和数据隐藏的特性</p><p>为了实现这些特性，c++所做的最重要的改进是提供了类</p><h2 id="10-1-过程性编程和OOP编程"><a href="#10-1-过程性编程和OOP编程" class="headerlink" title="10.1 过程性编程和OOP编程"></a>10.1 过程性编程和OOP编程</h2><p>过程性编程，首先考虑要遵循的步骤，然后考虑如何表示这些数据</p><p>OOP编程，首先从用户的角度考虑对象——描述对象所需的数据以及描述用户与数据交互所需的操作。</p><h2 id="10-2-抽象和类"><a href="#10-2-抽象和类" class="headerlink" title="10.2 抽象和类"></a>10.2 抽象和类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 类名<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//公共的行为或属性</span><br> <br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//公共的行为或属性</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>类的设计可以实现抽象接口，它将数据表示和操纵数据的方法组合成一个整洁的包，通常c++程序员将接口放在头文件中（成员变量声明，成员函数声明），将实现（成员函数的定义，也就是类方法的定义）放在源代码文件中</li><li>c++的类提供三个关键字进行访问控制，private，public，protected，本章介绍前两个</li><li>使用类对象的程序都可以访问公有部分，但是外部无法访问类对象的私有部分，只能通过类对象的公有部分访问类对象的私有部分（友元函数例外），共有成员相当于充当外部程序与对象私有成员的桥梁，提供了对象和程序之间的接口，防止程序直接可以访问对象数据，这也被称为数据隐藏</li><li>类的设计尽可能将公有接口和实现细节分开，公有接口表示设计的抽象组件，将实现细节放在一起并将其与抽象分开，叫做封装</li><li>数据项通常放在私有部分，组成类接口的成员函数放在公有部分</li><li>在进行成员函数的定义时，利用作用域解析运算符::来标识函数所属的类</li><li>客户-服务器模型： OOP程序通常依照客户-服务器模型来讨论设计，客户相当于使用类的程序，服务器相当于类声明，客户只能以公有方式定义的接口来访问服务器，也就是说客户只需要了解接口即可</li></ol><h2 id="10-3-类的构造函数和析构函数"><a href="#10-3-类的构造函数和析构函数" class="headerlink" title="10.3 类的构造函数和析构函数"></a>10.3 类的构造函数和析构函数</h2><ol><li>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span><br>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span>;<br>      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br>      <span class="hljs-built_in">Line</span>();  <span class="hljs-comment">// 这是构造函数</span><br> <br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">double</span> length;<br>&#125;;<br> <br><span class="hljs-comment">// 成员函数定义，包括构造函数</span><br>Line::<span class="hljs-built_in">Line</span>(<span class="hljs-type">void</span>)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object is being created&quot;</span> &lt;&lt; endl;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Line::setLength</span><span class="hljs-params">( <span class="hljs-type">double</span> len )</span></span><br><span class="hljs-function"></span>&#123;<br>    length = len;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Line::getLength</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><span class="hljs-comment">// 程序的主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>   Line line;<br> <br>   <span class="hljs-comment">// 设置长度</span><br>   line.<span class="hljs-built_in">setLength</span>(<span class="hljs-number">6.0</span>); <br>   cout &lt;&lt; <span class="hljs-string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="hljs-built_in">getLength</span>() &lt;&lt;endl;<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用构造函数有两种方式：<ul><li>显示地调用构造函数<br> <code>Stock food = Stock(&quot;world cabbage&quot;, 250, 1.25);</code></li><li>隐式调用<br> <code>Stock food(&quot;world cabbage&quot;, 250, 1.25);</code></li><li>其实也可以和new配合<br> <code>Stock* pstock = new Stock(&quot;world cabbage&quot;, 250, 1.25);</code></li></ul></li><li>无法使用对象去执行构造函数，因为构造函数是用来构建对象的，不能通过对象来调用</li><li>默认构造函数：如果没有提供构造函数，则c++会默认提供默认构造函数，即<br><code>Stock::Stock()&#123;&#125;</code></li><li>当且仅当没有定义构造函数时，编译器才会默认提供默认构造函数，如果为类提供了构造函数，则必须为其提供默认构造函数，否则下述语句会报错<br><code>Stock stock;</code></li><li>定义默认构造函数的方法有两种，一种是给已有构造函数的所有参数提供默认值，另一种方式是通过函数重载来定义另一种构造函数（一个没有参数的构造函数），但是不能同时采用这两种方式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Stock::<span class="hljs-built_in">Stock</span>()&#123;<br>    company = <span class="hljs-string">&quot;no_name&quot;</span>;<br>    shares = <span class="hljs-number">0</span>;<br>    share_val = <span class="hljs-number">0</span>;<br>    total_val = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>析构函数用于完成清理工作，析构函数的定义和构造函数很像，区别在于：<ul><li>在类名前加<del>，&#96;</del>Stock()&#96;</li><li>析构函数不仅没有返回值和生命类型，也没有参数</li></ul></li><li>析构函数被调用的时机：<ul><li>如果创建的是静态存储对象，则其析构函数将在程序结束时自动被调用</li><li>如果创建的是自动存储类型的变量，则在程序执行完所属的代码块后自动被调用</li><li>如果是new创建的对象，则使用delete释放内存时，析构函数自动被调用</li></ul></li><li>也可以用c++11进行类的列表初始化</li><li>类的成员函数也是可以通过const关键字进行声明，但是声明应变为：<br><code>void show() const;</code><br>同理定义应该变为：<br><code>Stock::void show() const&#123;...&#125;;</code><br>以这种方式声明和定义的函数叫做const成员函数，只要类方法不修改调用对象，就应该将其声明为const</li></ol><h2 id="10-4-this指针"><a href="#10-4-this指针" class="headerlink" title="10.4 this指针"></a>10.4 this指针</h2><p>我们来看下述代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> Stock&amp; <span class="hljs-title">Stock::topval</span><span class="hljs-params">(<span class="hljs-type">const</span> Stock&amp; s)</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.total_val &gt; total_val) <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ???;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码，我们知道传入的对象是s，但如果要返回的是调用该函数的对象本身，则无法描述。</p><p>c++提供叫做this的特殊指针，指向用来调用成员函数的对象，注意this只是指针，如果要表示对象，应该用*this，因此代码变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> Stock&amp; <span class="hljs-title">Stock::topval</span><span class="hljs-params">(<span class="hljs-type">const</span> Stock&amp; s)</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s.total_val &gt; total_val) <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设有两个Stock类，一个叫Mike，一个叫Jack，想要获得Mike和Jack中total_val的最大值，可以通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Stock temp = Mike.<span class="hljs-built_in">topval</span>(Jack);<br>Stock temp = Jack.<span class="hljs-built_in">topval</span>(Mike);<br></code></pre></td></tr></table></figure><h2 id="10-5-对象数组"><a href="#10-5-对象数组" class="headerlink" title="10.5 对象数组"></a>10.5 对象数组</h2><p>和普通类型数据数组声明一样，对象数组可以直接通过下述声明：<br><code>Stock mystuff[4]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Stock mystuff[<span class="hljs-number">4</span>] = &#123;<br>    <span class="hljs-built_in">Stock</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>),<br>    <span class="hljs-built_in">Stock</span>(),<br>    <span class="hljs-built_in">Stock</span>(<span class="hljs-string">&quot;world&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>剩余一个对象将会自动用默认构造函数构造</p><p>初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到对应元素中，因此，要创建对象数组，则这个类必须有默认构造函数</p><h2 id="10-6-类作用域"><a href="#10-6-类作用域" class="headerlink" title="10.6 类作用域"></a>10.6 类作用域</h2><p>来看下述代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bakery</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> Months = <span class="hljs-number">12</span>;<br>        <span class="hljs-type">double</span> costs[Months];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看可行，其实不行，第一句就会报错，因为这只是声明类，并没有创建对象，将没有用于存储值的空间</p><p>如果想要所有类共享某个常量，例如所有类的数组中的月份总数都设为常量12，可以通过另外两种办法进行：</p><ol><li>在类中声明一个枚举<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bakery</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">enum</span> &#123;Months = <span class="hljs-number">12</span>&#125;;<br>        <span class="hljs-type">double</span> costs[Months];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用关键字static<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bakery</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> Months = <span class="hljs-number">12</span>;<br>        <span class="hljs-type">double</span> costs[Months];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>这将直接创建一个名为Months的静态常量，并与其它静态常量存储在一起，因此只有一个Months，将被所有Bakery类共享</li></ol><p>关于枚举，说个题外话，我们再来看以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">egg</span> &#123;small, large&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Tshirt</span> &#123;small, large&#125;;<br></code></pre></td></tr></table></figure><p>这将无法通过编译，因为两行代码的作用域是一样的，当使用某一个enum例如small时，会发生冲突</p><p>c++11提供一种新枚举方式解决这种问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">egg</span> &#123;small, large&#125;;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Tshirt</span> &#123;small, large&#125;;<br></code></pre></td></tr></table></figure><p>将枚举量的作用域设置为类后，便不会发生冲突，使用时可以通过<code>egg::small 或者 Tshirt::small</code>进行区分</p><p>默认情况下c++11作用域内枚举的底层类型为int</p><h2 id="10-7-抽象数据类型"><a href="#10-7-抽象数据类型" class="headerlink" title="10.7 抽象数据类型"></a>10.7 抽象数据类型</h2><p>什么叫做抽象数据类型呢？个人认为，抽象数据类型就是c++本身没有提供的数据类型，例如设计了一个类叫做Stock，虽然书上说，这个数据类型Stock类非常具体，但我认为它也能被叫做抽象数据类型，只是比较具体而已，c++通过使用类来设计抽象数据类型（ADT）</p><p>最简单的例子，栈，属于ADT，可以用一个类来声明栈，这个类需要有：</p><ul><li>类方法：创建空栈，查看是否栈满，查看是否栈空，入栈，出栈等</li><li>类数据成员：例如用数组实现栈，则需要定义数组，还需要定义指针，数组空间（栈空间）等</li></ul><p>用户不需要管栈具体是怎么实现的，底层可能是数组，但只要了解接口（类方法），就可以将这个底层是数组且配合上提供的类方法的类，抽象为一个我们所熟悉使用的栈，这也就是通过类来设计ADT</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“C++ Primer Plus” 第九章 内存模型和名称空间</title>
    <link href="/2025/01/20/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <url>/2025/01/20/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="9-1-单独编译"><a href="#9-1-单独编译" class="headerlink" title="9.1 单独编译"></a>9.1 单独编译</h2><p>都是些头文件，防重复包含的知识，跳过</p><h2 id="9-2-存储持续性、作用域和链接性"><a href="#9-2-存储持续性、作用域和链接性" class="headerlink" title="9.2 存储持续性、作用域和链接性"></a>9.2 存储持续性、作用域和链接性</h2><ol><li>c++使用四种不同的方案来存储数据，即有四种存储持续性：<ul><li>自动存储持续性：在函数定义中声明的变量包括函数参数</li><li>静态存储持续性：在函数定义外定义的变量和用关键字static定义的变量，在程序运行过程中一直存在</li><li>动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete，有时也被称为堆</li><li>线程存储持续性（c++11）：在多核处理器的背景下，使用关键字thread_local声明的变量，则其生命周期和线程一样长</li></ul></li><li>作用域和链接：<ul><li>作用域描述了名称在文件的多大范围内可见，链接性描述了名称如何在不同单元之间共享</li><li>c++的作用域分为局部和全局</li><li>c++函数的作用域可以是整个类或整个名称空间，但不能是局部的</li></ul></li><li>自动存储持续性：<ul><li>默认情况下在函数中声明的函数参数和变量都属于自动变量，作用域为局部，没有链接性，当函数结束时这些变量会自动被释放</li><li>自动变量的作用域在变量所在的花括号里，不包括包含的花括号，例如： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>        cout &lt;&lt; a;<br>    &#125;<br>    cout &lt;&lt; a;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>上述代码中，会先输出2再输出1，因为里面的花括号里新定义的a会隐藏以前的定义，新定义可见，旧定义暂时不可见，当里面的花括号内容执行完毕后新定义的a变量被释放，则旧定义又可见了</li><li>当函数被调用时，其传递参数也属于自动变量，传递的自动变量被压入栈中，函数内部创建的自动变量也会压入栈，当函数执行完成后会将栈顶指针回复到函数调用前的位置，以达到释放自动变量的效果</li><li>关键字register以前用于声明寄存器变量，也属于自动变量，它告诉编译器用CPU寄存器来存储自动变量，但c++11后这种关键字只是用来显示表明是自动变量，关键字auto以前是用来声明自动变量的，c++11后用来让编译器自动识别变量的类型</li></ul></li><li>静态持续变量：<ul><li>c++为静态存储持续性提供3种链接性：外部链接性，内部链接性，无链接性</li><li>无链接性：在函数定义的代码块内利用关键字static定义的变量，例如<code>static int x = 1</code>，这句代码在定义无链接性的静态变量时进行了初始化，如果多次执行该函数，初始化只会在第一次执行时进行初始化一次。当函数执行完成后，该静态变量也不会消失，依旧能够继续保存之前的内容，例如函数体内有<code>x++</code>，第一次执行完后x变为2，且x不会被释放，下一次调用该函数后x变为3</li><li>内部链接性：在文件内，函数定义之外的区域利用关键字static定义的变量，该变量的作用域是整个文件，该文件的所有函数都能访问到该变量，且该变量也只能初始化一次，不会被自动释放</li><li>外部链接性：在文件内，函数定义之外的区域定义的变量，该变量的作用域是整个文件，该文件的所有函数都能访问到该变量，同时，其它文件也可以使用该变量，只需要利用关键字extern进行声明，例如，在另一个文件进行声明<code>extern int x;</code>，编译器不会给该变量分配空间，自动在其他文件中寻找该变量。注意，利用extern声明的变量如果进行初始化，声明会变为定义，编译器会分配空间。</li><li>很多时候只是想定义常量数据，并且有外部链接性，那么可以在定义这种全局变量前加关键字const防止修改</li></ul></li><li>存储说明符和限定符：<ul><li>存储说明符有：auto, register, static, extern, thread_local, mutable, 大部分已经介绍过，其中mutable可以用来指出，当结构体或者类变量被const修饰时，可以在里面的某个成员前加上mutable，声明这个成员是特殊的，依旧可以修改，例如： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-type">const</span> data test = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>test.b = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li><li>上述代码也能通过</li><li>限定符也叫cv限定符，主要是const和volatile</li><li>volatile关键字表明，告诉编译器不要优化代码，因为即使程序代码没有修改某个变量，但是该变量也可能会变化。例如，某个变量和外部硬件有关，在系统不更改它的情况下，外部硬件的变化可能会导致该变量也变化，如果编译器发现经常访问该变量，则很可能自动优化为，将该变量存储在寄存器中以便提高访问速度，可是当某一次访问后编译器将该变量存储到寄存器中时，意味着下一次访问该变量时并不会发生变化，如果此时硬件导致变量发生了变化，而编译器访问的却是上一次存储的寄存器的值时，就会出现数据不准确的错误，volatile就是告诉编译器不要优化。</li></ul></li><li>动态分配<ul><li>c++使用new运算符来动态分配内存，分配的内存要通过delete手动释放</li><li>与自动内存不同，动态内存不是LIFO的，通常编译器会使用三块独立的内存，一块用于静态变量，一块用于自动变量，一块用于动态内存（堆）</li><li>定位new运算符：利用该特性需要包含头文件new，可以让分配的内存不在堆里自动分配，而是制定想要使用的位置，用法为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buffer[<span class="hljs-number">200</span>];<br><span class="hljs-type">int</span>* p1;<br>p1 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-type">int</span>[<span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="9-3-名称空间"><a href="#9-3-名称空间" class="headerlink" title="9.3 名称空间"></a>9.3 名称空间</h2><ol><li>考虑这种情况：例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。</li><li>引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</li><li>命名空间的定义使用关键字namespace，例如<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> namespace_name &#123;<br>   <span class="hljs-comment">// 代码声明</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>访问某个命名空间的某个声明时，可以利用作用域解析符::或者using命令或using编译</li><li>示例使用代码片段如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-comment">// 第一个命名空间</span><br><span class="hljs-keyword">namespace</span> first_space&#123;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Inside first_space&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;<br><span class="hljs-comment">// 第二个命名空间</span><br><span class="hljs-keyword">namespace</span> second_space&#123;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Inside second_space&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>   <span class="hljs-comment">// 调用第一个命名空间中的函数</span><br>   first_space::<span class="hljs-built_in">func</span>();<br>   <br>   <span class="hljs-comment">// 调用第二个命名空间中的函数</span><br>   second_space::<span class="hljs-built_in">func</span>(); <br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。        但是，现代程序员不推荐这样使用，因为会包含太多所指定的命名空间中不需要的内容，如果局部名称和命名空间名称冲突，则局部名称会覆盖名称空间的版本，而编译器不会发出警告。</li><li>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> namespace_name1 &#123;<br>   <span class="hljs-comment">// 代码声明</span><br>   <span class="hljs-keyword">namespace</span> namespace_name2 &#123;<br>      <span class="hljs-comment">// 代码声明</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>导入名称时，首选使用作用域解析运算符或using声明的方法</li><li>对于using声明，首选将其作用域设置为局部而不是全局</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“C++ Primer Plus” 第八章 函数探幽</title>
    <link href="/2025/01/19/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <url>/2025/01/19/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="8-1-c-内联函数"><a href="#8-1-c-内联函数" class="headerlink" title="8.1 c++内联函数"></a>8.1 c++内联函数</h2><ol><li>内联函数：使用<code>inline</code>关键字定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>内联函数遵循函数的定义规范，有明确的函数名，参数列表和返回类型，这是它和传统C风格中的宏定义#define最大的区别</li><li>编译器会选择性地判断内联函数，如果内联函数中函数体过大或进行了递归（内联函数不能自己调用自己），则编译器认为使用内联函数并不值得抵消普通函数切换过程带来的开销，因此即使加了inline关键字，也会把函数认为是普通函数。</li><li>如果内联函数的函数体小，则会用内联代码替换掉函数调用时的代码，有点类似宏定义#define</li><li>内联函数适用于那些调用频繁且函数体较小的函数。例如一些简单的计算函数、获取属性值的函数等。使用内联函数可以减少函数调用的开销，提高程序的运行效率，同时又保留了函数的类型检查和调试等优点。</li><li>宏定义则适用于一些简单的文本替换场景，如定义常量、简单的代码片段等。</li></ol><h2 id="8-2-引用变量"><a href="#8-2-引用变量" class="headerlink" title="8.2 引用变量"></a>8.2 引用变量</h2><ol><li>引用变量主要作用是用作函数的形参，通过将引用变量作为参数，函数将使用原始数据而不是其副本，节省资源，但要注意此时函数内的操作将可能会修改参数本身。</li><li>引用更接近<code>const</code>指针，必须在创建的时候进行初始化，一旦和某个变量关联起来，就将一直效忠于它。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>&amp; a = b;<br></code></pre></td></tr></table></figure></li><li>如果程序员的意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用变量不产生变量副本，则应该使用常量应用，也就是在前面加入关键字<code>const</code>，例如<code>const int&amp; a</code></li><li>使用const可以避免无意中对数据的修改，并且能够处理const和非const的实参，否则只能接受非const的实参</li><li>c++11新增了右值引用，这种引用可指向右值，是使用&amp;&amp;声明的</li><li>一般的常规变量直接使用值传递，稍微复杂点的变量使用引用参数传递，例如结构体，类等</li><li>由于c++继承的特性，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数，例如ostream&amp;作为参数的函数，可以接收ostream对象也可以接受ofstream对象</li></ol><h2 id="8-3-默认参数"><a href="#8-3-默认参数" class="headerlink" title="8.3 默认参数"></a>8.3 默认参数</h2><ol><li>例如<code>char* left(const char* str, int n = 1);</code> 在使用这个函数时可以直接使用<code>left(str, 2)</code>，也可以省略掉后面的n，变成<code>left(str)</code>，这样会默认n&#x3D;1</li><li>在以后设计类时，通过使用默认参数，可以减少要定义的析构函数、方法、以及方法重载的数量</li><li>必须从右向左添加默认值，也就是说如果要为函数中某个参数设置默认值，则参数列表中该参数右边的所有参数也必须提供默认值</li></ol><h2 id="8-4-函数重载"><a href="#8-4-函数重载" class="headerlink" title="8.4 函数重载"></a>8.4 函数重载</h2><ol><li>函数多态（函数重载）可以让程序员能够使用多个同名的函数，c++通过上下文来确定重载函数对应的版本</li><li>函数重载的关键是函数的参数列表，也称为函数特征标。通过特征标的不同来判断重载函数对应的版本</li><li>类型引用和类型本身视为同一个特征标，因为对于<code>max(n)</code>而言，无法判断对应的函数原型是<code>int max(int n)</code>还是<code>int max(int&amp; n)</code></li><li>函数重载的返回类型可以不同，但是特征标也必须不同，因为编译器是通过特征标唯一确定函数版本的</li><li>没有必要滥用函数重载，仅当函数基本上执行相同的任务，但使用不同形式的数据时才应采用函数重载</li></ol><h2 id="8-5-函数模板"><a href="#8-5-函数模板" class="headerlink" title="8.5 函数模板"></a>8.5 函数模板</h2><ol><li>函数模板是通用的函数描述，使用泛型来定义函数，其中泛型还可以用具体的类型例如int替换，c++的函数模板功能可以自动完成生成模板函数的过程</li><li>例如定义一个交换模板：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span>&#123;<br>    T temp;<br>    temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>上述交换模板中，template和typename是关键字必须要，typename可以换成class但是不建议换</li><li>有了上述的函数模板后，在程序中就可以直接使用<code>swap(int数据, int数据)</code>和<code>swap(double数据, double数据)</code>，而不需要因为参数类型不同而定义多个函数</li><li>函数模板只是使用起来方便，但其实并不会缩短最终的可执行程序，更常见的情形时将模板放在头文件中，并在需要使用模板的文件中包含头文件</li><li>与常规函数一样，模板函数也是可以重载的，例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T* a, T* b, <span class="hljs-type">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure>编译器将会根据函数调用时参数的类型进行自动匹配</li><li>模板函数也是有局限性的，例如模板里有<code>(a &lt; b)</code>的判断条件，如果函数调用时输入参数是int类型，则可以正常使用；如果输入类型是结构体，则无法正常使用，处理这种情况有两种办法：重载这个<code>&lt;</code>，让它能处理输入类型是结构体；或者为特定类型提供具体化的模板定义。</li><li>显示具体化：提供一个具体化函数定义，其中包含所需的代码，当编译器找到和函数调用匹配的具体化定义时，将使用该定义<ul><li>显示具体化的原型和定义以<code>template &lt;&gt;</code>打头</li><li>优先级：常规函数 &gt; 显示具体化函数 &gt; 普通模板函数</li><li>定义形式例如：<code>template &lt;&gt; void Swap&lt;job&gt;(job&amp;, job&amp;)</code>，其中的Swap<job>中的<job>是可选的，也可以不写</li></ul></li><li>实例化和具体化：<ul><li>代码中包含函数模版并不会生成函数定义，只是提供了一个方案，当编译器利用这个模板生成函数定义时，得到的就是模版的实力，叫做实例化，例如执行<code>Swap(a, b)</code>，编译器会自动找到模板并生成一个实例，这个实例才能叫做函数定义；这种通过调用函数时提供具体类型参数的实例化被称为隐式实例化。</li><li>还有一种显示实例化，可以直接命令编译器创建特定的实例，语法是：声明所需的种类-用&lt;&gt;表示类型，并在前面加上关键字template，例如<code>template void Swap&lt;int&gt;(int, int)</code>，编译器在看到这句声明后，将会使用Swap模板生成一个使用类型为int的实例，即“使用Swap模板生成int类型的函数定义”</li><li>要将显示实例化和显示具体化作区分，显示具体化的代码类似为<code>template &lt;&gt; void Swap&lt;int&gt;(int&amp;, int&amp;)</code>，意思是“不要使用Swap模板来生成定义，要专门使用为int类型显示定义的函数定义”</li><li>显示实例化，隐式实例化，显示具体化都统称为具体化</li></ul></li><li>一个函数调用对应多个函数版本时，编译器该如何选择？从最佳到最差的顺序如下：<ul><li>完全匹配，但常规函数由于模板</li><li>提升转换</li><li>标准转换</li><li>用户定义的转换</li></ul></li><li>完全匹配允许的无关紧要的转换：<table><thead><tr><th><strong>转换类型</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>引用绑定</td><td>将实参绑定到引用类型（包括左值引用和右值引用）。</td><td><code>int</code> → <code>int&amp;</code> 或 <code>int&amp;&amp;</code></td></tr><tr><td>数组到指针的转换</td><td>将数组类型转换为指向数组首元素的指针。</td><td><code>int[]</code> → <code>int*</code></td></tr><tr><td>函数到函数指针的转换</td><td>将函数类型转换为函数指针类型。</td><td><code>void f()</code> → <code>void (*pf)()</code></td></tr><tr><td>添加 <code>const</code> 或 <code>volatile</code> 限定符</td><td>在参数类型中添加 <code>const</code> 或 <code>volatile</code> 限定符。</td><td><code>int</code> → <code>const int</code> 或 <code>volatile int</code></td></tr><tr><td>指针类型转换</td><td>在指针类型中添加 <code>const</code> 或 <code>volatile</code> 限定符。</td><td><code>int*</code> → <code>const int*</code> 或 <code>volatile int*</code></td></tr><tr><td>标准转换序列中的“平凡转换”</td><td>包括类型提升（如 <code>char</code> → <code>int</code>）、浮点数提升（如 <code>float</code> → <code>double</code>）等。</td><td><code>char</code> → <code>int</code> 或 <code>float</code> → <code>double</code></td></tr><tr><td>用户定义的隐式类型转换</td><td>如果用户定义了隐式类型转换操作符或构造函数，这些转换也可能被视为完全匹配的一部分。</td><td><code>class A</code> → <code>class B</code>（如果定义了隐式转换）</td></tr></tbody></table></li><li>在c++98中，会出现无法判断函数模板内某个参数是什么类型的问题，因此c++11增加了关键字decltype，用于获取表达式的类型。它允许程序员在编译时推导出变量或表达式的类型，并可以将该类型用作其他声明的一部分。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 完结</title>
    <link href="/2025/01/15/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E5%AE%8C%E7%BB%93/"/>
    <url>/2025/01/15/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E5%AE%8C%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>终于算是完成了对《从零搭建操作系统》这本书的阅读和实现</p><p>操作系统深奥吗？就如书的作者在封面的总结“操作系统并不深奥”，读完整本书之后我会感觉确实，并不深奥，但是很难，难在框架太大，涉及到的细节太多，例如页表管理，内存管理，进程调度，我至少重复看了三遍，但还是会忘掉一些细节，从零搭完这些功能会发现，其实并没有想象中的那么深奥，不会让你读不懂。</p><p>但是操作系统最让人感叹的地方在于，涉及的很精妙，缓缓紧扣，例如最明显的内存管理，看起来很复杂，其实就是设计一堆内存池，通过一些内存位图，分配了就置1没分配就置0，如何分配也就是看在位图中找找找找到合适的位然后把对应内存的地址返回去，这么说起来好像很低端，但其实真实情况是：内存也分为虚拟内存和物理内存，分为用户内存和内核内存，不同的内存之间在分配的过程中不能冲突，并且要尽量合理分配，还要考虑内存的特权级，实现arena，不同用户进程都有的互相独立的虚拟内存空间，因为有虚拟内存和物理内存的区别，所以页表知识掌握不够牢靠的根本没法学，因此实际实现起来复杂度还是很大的。</p><p>恐怖的是我们实现的只是个小型的操作系统，真正的庞然大物Linux不知道到底有多少细节</p><p>感觉学完之后，整个人对操作系统，计算机原理等理解上升了好几个台阶，虽然学艺不精，但是让我从计算机上电的那一瞬间开始到保护模式、页表、内存管理、线程、各种什么键盘啊硬盘啊显存啊外设操作、中断、特权级、shell，也能讲出个一二</p><p>想起当初为什么会开始接触Linux内核，还是在和师兄出差的那趟高铁上听他们推荐入了斯坦福大学的经典课程Mit6.S081这门课程，由于是第一次接触，并且是全英，所以起步非常艰难，环境都搭了老半天，好不容易上手之后，做这门课的Lab做到一半心态爆炸，便暂时搁置了</p><p>后面开始在B站上发现一个up分享的搭建小型操作系统的视频，开始有兴趣从底层学起，学了一段时间发现这个up也是跟随一本书学习的，也就是《从零搭建操作系统》这本书，书的内容会比这个up介绍的细很多，因此才正式跟随这本书进行学习。</p><p>一开始越学越起劲，结果劲头过了之后开始有点囫囵吞枣，慢慢地坏处就体现出来了，到内存管理之后，进程线程时就因为基础不牢导致地动山摇，所以沉下心了先暂停学习，再次对已走过的路重新复习总结，打好基础，最后看到实现的shell界面时还是很开心的。</p><p>这个帖子就保存着吧，之后我还会再次复习这本书的，常看常新，并且里面有些知识点是被我跳过的，也需要补回来。</p><p>暂时完结，小洒一下花，准备回家过年去，重心要偏向c++和力扣，八股上</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第十五章 系统交互</title>
    <link href="/2025/01/14/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/"/>
    <url>/2025/01/14/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这章就是最后一章啦！会有很多平常学linux接触到的东西，例如fork，read，putchar，clear，shell之类的，但是大部分人使用这些函数都是进行应用层开发，我们这里会对它进行底层的实现，深层了解这几个常用的系统调用内部的原理</p><h2 id="15-1-fork-的原理与实现"><a href="#15-1-fork-的原理与实现" class="headerlink" title="15.1 fork 的原理与实现"></a>15.1 fork 的原理与实现</h2><p>我们先来看以下经典代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-type">pid_t</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">pid_t</span> pid = fork();<br><span class="hljs-keyword">if</span>(pid != <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;im father process pid = %d\n!&quot;</span>,pid);<br><span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;im child process pid = %d\n!&quot;</span>,pid);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行完这段代码后，系统打印两个printf的内容，理论上这两个printf在if else语句里，是只能执行其中一个的。这其中就是fork函数在起作用</p><p>fork：当进程A调用了fork函数后，相当于是创建了另一个进程B，并且这个进程B和进程A是“一模一样”的，这里的“一模一样”是指，进程A和B的资源是一样的，但并不是共享资源，因为进程与进程之间是隔离的，只是进程A拷贝了一份资源给进程B，包括代码和数据。因此，上述代码看起来像是一个进程里的代码，但其实在fork之后，会创建一个新的进程B，A作为B的父进程，B作为A的子进程。</p><p>fork的返回值是进程的pid，如果是进程是父进程，则返回父进程的pid，如果进程是子进程，则返回0（不是说子进程没有pid，而是不返回pid只返回0，这样做的目的是能够通过返回值来区分当前进程是子进程和父进程。</p><p>可以这么简单的理解，fork这种返回值的设定是为了便于设计程序。进程A通过返回值pid，在进程A的代码段里就会只执行<code>if(pid != 0)</code>下的语句，进程B通过返回值pid发现是0，在进程B的代码段里就会只执行<code>else</code>下的语句。</p><h3 id="15-1-1-fork实现前的补充工作"><a href="#15-1-1-fork实现前的补充工作" class="headerlink" title="15.1.1 fork实现前的补充工作"></a>15.1.1 fork实现前的补充工作</h3><p>我们需要在thread.c文件中，在PCB结构体里添加父进程的id这一元素，并在初始化中将该值初始化为-1，默认进程没有父进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*PCB结构体，存储进程或线程的基本信息*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>    <span class="hljs-type">uint32_t</span> cwd_inode_nr;      <span class="hljs-comment">//工作目录inode编号</span><br>    <span class="hljs-type">int16_t</span> parent_pid;                 <span class="hljs-comment">//父进程的pid，如果没有父进程则为-1</span><br>    <span class="hljs-type">uint32_t</span> stack_magic;      <span class="hljs-comment">//越界检查  因为我们pcb上面的就是我们要用的栈了 到时候还要越界检查</span><br>&#125;;<br><br><span class="hljs-comment">/*初始化线程的基本信息*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* pthread, <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> prio)</span>&#123;<br>    ...<br>    pthread-&gt;cwd_inode_nr = <span class="hljs-number">0</span>;<span class="hljs-comment">//默认工作路径在根目录</span><br>    pthread -&gt; parent_pid = <span class="hljs-number">-1</span>;             <span class="hljs-comment">//默认没有父进程</span><br>    pthread -&gt; stack_magic = <span class="hljs-number">0x19870916</span>;    <span class="hljs-comment">//魔数，可以随意设置</span><br>    pthread -&gt; self_kstack = (<span class="hljs-type">uint32_t</span>*)((<span class="hljs-type">uint32_t</span>)pthread + PG_SIZE);  <span class="hljs-comment">//设置线程在内核态下栈顶的位置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在memory.c中增加函数用以在内存池中分配一页内存并完成虚拟地址的映射，该函数不同的地方在于：函数中不需要从虚拟地址内存池中设置位图。<br>注意：这个函数是专门用来fork时复制进程A用户空间的资源给进程B的时候的，对于进程B而言，需要分配新的空间存储进程A的资源，但对于进程A而言，分配的空间已经是在进程A的虚拟地址位图里做好了映射了，因此进程B只需要将虚拟地址位图最后也复制过去就好。因此这个函数相当于是进程B专门用来做按照进程A的资源进行内存映射的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//得到1页大小内存并复制到页表中 专门针对fork时虚拟地址位图无需操作</span><br><span class="hljs-comment">//因为位图我们后面会复制父进程的 所以当然不用继续对虚拟位图操作了</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">get_a_page_without_opvaddrbitmap</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> pool_flags pf,<span class="hljs-type">uint32_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span>* <span class="hljs-title">mem_pool</span> =</span> (pf == PF_KERNEL) ? &amp;kernel_pool : &amp;user_pool;<br>    lock_acquire(&amp;mem_pool-&gt;lock);<br>    <span class="hljs-type">void</span>* page_phyaddr = palloc(mem_pool);<br>    <span class="hljs-comment">//分配失败</span><br>    <span class="hljs-keyword">if</span>(page_phyaddr == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        lock_release(&amp;mem_pool-&gt;lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    page_table_add((<span class="hljs-type">void</span>*)vaddr,page_phyaddr);<br>    lock_release(&amp;mem_pool-&gt;lock);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)vaddr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-1-2-fork的实现"><a href="#15-1-2-fork的实现" class="headerlink" title="15.1.2 fork的实现"></a>15.1.2 fork的实现</h3><p>fork.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">intr_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">thread_ready_list</span>;</span>      <span class="hljs-comment">//就绪队列</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">thread_all_list</span>;</span>        <span class="hljs-comment">//所有任务队列</span><br><br><span class="hljs-comment">//复制父进程的pcb给子进程，直接先把pcb所在页 包括内核栈 中断栈全部一起复制过来 其他的需要修改的再一项项改</span><br><span class="hljs-type">int32_t</span> <span class="hljs-title function_">copy_pcb_vaddrbitmap_stack0</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* child_thread,<span class="hljs-keyword">struct</span> task_struct* parent_thread)</span><br>&#123;<br>    <span class="hljs-comment">//直接先把pcb所在页 包括内核栈 中断栈全部一起复制过来 其他的需要修改的再一项项改</span><br>    <span class="hljs-built_in">memcpy</span>(child_thread,parent_thread,PG_SIZE);<br>    child_thread-&gt;pid = fork_pid();<br>    child_thread-&gt;elapsed_ticks = <span class="hljs-number">0</span>;<br>    child_thread-&gt;status = TASK_READY; <span class="hljs-comment">//之后要放到就绪队列 被调度的</span><br>    child_thread-&gt;ticks = child_thread-&gt;priority; <span class="hljs-comment">//时间片填满</span><br>    child_thread-&gt;parent_pid = parent_thread-&gt;pid; <span class="hljs-comment">//默认是-1 对于子进程的parent_pid 父进程的pid</span><br>    child_thread-&gt;general_tag.prev = child_thread-&gt;general_tag.next = <span class="hljs-literal">NULL</span>; <br>    child_thread-&gt;all_list_tag.prev = child_thread-&gt;all_list_tag.next = <span class="hljs-literal">NULL</span>;<br>    block_desc_init(child_thread-&gt;u_block_desc);<span class="hljs-comment">//malloc 内存块分配符初始化</span><br>    <span class="hljs-comment">//虚拟位图需要分配页 的页数 毕竟两个进程不能共享虚拟内存位图嘛 但是我们是需要把父进程的给复制了 </span><br>    <span class="hljs-type">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="hljs-number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="hljs-number">8</span> , PG_SIZE);  <br>    <span class="hljs-type">void</span>* vaddr_btmp = get_kernel_pages(bitmap_pg_cnt);<br>    <span class="hljs-comment">//复制父进程的虚拟内存位图 并把自己刚分配好的独立位图给我们的子进程赋值</span><br>    <span class="hljs-built_in">memcpy</span>(vaddr_btmp,child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits,bitmap_pg_cnt * PG_SIZE);<br>    child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits = vaddr_btmp;<br>    ASSERT(<span class="hljs-built_in">strlen</span>(child_thread-&gt;name) &lt; <span class="hljs-number">11</span>); <span class="hljs-comment">//进程后面加个名字</span><br>    <span class="hljs-built_in">strcat</span>(child_thread-&gt;name,<span class="hljs-string">&quot;_fork&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//将父进程在内存区的数据全部复制给子进程</span><br><span class="hljs-comment">//buf_page是因为用户进程间无法共享内存 看不见彼此 只能通过buf_page来作为过渡</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">copy_body_stack3</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* parent_thread,<span class="hljs-keyword">struct</span> task_struct* child_thread,<span class="hljs-type">void</span>* buf_page)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span>* vaddr_btmp = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.bits;<br>    <span class="hljs-type">uint32_t</span> btmp_bytes_len = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len;<br>    <span class="hljs-type">uint32_t</span> vaddr_start = parent_thread-&gt;userprog_vaddr.vaddr_start;<br>    <span class="hljs-type">uint32_t</span> idx_byte = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> idx_bit = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> prog_vaddr = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//根据虚拟内存位图来看 我们只需要把位图中看看哪些页被用了</span><br>    <span class="hljs-comment">//我们把那些页给复制过去即可 同时也需要把页表在新进程中安装一下</span><br>    <span class="hljs-keyword">while</span>(idx_byte &lt; btmp_bytes_len)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(vaddr_btmp[idx_byte])<br>        &#123;<br>            idx_bit = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(idx_bit &lt; <span class="hljs-number">8</span>) <span class="hljs-comment">//一字节8位</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>((BITMAP_MASK &lt;&lt; idx_bit) &amp; vaddr_btmp[idx_byte])<br>                &#123;<br>                    prog_vaddr = (idx_byte * <span class="hljs-number">8</span> + idx_bit) * PG_SIZE + vaddr_start;<br>                    <span class="hljs-built_in">memcpy</span>(buf_page,(<span class="hljs-type">void</span>*)prog_vaddr,PG_SIZE);<br>                    page_dir_activate(child_thread); <span class="hljs-comment">//切换到用户页表 防止安装到父进程里面去了</span><br>                    get_a_page_without_opvaddrbitmap(PF_USER,prog_vaddr);<br>                    <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)prog_vaddr,buf_page,PG_SIZE);<br>                    page_dir_activate(parent_thread); <span class="hljs-comment">//切换回父进程</span><br>                &#125;<br>                ++idx_bit;<br>            &#125;<br>        &#125;<br>        ++idx_byte;<br>    &#125;    <br>&#125;<br><br><span class="hljs-comment">//给子进程构建内核栈和修改返回值</span><br><span class="hljs-type">int32_t</span> <span class="hljs-title function_">build_child_stack</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* child_thread)</span><br>&#123;<br>    <span class="hljs-comment">//内核栈的最高地址处 intr中断栈最低地址处</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_stack</span>* <span class="hljs-title">intr_0_stack</span> =</span> \<br>      (<span class="hljs-keyword">struct</span> intr_stack*)((<span class="hljs-type">uint32_t</span>)child_thread + PG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> intr_stack));<br>    <span class="hljs-comment">//返回值 0</span><br>    intr_0_stack-&gt;eax = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//这里我把其结构体搬过来了</span><br>    <span class="hljs-comment">/*struct thread_stack</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        uint32_t ebp;</span><br><span class="hljs-comment">        uint32_t ebx;</span><br><span class="hljs-comment">        uint32_t edi;</span><br><span class="hljs-comment">        uint32_t esi;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        void (*eip) (thread_func* func,void* func_arg); //和下面的相互照应 以ret 汇编代码进入kernel_thread函数调用</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">        void (*unused_retaddr);                         //占位数 在栈顶站住了返回地址的位置 因为是汇编ret </span><br><span class="hljs-comment">        thread_func* function;                          //进入kernel_thread要调用的函数地址</span><br><span class="hljs-comment">        void* func_arg;      //参数指针</span><br><span class="hljs-comment">    &#125;;*/</span><br>    <span class="hljs-comment">//返回地址毕竟是高地址</span><br>    <span class="hljs-type">uint32_t</span>* ret_addr_in_thread_stack = (<span class="hljs-type">uint32_t</span>*)intr_0_stack - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint32_t</span>* esi_ptr_in_thread_stack =  (<span class="hljs-type">uint32_t</span>*)intr_0_stack - <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint32_t</span>* edi_ptr_in_thread_stack =  (<span class="hljs-type">uint32_t</span>*)intr_0_stack - <span class="hljs-number">3</span>;<br>    <span class="hljs-type">uint32_t</span>* ebx_ptr_in_thread_stack =  (<span class="hljs-type">uint32_t</span>*)intr_0_stack - <span class="hljs-number">4</span>;<br>    <span class="hljs-type">uint32_t</span>* ebp_ptr_in_thread_stack =  (<span class="hljs-type">uint32_t</span>*)intr_0_stack - <span class="hljs-number">5</span>;<br>    <br>    *ret_addr_in_thread_stack = (<span class="hljs-type">uint32_t</span>)intr_exit;<br>    <span class="hljs-comment">//反正之后的pop都会覆盖</span><br>    *esi_ptr_in_thread_stack = *edi_ptr_in_thread_stack = *ebx_ptr_in_thread_stack = \<br>    *ebp_ptr_in_thread_stack = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//内核栈栈顶</span><br>    child_thread-&gt;self_kstack = ebp_ptr_in_thread_stack;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//更新inode打开数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">updata_inode_open_cnts</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* thread)</span><br>&#123;<br>    <span class="hljs-type">int32_t</span> local_fd = <span class="hljs-number">3</span>,global_fd = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(local_fd &lt; MAX_FILES_OPEN_PER_PROC)<br>    &#123;<br>        global_fd = thread-&gt;fd_table[local_fd];<br>        ASSERT(global_fd &lt; MAX_FILE_OPEN);<br>        <span class="hljs-keyword">if</span>(global_fd != <span class="hljs-number">-1</span>)<br>            ++file_table[global_fd].fd_inode-&gt;i_open_cnts;<br>        ++local_fd;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//汇总函数 包装 把父进程资源给子进程</span><br><span class="hljs-type">int32_t</span> <span class="hljs-title function_">copy_process</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* child_thread,<span class="hljs-keyword">struct</span> task_struct* parent_thread)</span><br>&#123;<br>    <span class="hljs-comment">//用于给memcpy 过渡的页面</span><br>    <span class="hljs-type">void</span>* buf_page = get_kernel_pages(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(buf_page == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        printk(<span class="hljs-string">&quot;copy_process: buf_page alloc fail\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(copy_pcb_vaddrbitmap_stack0(child_thread,parent_thread) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        printk(<span class="hljs-string">&quot;copy_process: copy_pcb_vaddrbitmap_stack0 fail\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    child_thread-&gt;pgdir = create_page_dir();<br>    printk(<span class="hljs-string">&quot;child_thread-&gt;pgdir %x\nparent_thread-&gt;pgdir %x\n&quot;</span>,child_thread-&gt;pgdir,parent_thread-&gt;pgdir);<br>    <span class="hljs-keyword">if</span>(child_thread-&gt;pgdir == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        printk(<span class="hljs-string">&quot;copy_process: child_thread-&gt;pgdir create fail\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    copy_body_stack3(parent_thread,child_thread,buf_page);<br>    build_child_stack(child_thread);<br>    updata_inode_open_cnts(child_thread);<br>    mfree_page(PF_KERNEL,buf_page,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//禁止从内核调用 只能从用户进程调用</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">sys_fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">parent_thread</span> =</span> running_thread();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">child_thread</span>  =</span> get_kernel_pages(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(child_thread == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    ASSERT(INTR_OFF == intr_get_status() &amp;&amp; parent_thread-&gt;pgdir != <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">if</span>(copy_process(child_thread,parent_thread) == <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    ASSERT(!elem_find(&amp;thread_ready_list,&amp;child_thread-&gt;general_tag));<br>    list_append(&amp;thread_ready_list,&amp;child_thread-&gt;general_tag);<br>    ASSERT(!elem_find(&amp;thread_all_list,&amp;child_thread-&gt;all_list_tag));<br>    list_append(&amp;thread_all_list,&amp;child_thread-&gt;all_list_tag);<br>    <br>    <span class="hljs-keyword">return</span> child_thread-&gt;pid;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>fork其实主要完成两个工作：</p><ol><li>完成资源的复制</li><li>在处理器执行子进程的时候，让处理器指向子进程中fork的下一步代码位置</li></ol><p>用户进程一般是通过系统调用从而执行fork的，系统调用本身属于中断，通过中断的上下文保护，让用户进入内核态实现系统调用并返回。</p><p>对于父进程，执行完系统调用fork后就会继续执行之后的代码，是因为中断退出函数<code>intr_exit</code>在起作用恢复上下文。对于子进程，本身是被fork创建出来的，因此不存在父进程那般进入中断的状态，也就无法通过中断退出函数<code>intr_exit</code>恢复上下文。</p><p>子进程被创建后，进程的状态会被设置成READY态，并将进程加入到进程准备队列中，等待调度器调度，当调度器调度到子进程时，是通过schedule中的switch_to恢复子进程的上下文的，因此我们要在子进程的内核栈里，将内核栈中eip指针指向中断退出函数<code>intr_exit</code>，这样switch_to通过<code>ret</code>将处理器的eip指针指向指向中断退出函数<code>intr_exit</code>，并进而通过中断退出函数恢复上下文。</p><p>有的人可能好奇，为什么子进程可以直接通过中断退出函数恢复上下文，没进行过保存上下文又如何有恢复一说呢？其实保存已经进行过了，但是是父进程进行的，父进程先通过进入中断保存了上下文在用户进程栈里，在中断处理函数例程中才完成了对子进程的复制，子进程拥有父进程的所有资源，因此子进程的进程栈里其实也有一份父进程保存上下文时的拷贝，因此可以通过<code>intr_exit</code>恢复上下文。</p><h3 id="15-1-3-添加fork系统调用与直线init进程"><a href="#15-1-3-添加fork系统调用与直线init进程" class="headerlink" title="15.1.3 添加fork系统调用与直线init进程"></a>15.1.3 添加fork系统调用与直线init进程</h3><p>在Linux中，init是用户级进程，是第一个启动的程序，因此它的pid是1，Linux利用这个进程完成很多初始化的工作<br>在main.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br>   intr_enable();<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> ret_pid = fork();<br>    <span class="hljs-keyword">if</span>(ret_pid)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am father,my pid is %d, ret pid is %d\n&quot;</span>,getpid(),ret_pid);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child, my pid is %d, ret pid is %d\n&quot;</span>,getpid(),ret_pid);   <br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在thread.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*初始化线程环境*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    ...<br>    process_execute(init,<span class="hljs-string">&quot;init&quot;</span>);<br>    make_main_thread();<br>    idle_thread = thread_start(<span class="hljs-string">&quot;idle&quot;</span>,<span class="hljs-number">10</span>,idle,<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//创建休眠进程</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/15.1.png" title="fork运行过程"></p><h2 id="15-2-实现一个简单的shell"><a href="#15-2-实现一个简单的shell" class="headerlink" title="15.2 实现一个简单的shell"></a>15.2 实现一个简单的shell</h2><p>我们实现一个简单的shell，能处理键入的命令</p><h3 id="15-2-1-shell雏形"><a href="#15-2-1-shell雏形" class="headerlink" title="15.2.1 shell雏形"></a>15.2.1 shell雏形</h3><p>shell.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shell.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;file.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cmd_len    128 <span class="hljs-comment">//最大支持128个字符</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ARG_NR 16  <span class="hljs-comment">//命令名外支持15个参数</span></span><br><br><span class="hljs-type">char</span> cmd_line[cmd_len] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> cwd_cache[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//目录的缓存 执行cd则移动到其他目录去</span><br><span class="hljs-type">char</span>* argv[MAX_ARG_NR];   <span class="hljs-comment">//参数</span><br><br><span class="hljs-comment">//固定输出提示</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_prompt</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[tomato@localhost %s]$ &quot;</span>,cwd_cache);<br>&#125;<br><br><span class="hljs-comment">//从键盘缓冲区中最多读入count字节到buf</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">readline</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf,<span class="hljs-type">int32_t</span> count)</span><br>&#123;<br>    ASSERT(buf != <span class="hljs-literal">NULL</span> &amp;&amp; count &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-type">char</span>* pos = buf;<br>    <span class="hljs-comment">//默认没有到回车就不停止 、一个一个字节读</span><br>    <span class="hljs-keyword">while</span>(read(stdin_no,pos,<span class="hljs-number">1</span>) != <span class="hljs-number">-1</span> &amp;&amp; (pos - buf) &lt; count)<br>    &#123;<br>        <span class="hljs-keyword">switch</span>(*pos)<br>        &#123;<br>            <span class="hljs-comment">//清屏</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>-<span class="hljs-string">&#x27;a&#x27;</span>:<br>                *pos = <span class="hljs-number">0</span>;<br>                clear();<br>                print_prompt();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);  <span class="hljs-comment">//把刚刚键入的字符打印出来</span><br>                <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-comment">//清除输入</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>-<span class="hljs-string">&#x27;a&#x27;</span>:<br>                <span class="hljs-keyword">while</span>(buf != pos)<br>                &#123;<br>                    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\b&#x27;</span>);<br>                    *(pos--) = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-comment">//和下面的回车一起</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\r&#x27;</span>:<br>                *pos = <span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            <br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\b&#x27;</span>:<br>                <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;\b&#x27;</span>) <span class="hljs-comment">//阻止删除不是本次输出的信息</span><br>                &#123;<br>                    --pos;<br>                    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\b&#x27;</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">putchar</span>(*pos);<br>                ++pos;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;readline: cant fine entry_key in the cmd_line,max num of char is 128\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//解析键入的字符 token为分割符号</span><br><span class="hljs-type">int32_t</span> <span class="hljs-title function_">cmd_parse</span><span class="hljs-params">(<span class="hljs-type">char</span>* cmd_str,<span class="hljs-type">char</span>** argv,<span class="hljs-type">char</span> token)</span><br>&#123;<br>    ASSERT(cmd_str != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">int32_t</span> arg_idx = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//初始化指针数组</span><br>    <span class="hljs-keyword">while</span>(arg_idx &lt; MAX_ARG_NR)<br>    &#123;<br>        argv[arg_idx] = <span class="hljs-literal">NULL</span>;<br>        arg_idx++;<br>    &#125;<br>    <span class="hljs-type">char</span>* next = cmd_str;<br>    <span class="hljs-type">int32_t</span> argc = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*next)<br>    &#123;<br>        <span class="hljs-comment">//跳过分隔符</span><br>        <span class="hljs-keyword">while</span>(*next == token)++next;<br>        <span class="hljs-keyword">if</span>(*next == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果到达字符串末尾，则退出循环</span><br><br>        <span class="hljs-comment">//保存当前参数的起始位置</span><br>        argv[argc] = next;     <span class="hljs-comment">//无论怎么样 到这里都是有字符的地方 且argc表示目前存在第几个参数字符串</span><br>        <br>        <span class="hljs-comment">//跳过当前参数</span><br>        <span class="hljs-keyword">while</span>(*next &amp;&amp; *next != token)  <span class="hljs-comment">//要不结束了为0 或者到了分割符号</span><br>            ++next;<br>        <br>        <span class="hljs-comment">// 相当于是，将输入的字符串里的空格全部替换成了结束符</span><br>        <span class="hljs-keyword">if</span>(*next)<br>            *(next++) = <span class="hljs-number">0</span>; <span class="hljs-comment">//到最后就是设置字符串的末尾0 分割符号位置刚好处理为0 这样字符串有结束末尾了</span><br>                        <span class="hljs-comment">//最后一个参数后面自然有&#x27;\0&#x27;</span><br>        <span class="hljs-keyword">if</span>(argc &gt; MAX_ARG_NR)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <br>        ++argc;        <br>    &#125;<br>    <span class="hljs-keyword">return</span> argc;        <span class="hljs-comment">//多少个参数</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">my_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    cwd_cache[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-type">int</span> argc = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        print_prompt();<br>        <span class="hljs-built_in">memset</span>(cmd_line,<span class="hljs-number">0</span>,cmd_len);<br>        readline(cmd_line,cmd_len);<br>        <span class="hljs-keyword">if</span>(cmd_line[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>            <br>        argc = <span class="hljs-number">-1</span>;  <br>        argc = cmd_parse(cmd_line,argv,<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num of arguments exceed %d\n&quot;</span>,MAX_ARG_NR);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int32_t</span> arg_idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(arg_idx &lt; argc)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>,argv[arg_idx]);<br>            arg_idx++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    PANIC(<span class="hljs-string">&quot;my_shell: should not be here&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   cls_screen();<br>   console_put_str(<span class="hljs-string">&quot;[tomato@localhost /]$ &quot;</span>);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> ret_pid = fork();<br>    <span class="hljs-keyword">if</span>(ret_pid)<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span><br>        my_shell();<br>    PANIC(<span class="hljs-string">&quot;init: should not be here&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>init进程是系统创建的第一个程序，是所有进程的父进程，因此在init进程中利用fork创建一个子进程，子进程执行<code>my_shell()</code>函数</p><p><code>my_shell()</code>函数的主要作用是：将用户键入的命令按照空格作为分隔符，写入数组<code>argv[arg_idx]</code>作为参数；具体实现算法实际上就是将用户输入的命令作为一整个字符串处理，将命令中的空格换成字符串结束符<code>\0</code>，并把每个参数的起始地址存放至数组<code>argv[arg_idx]</code>。</p><p><img src="/../img/15.2.png" title="shell雏形"></p><h3 id="15-2-2-实现shell的一些功能"><a href="#15-2-2-实现shell的一些功能" class="headerlink" title="15.2.2 实现shell的一些功能"></a>15.2.2 实现shell的一些功能</h3><p>命令分为两大类：外部命令 和 内部命令</p><p>外部命令是指该命令存储在文件系统上的外部程序，执行该命令时，实际是从文件系统上加载该程序到内存后运行的，也就是说外部命令会以进程的方式执行，Linux常用的ls，mkdir，clear等都是外部命令</p><p>内部命令也称为内建命令，是系统本身提供的功能，只是一些单独的功能函数，比如cd命令</p><p>为了方便，我们就将ls等命令直接写成内部命令了，内部命令放入新的文件buildin_cmd.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;buildin_cmd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;file.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio-kernel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dir.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shell.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> final_path[<span class="hljs-number">160</span>];<br><br><span class="hljs-comment">//在用户态就把路径给解析出来</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wash_path</span><span class="hljs-params">(<span class="hljs-type">char</span>* old_abs_path,<span class="hljs-type">char</span>* new_abs_path)</span><br>&#123;<br>    ASSERT(old_abs_path[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;/&#x27;</span>);<br>    <span class="hljs-type">char</span> name[MAX_FILE_NAME_LEN] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span>* sub_path = old_abs_path;<br>    sub_path = path_parse(sub_path,name);<br>    <br>    <span class="hljs-comment">//如果直接就是根目录 直接返回即可</span><br>    <span class="hljs-keyword">if</span>(name[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>    &#123;<br>        new_abs_path[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        new_abs_path[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    new_abs_path[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br>    <span class="hljs-built_in">strcat</span>(new_abs_path,<span class="hljs-string">&quot;/&quot;</span>);<br>    <span class="hljs-keyword">while</span>(name[<span class="hljs-number">0</span>])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;..&quot;</span>,name))   <span class="hljs-comment">//返回上级</span><br>        &#123;<br>            <span class="hljs-type">char</span>* slash_ptr = <span class="hljs-built_in">strrchr</span>(new_abs_path,<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">//等于移动到最偏右的/位置去</span><br>            <span class="hljs-keyword">if</span>(slash_ptr != new_abs_path)   <span class="hljs-comment">//如果为 /aaa 那么移动之后就到/的位置了 如果是/aaa/bbb 那么就会回到/aaa/</span><br>                *slash_ptr = <span class="hljs-number">0</span>; <span class="hljs-comment">// 把/变成0</span><br>            <span class="hljs-keyword">else</span><br>        *(slash_ptr+<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果是 / 或者 /aaa 那么都回到/ 则把最右边+1置零位即可</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;.&quot;</span>,name))  <span class="hljs-comment">//如果不是到. 增加到后米纳即可 .等于没有作用 继续遍历即可</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(new_abs_path,<span class="hljs-string">&quot;/&quot;</span>))  <span class="hljs-comment">//不是 / 防止出现// 的情况</span><br>                <span class="hljs-built_in">strcat</span>(new_abs_path,<span class="hljs-string">&quot;/&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(new_abs_path,name);<br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(name,<span class="hljs-number">0</span>,MAX_FILE_NAME_LEN);<br>        <span class="hljs-keyword">if</span>(sub_path)<br>            sub_path = path_parse(sub_path,name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//把path处理 . ..去掉 储存在final_path getcwd得到当前工作目录 + 相对路径 即绝对路径</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">make_clear_abs_path</span><span class="hljs-params">(<span class="hljs-type">char</span>* path,<span class="hljs-type">char</span>* final_path)</span><br>&#123;<br>    <span class="hljs-type">char</span> abs_path[MAX_PATH_LEN] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(path[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span>)  <span class="hljs-comment">//如果不是绝对路径就弄成绝对路径</span><br>    &#123;<br>        <span class="hljs-built_in">memset</span>(abs_path,<span class="hljs-number">0</span>,MAX_PATH_LEN);<br>        <span class="hljs-keyword">if</span>(getcwd(abs_path,MAX_PATH_LEN) != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!((abs_path[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; abs_path[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>))<br>                <span class="hljs-built_in">strcat</span>(abs_path,<span class="hljs-string">&quot;/&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//把path 加到工作目录的头上</span><br>    <span class="hljs-built_in">strcat</span>(abs_path,path);<br>    wash_path(abs_path,final_path);<br>&#125;<br><br><span class="hljs-comment">// pwd命令中的内建函数 得到当前工作目录</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildin_pwd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-comment">//没有参数才可以</span><br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pwd: no argument support!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(getcwd(final_path,MAX_PATH_LEN) != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,final_path);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pwd: get current work directory failed\n&quot;</span>);<br>    &#125;   <br>&#125;<br><br><span class="hljs-comment">// 支持一个参数 改变当前工作目录</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">buildin_cd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc &gt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cd: only support 1 argument!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">1</span>)<br>    &#123;<br>        final_path[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        final_path[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>    make_clear_abs_path(argv[<span class="hljs-number">1</span>],final_path);<br>    <br>    <span class="hljs-keyword">if</span>(chdir(final_path) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cd: no such directory %s\n&quot;</span>,final_path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> final_path;   <br>&#125;<br><br><span class="hljs-comment">// ls内建函数 仅支持-l -h -h等于不支持 哈哈</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildin_ls</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-type">char</span>* pathname = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">file_stat</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;file_stat,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> stat));<br>    <span class="hljs-type">bool</span> long_info = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">uint32_t</span> arg_path_nr = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">uint32_t</span> arg_idx = <span class="hljs-number">1</span>;    <span class="hljs-comment">//第一个字符串是 ls 跳过</span><br>    <span class="hljs-keyword">while</span>(arg_idx &lt; argc)    <span class="hljs-comment">//仅仅支持 ls 或者 ls -l 或者 ls -l path的形式</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(argv[arg_idx][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;-l&quot;</span>,argv[arg_idx]))<br>                long_info = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;-h&quot;</span>,argv[arg_idx]))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: -l list all all information about the file.\nnot support -h now sry - -\n&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ls: invaild option %s\nTry &#x27;ls -l&#x27; u can get what u want\n&quot;</span>,argv[arg_idx]);<br>                <span class="hljs-keyword">return</span>; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(arg_path_nr == <span class="hljs-number">0</span>)<br>            &#123;<br>                pathname = argv[arg_idx];<br>                arg_path_nr = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ls: only support one path\n&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        ++arg_idx;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(pathname == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//ls 或者 ls -l</span><br>    &#123;<br>        <span class="hljs-comment">//得到工作目录</span><br>        <span class="hljs-keyword">if</span>(getcwd(final_path,MAX_PATH_LEN) != <span class="hljs-literal">NULL</span>)<br>    pathname = final_path;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ls: getcwd for default path failed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        make_clear_abs_path(pathname,final_path);<br>        pathname = final_path;<br>    &#125;<br>    <br>    <span class="hljs-comment">//目录下的文件</span><br>    <span class="hljs-keyword">if</span>(stat(pathname,&amp;file_stat) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ls: cannot access %s: No such file or directory\n&quot;</span>,pathname);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(file_stat.st_filetype == FT_DIRECTORY)  <span class="hljs-comment">//得到目录文件才继续</span><br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir</span>* <span class="hljs-title">dir</span> =</span> opendir(pathname); <span class="hljs-comment">//得到目录指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir_entry</span>* <span class="hljs-title">dir_e</span> =</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">char</span> sub_pathname[MAX_PATH_LEN] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">uint32_t</span> pathname_len   = <span class="hljs-built_in">strlen</span>(pathname);<br>        <span class="hljs-type">uint32_t</span> last_char_idx  = pathname_len - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">memcpy</span>(sub_pathname,pathname,pathname_len);<br>        <br>        <span class="hljs-comment">//方便后面得到当前目录下的文件stat信息 </span><br>        <span class="hljs-comment">//加个/ 之后每个文件加文件名stat即可</span><br>        <span class="hljs-keyword">if</span>(sub_pathname[last_char_idx] != <span class="hljs-string">&#x27;/&#x27;</span>) <br>        &#123;<br>            sub_pathname[pathname_len] = <span class="hljs-string">&#x27;/&#x27;</span>; <br>            ++pathname_len;<br>        &#125;<br>        <br>        rewinddir(dir);  <span class="hljs-comment">//目录指针指向0  方便readdir遍历目录项</span><br>        <span class="hljs-keyword">if</span>(long_info)    <span class="hljs-comment">// ls -l 这里是目录的ls</span><br>        &#123;<br>            <span class="hljs-type">char</span> ftype;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;total: %d\n&quot;</span>,file_stat.st_size);<br>            <span class="hljs-keyword">while</span>((dir_e = readdir(dir)))    <span class="hljs-comment">//通过readdir来遍历目录项 我还专门回去看了看这个函数</span><br>            &#123;<br>                ftype = <span class="hljs-string">&#x27;d&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(dir_e-&gt;f_type == FT_REGULAR)<br>                    ftype = <span class="hljs-string">&#x27;-&#x27;</span>;<br>                sub_pathname[pathname_len] = <span class="hljs-number">0</span>; <span class="hljs-comment">//把字符串末尾设0 方便strcat函数</span><br>                <span class="hljs-built_in">strcat</span>(sub_pathname,dir_e-&gt;filename);<br>                <span class="hljs-built_in">memset</span>(&amp;file_stat,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> stat));<br>                <span class="hljs-keyword">if</span>(stat(sub_pathname,&amp;file_stat) == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ls: cannot access %s:No such file or directory\n&quot;</span>,dir_e-&gt;filename);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c    %d    %d    %s\n&quot;</span>,ftype,dir_e-&gt;i_no,file_stat.st_size,dir_e-&gt;filename);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">//仅仅是ls 把文件名写出来即可</span><br>        &#123;<br>            <span class="hljs-keyword">while</span>((dir_e = readdir(dir)))<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s  &quot;</span>,dir_e-&gt;filename);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        closedir(dir);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(long_info)<br>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-    %d    %d    %s\n&quot;</span>,file_stat.st_ino,file_stat.st_size,pathname);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,pathname);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildin_ps</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>     <span class="hljs-comment">//不应该有参数</span><br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ps: no argument support!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ps();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">buildin_clear</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;clear: no argument support!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    clear();<br>&#125;<br><br><span class="hljs-type">int32_t</span> <span class="hljs-title function_">buildin_mkdir</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-comment">//必须要有一个 安装路径参数</span><br>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mkdir: only support 1 argument!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        make_clear_abs_path(argv[<span class="hljs-number">1</span>],final_path);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;/&quot;</span>,final_path))  <span class="hljs-comment">//不是根目录 根目录一直都在</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(mkdir(final_path) == <span class="hljs-number">0</span>)<br>                ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mkdir: create directory %s failed.\n&quot;</span>,argv[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">int32_t</span> <span class="hljs-title function_">buildin_rmdir</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rmdir: only support 1 argument!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        make_clear_abs_path(argv[<span class="hljs-number">1</span>],final_path);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;/&quot;</span>,final_path)) <span class="hljs-comment">// 不能删除根目录</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(rmdir(final_path) == <span class="hljs-number">0</span>)<br>                ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rmdir: remove %s failed\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">int32_t</span> <span class="hljs-title function_">buildin_rm</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> argc,<span class="hljs-type">char</span>** argv)</span><br>&#123;<br>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rm: only support 1 argument!\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        make_clear_abs_path(argv[<span class="hljs-number">1</span>],final_path);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;/&quot;</span>,final_path))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(unlink(final_path) == <span class="hljs-number">0</span>)<br>                ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rm: delete %s failed\n&quot;</span>,argv[<span class="hljs-number">1</span>]); <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>那么我们在shell中键入的命令如何真正被调用呢，对于内建命令来说，其实就是在shell的调用函数里面，对输入的参数中第一个参数进行switch，从而调用不同的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">my_shell</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    cwd_cache[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    cwd_cache[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> argc = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        print_prompt();<br>        <span class="hljs-built_in">memset</span>(cmd_line,<span class="hljs-number">0</span>,cmd_len);<br>        <span class="hljs-built_in">memset</span>(final_path,<span class="hljs-number">0</span>,MAX_PATH_LEN);<br>        <span class="hljs-built_in">memset</span>(argv,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*) * MAX_ARG_NR);<br>        readline(cmd_line,cmd_len);<br>        <span class="hljs-keyword">if</span>(cmd_line[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>            <br>        argc = <span class="hljs-number">-1</span>;  <br>        argc = cmd_parse(cmd_line,argv,<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num of arguments exceed %d\n&quot;</span>,MAX_ARG_NR);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;ls&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>            buildin_ls(argc,argv);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;pwd&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>            buildin_pwd(argc,argv);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;ps&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>            buildin_ps(argc,argv);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;cd&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(buildin_cd(argc,argv) != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-built_in">memset</span>(cwd_cache,<span class="hljs-number">0</span>,MAX_PATH_LEN);<br>                <span class="hljs-built_in">strcpy</span>(cwd_cache,final_path);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;clear&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>            buildin_clear(argc,argv);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;mkdir&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>            buildin_mkdir(argc,argv);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;rmdir&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>            buildin_rmdir(argc,argv);   <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;rm&quot;</span>,argv[<span class="hljs-number">0</span>]))<br>            buildin_rm(argc,argv); <br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;external command\n&quot;</span>);<br>    &#125;<br>    PANIC(<span class="hljs-string">&quot;my_shell: should not be here&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/15.3.png" title="fork执行ls、pwd、ps、mkdir等命令"><br>测试的时候，一直重复键入命令多了之后，就会出现问题<br><code>03195344000i[KBD   ] internal keyboard buffer full, ignoring scancode.(9f)</code><br>像是环形缓冲区当初设计的时候有bug</p><h2 id="15-3-有待开发从底层实现的一些命令"><a href="#15-3-有待开发从底层实现的一些命令" class="headerlink" title="15.3 有待开发从底层实现的一些命令"></a>15.3 有待开发从底层实现的一些命令</h2><p>该小节是纯概念上的介绍，并没有实现从底层的开发，实现这些命令需要对系统里的内存管理，文件系统管理等有非常熟悉的掌握，以及如果需要像Linux一样实现这些命令，就需要修改前面很多数据结构的定义，例如我们的文件结构只设计了三个参数，需要扩充，但是非常容易有牵一发而动全身的情况发生，因此如果需要在现有的基础上实现，那么就只能粗略地、简单地实现，作用并不是很大（虽然前面有些功能例如内存管理的实现也比较简单粗略）。因此，决定从概念上掌握这几个命令。</p><h3 id="15-3-1-exec"><a href="#15-3-1-exec" class="headerlink" title="15.3.1 exec"></a>15.3.1 exec</h3><ol><li><p>exec 的功能？<br>答：exec 会把一个可执行文件的绝对路径作为参数，把当前正在运行的用户进程的进程体（代码段、数据段、堆栈）用该可执行文件的进程体替换掉，从而实现了新进程的执行。注意，这里只替换了进程体，并没有替换其它内容，也就是进程的PCB没有被替换，新进程的pid依然是老进程的pid</p></li><li><p>为什么要有 exec？<br>答：有了exec，用户就可以完成任意外部命令的运行，或者说任意外部进程的进行，操作系统只会提供少部分的进程，实际上在使用中都是通过操作系统加载外部进程来完成我们所需要的功能的，exec起到的就是这个加载的作用</p></li><li><p>exec 的内部实现？<br>答：我们已经知道了exec就是将外部可执行文件的内容替换掉用户进程的进程体，外部可执行文件是ELF格式的，因此需要熟悉ELF格式，解析ELF格式的可执行文件，再将其中关键的信息覆盖掉原来进程的进程体。</p></li></ol><h3 id="15-3-2-系统调用wait和exit"><a href="#15-3-2-系统调用wait和exit" class="headerlink" title="15.3.2 系统调用wait和exit"></a>15.3.2 系统调用wait和exit</h3><p>wait和exit总是配合使用的</p><ol><li><p>exit的表面功能？<br>答：exit由子进程调用，是子进程结束运行。</p></li><li><p>exit的本质？<br>答：子进程结束后，会将子进程的返回值传递给内核，内核在幕后会将子进程除了PCB之外的所有资源回收。子进程的PCB不由exit释放，因为子进程的返回值需要传递给父进程，但是进程之间是相互独立的，所以通过将返回值存到子进程的PCB中，PCB处于内核空间，因此可以被进程共享。</p></li><li><p>wait的表面功能？<br>答：父进程调用，使父进程阻塞自己，直到某个子进程调用exit结束运行，获得子进程的返回值。</p></li><li><p>wait的本质？<br>答：内核在幕后将子进程的返回值传递给父进程，也就是从子进程的PCB中找到子进程的返回值并传递给父进程，并唤醒阻塞的父进程，然后将子进程的PCB回收。</p></li><li><p>为什么需要用到wait和exit？<br>答：本质上为了解决线程同步问题，打个比方，某个父进程创建了一个子进程，让它帮忙去执行其它功能，但是父进程在某些时候希望子进程执行完某些功能后将结果给父进程，父进程再继续执行，因此是为了协调父子进程某些代码的执行次序问题，所以调用wait和exit来解决。</p></li><li><p>孤儿进程和僵尸进程是怎么来的？<br>答：不正常的wait和exit配合，就会产生孤儿进程和僵尸进程。</p><ul><li>孤儿进程：在wait和exit的配合中，父进程因为一些原因，提前退出，但是它的所有子进程都还在运行还没有exit，那么这些子进程都有自己的进程体，同时失去了父进程，成为孤儿进程。不过还好，这些子进程会被init进程收留，因为init进程是所有进程的父进程</li><li>僵尸进程：子进程正常exit了，释放了进程体，但是子进程的PCB还没释放，需要父进程通过wait获得子进程的返回值的同时释放子进程的PCB，如果这时父进程没有wait，那么子进程的PCB就一直存在于内核空间，变成一个没有身体，只有头部的僵尸进程。</li><li>孤儿进程和僵尸进程的危害：孤儿进程好像没有什么特别大影响，因为最终会有init进程收尾。但是僵尸进程如果大量存在，会占用内核空间，同时占用pid号导致内核没有pid可以分配给新的进程，这种情况下只能把僵尸进程的父进程kill掉，从而释放其所有子进程的PCB。</li></ul></li></ol><h3 id="15-3-3-管道pipe"><a href="#15-3-3-管道pipe" class="headerlink" title="15.3.3 管道pipe"></a>15.3.3 管道pipe</h3><p>进程被设计成是互相独立的，但是肯定会有一些应用需要进程之间相互通信，实现进程之间通信的方法有很多种，例如消息队列，共享内存，socket网络通信，管道pipe等，下面介绍管道的原理。在Linux中，一切皆文件，所以管道也是作为文件来操作的。</p><ol><li><p>管道的位置？<br>答：多个进程之间需要分享数据，势必要有个公共区域用来共享，所以很显然，管道存在于内存之中并且在内核空间里。并且由于不知道管道需要共享的数据量，所以一般将管道设计为一个环形缓冲区进行实现。<br><img src="/../img/15.4.png" title="管道的位置"></p></li><li><p>管道的实体？<br>答：管道有两端，一端用于从管道中读出数据，另一端用于从管道写入数据，这两端使用文件描述符的方式来读取，因此进程创建管道实际上是内核为其返回了用于读取管道缓冲区的文件描述符，一个描述符只用于读，另一个描述符只用于写。</p></li><li><p>管道的创建？<br>答：通常情况，用户进程会为内核提供一个长度为2的文件描述符数组，内核在该数组中写入管道的两个文件描述符，假设该数组叫fd，则fd[0]用于读取管道，fd[1]用于写入管道。</p></li><li><p>管道的使用？<br>答：分为匿名管道和有名管道。</p><ul><li>匿名管道：一个进程在创建管道后得到数组fd，紧接着立马进行fork创建一个子进程，子进程有和父进程一样的资源，所以子进程也有一样的fd数组，此时可以通过管道完成父子进程的通信。</li><li>有名管道：如果是多个进程之间需要通信，某个进程A创建管道后，需要让其他进程也知道该管道（某个内核缓冲区）的位置，也就是文件描述符，匿名进程是通过fork让子进程知道的fd数组，对于没有父子关系的多个进程而言，则需要利用有名管道，使得该管道对其他进程“可见”，例如Linux就会通过mkfifo命令创建有名管道。<br><img src="/../img/15.5.png" title="管道的使用"></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第十四章 文件系统</title>
    <link href="/2025/01/10/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/"/>
    <url>/2025/01/10/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>文件系统涉及的函数太多，这里只列举一些概念以及测试结果</p><h2 id="14-1-文件系统概念简介"><a href="#14-1-文件系统概念简介" class="headerlink" title="14.1 文件系统概念简介"></a>14.1 文件系统概念简介</h2><p>硬盘是低速设备，读写单位是扇区，操作系统往往等数据到一定量时才一次性访问硬盘，这个量就是块，块的大小是扇区的整数倍，块是文件系统读写的单位。<br>在Windows中，块被称为簇。</p><p>以FAT文件系统为例，所有的块由链式结构组成，但通过链式结构来组织文件的弊端是当访问文件中的某个块时，必须从头开始遍历块节点。<br><img src="/../img/14.1.png" title="文件的链式结构"></p><p>链式结构弊端太大，我们使用UINX操作系统中的索引结构inode，总结就是：</p><ol><li>每个文件有自己单独的inode，inode相当于文件的身份证，是文件实体数据块在文件系统上的元信息</li><li>所有文件的inode集中管理，形成inode数组，每个inode编号就是在该inode数组下的下标</li><li>inode中的前12个直接数据块指针和后3个间接块索引表用于指向文件中的数据块实体<br><img src="/../img/14.2.png" title="inode中前12个直接数据块指针和后3个间接块索引表"></li><li>inode表示的要么是普通文件，要么是目录文件，即数据块的内容要么是普通文件的文件内容，要么是目录文件的目录项</li><li>目录项仅存在于inode指向的数据块中，有目录项的数据块就是目录<br><img src="/../img/14.3.png" title="inode与目录项的关系"></li><li>每个目录项中记录的是文件名、文件inode编号以及文件类型（普通文件还是目录文件）</li><li>inode不能直接引用，必须通过文件名找到文件名所在的目录项，然后从该目录项中获得该文件的inode编号，然后通过此编号在inode数组中找到对应的inode，进而找到对应的数据块</li><li>根目录所在的数据块的地址是被写死的</li></ol><p>超级块：每个分区某个固定位置去获取文件系统元信息的配置，超级块中存储了许多“配置信息”，例如文件系统可用数据块的数量，inode数量，分区起始扇区地址，空闲块位图地址，空闲块位图大小，inode位图地址，根目录地址，根目录大小等；超级快被固定存储在各个分区的第2个扇区，通常占一个扇区大小。<br><img src="/../img/14.4.png" title="文件系统布局"></p><h2 id="14-2-创建文件系统"><a href="#14-2-创建文件系统" class="headerlink" title="14.2 创建文件系统"></a>14.2 创建文件系统</h2><p>放两张图，一张是硬盘分区中文件系统安装后的架构，一张是超级块里存放的信息，在某个分区上进行文件系统的创建，本质上就是将该分区的内容按照这两张图的格式进行一个“修整”，形成文件系统的架构；根据这两张图的内容，我们开始创建文件系统，将文件系统的代码全部存放在新的文件夹fs中<br><img src="/../img/14.5.png" title="文件系统布局"><br><img src="/../img/14.6.png" title="超级块结构内容"></p><p>super_block.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//超级块定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> magic;<span class="hljs-comment">//魔数，用来表示文件系统类型</span><br>    <br>    <span class="hljs-type">uint32_t</span> sec_cnt;<span class="hljs-comment">//本分区的扇区数量</span><br>    <span class="hljs-type">uint32_t</span> inode_cnt;<span class="hljs-comment">//本分区中的inode数量</span><br>    <span class="hljs-type">uint32_t</span> part_lba_base;    <span class="hljs-comment">//本分区的lba起始位置</span><br>    <br>    <span class="hljs-type">uint32_t</span> block_bitmap_lba;<span class="hljs-comment">//块位图本身起始扇区lba地址</span><br>    <span class="hljs-type">uint32_t</span> block_bitmap_sects;<span class="hljs-comment">//块位图所占的扇区数</span><br>    <br>    <span class="hljs-type">uint32_t</span> inode_bitmap_lba;<span class="hljs-comment">//inode位图本身起始扇区lba地址</span><br>    <span class="hljs-type">uint32_t</span> inode_bitmap_sects;<span class="hljs-comment">//inode位图所占的扇区数</span><br>    <br>    <span class="hljs-type">uint32_t</span> inode_table_lba;<span class="hljs-comment">//inode数组本身起始扇区lba地址</span><br>    <span class="hljs-type">uint32_t</span> inode_table_sects;<span class="hljs-comment">//inode数组所占扇区数</span><br>    <br>    <span class="hljs-type">uint32_t</span> data_start_lba;<span class="hljs-comment">//存放数据区开始的第一个扇区号</span><br>    <span class="hljs-type">uint32_t</span> root_inode_no;<span class="hljs-comment">//根目录所在的inode号</span><br>    <span class="hljs-type">uint32_t</span> dir_entry_size;<span class="hljs-comment">//目录项大小</span><br>    <br>    <span class="hljs-type">uint8_t</span> pad[<span class="hljs-number">460</span>];<span class="hljs-comment">//13 * 4 + 460 = 512 为了凑够512字节凑齐一个扇区的大小</span><br>&#125; __attribute__ ((packed));<br></code></pre></td></tr></table></figure><p>我们的超级块存放在每个分区的第二扇区，并且占满整个扇区，因此后面要用<code>__attribute__ ((packed))</code>进行优化，告诉编译器不要优化这个数据结构，保持它的大小为512字节。 硬盘操作以扇区为单位，文件系统以内存块为单位，我们将内存块设计成大小与扇区一致，这样比较方便。</p><p>inode.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//inode节点定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> i_no;     <span class="hljs-comment">//inode 编号</span><br>    <span class="hljs-type">uint32_t</span> i_size;     <span class="hljs-comment">//inode指向的文件的大小</span><br>    <br>    <span class="hljs-type">uint32_t</span> i_open_cnts;   <span class="hljs-comment">//记录此文件被打开的次数</span><br>    <span class="hljs-type">bool</span> write_deny;     <span class="hljs-comment">//写文件不能并行，当该值为true时，说明此文件已经在进行写操作，其它对该文件的写操作应该被拒绝</span><br>    <br>    <span class="hljs-type">uint32_t</span> i_sectors[<span class="hljs-number">13</span>]; <span class="hljs-comment">//这里只实现了一级简介块 0-11是直接块 12是一级间接块</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">inode_tag</span>;</span><span class="hljs-comment">//用于以后加入“已打开的inode列表”</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>dir.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FILE_NAME_LEN16 <span class="hljs-comment">//最长16个字</span></span><br><br><span class="hljs-comment">/*目录结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>* <span class="hljs-title">inode</span>;</span><span class="hljs-comment">//指向已经打开的inode指针</span><br>    <span class="hljs-type">uint32_t</span> dir_pos;<span class="hljs-comment">//目录偏移位置</span><br>    <span class="hljs-type">uint8_t</span>  dir_buf[<span class="hljs-number">512</span>];<span class="hljs-comment">//目录的数据缓冲</span><br>&#125;;<br><br><span class="hljs-comment">/*目录项结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir_entry</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> filename[MAX_FILE_NAME_LEN];<span class="hljs-comment">//16个字的名字</span><br>    <span class="hljs-type">uint32_t</span> i_no;<span class="hljs-comment">//inode编号</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">file_types</span> <span class="hljs-title">f_type</span>;</span><span class="hljs-comment">//文件类型 由此看是目录还是文件类型</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>fs.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FILES_PER_PART     4096  <span class="hljs-comment">//每个扇区最大支持文件数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITS_PER_SECTOR4096  <span class="hljs-comment">//每扇区的位数 512字节 * 8</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTOR_SIZE512   <span class="hljs-comment">//每扇区的字节数 512字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZESECTOR_SIZE   <span class="hljs-comment">//块字节大小 我们这里一块 == 一扇区</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">file_types</span> </span><br><span class="hljs-class">&#123;</span><br>    FT_UNKNOWN,<span class="hljs-comment">//未知文件类型</span><br>    FT_REGULAR,<span class="hljs-comment">//普通文件类型</span><br>    FT_DIRECTORY<span class="hljs-comment">//目录文件类型</span><br>&#125;;<br><br><span class="hljs-comment">/*格式化分区，初始化分区的元信息，创建文件系统*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">partition_format</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-keyword">struct</span> partition* part)</span>;<br><span class="hljs-comment">//除了挂载 还需要在内存中把超级块指针 块位图 i结点位图 i结点指针给初始化赋值了 方便使用</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">mount_partition</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_elem* pelem,<span class="hljs-type">int</span> arg)</span>;<br><span class="hljs-comment">//在磁盘上搜索文件系统，若没有则格式化分区创建文件系统</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">filesys_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>上述都是一些结构的定义，下面开始进行文件系统代码的编写<br>fs.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span>* <span class="hljs-title">cur_part</span>;</span><span class="hljs-comment">//默认操作分区</span><br><br><span class="hljs-comment">/*格式化分区，初始化分区的元信息，创建文件系统*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">partition_format</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-keyword">struct</span> partition* part)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> boot_sector_sects = <span class="hljs-number">1</span>;<span class="hljs-comment">//引导块一个块</span><br>    <span class="hljs-type">uint32_t</span> super_block_sects = <span class="hljs-number">1</span>;<span class="hljs-comment">//超级块一个块</span><br>    <span class="hljs-type">uint32_t</span> inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART,BITS_PER_SECTOR);  <span class="hljs-comment">//inode位图占的块数</span><br>    <span class="hljs-type">uint32_t</span> inode_table_sects = DIV_ROUND_UP((<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> inode) * MAX_FILES_PER_PART),SECTOR_SIZE);<span class="hljs-comment">//inode数组所占的块数</span><br>    <br>    <span class="hljs-comment">//注意这里的used_sects 肯定是不准确 差了那么一点点的 因为还没有包含block_bitmap_sects 但是为了简单处理 要先得到free_sects才能推  所以到后面block_bitmap_sects 要除两次</span><br>    <span class="hljs-type">uint32_t</span> used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;<br>    <span class="hljs-type">uint32_t</span> free_sects = part-&gt;sec_cnt - used_sects;<br>    <span class="hljs-type">uint32_t</span> block_bitmap_sects = DIV_ROUND_UP(free_sects,BITS_PER_SECTOR);<span class="hljs-comment">//一位一块</span><br>    <span class="hljs-type">uint32_t</span> block_bitmap_bit_len = free_sects - block_bitmap_sects;<span class="hljs-comment">//再减去block_bitmap的</span><br>    block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len,BITS_PER_SECTOR);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> <span class="hljs-title">sb</span>;</span>        <span class="hljs-comment">//利用内存中的栈来初始化超级块</span><br>    sb.magic         = <span class="hljs-number">0x19590318</span>;<span class="hljs-comment">//魔数</span><br>    sb.sec_cnt       = part-&gt;sec_cnt; <span class="hljs-comment">//该分区总扇区数</span><br>    sb.inode_cnt     = MAX_FILES_PER_PART;<span class="hljs-comment">//该分区总inode数</span><br>    sb.part_lba_base = part-&gt;start_lba;<span class="hljs-comment">//该分区lba起始扇区位置</span><br>    <span class="hljs-comment">// 引导块 超级块 空闲块位图 inode位图 inode数组 根目录 空闲块区域</span><br>    <span class="hljs-comment">//挨着挨着顺序赋值即可</span><br>    sb.block_bitmap_lba   = part-&gt;start_lba + boot_sector_sects + super_block_sects;<br>    sb.block_bitmap_sects = block_bitmap_sects;<br><br>    sb.inode_bitmap_lba   = sb.block_bitmap_lba + block_bitmap_sects;<br>    sb.inode_bitmap_sects = inode_bitmap_sects;<br>    <br>    sb.inode_table_lba    = sb.inode_bitmap_lba + inode_bitmap_sects;<br>    sb.inode_table_sects  = inode_table_sects;<br>    <br>    sb.data_start_lba     = sb.inode_table_lba + inode_table_sects;<br>    sb.root_inode_no   = <span class="hljs-number">0</span>;<span class="hljs-comment">//根目录inode起始编号 0 </span><br>    sb.dir_entry_size     = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> dir_entry); <span class="hljs-comment">//目录项大小</span><br>    <br>    printk(<span class="hljs-string">&quot;%s  info:\n&quot;</span>,part-&gt;name);<br>    printk(<span class="hljs-string">&quot;    magic:0x%x\n    part_lba_base:0x%x\n    all_sectors:0x%x\n    \</span><br><span class="hljs-string">inode_cnt:0x%x\n    block_bitmap_lba:0x%x\n    block_bitmap_sectors:0x%x\n    \</span><br><span class="hljs-string">inode_bitmap_lba:0x%x\n    inode_bitmap_sectors:0x%x\n    \</span><br><span class="hljs-string">inode_table_lba:0x%x\n    inode_table_sectors:0x%x\n    \</span><br><span class="hljs-string">data_start_lba:0x%x\n&quot;</span>, \<br>    sb.magic,sb.part_lba_base,sb.sec_cnt,sb.inode_cnt,sb.block_bitmap_lba,sb.block_bitmap_sects,\<br>    sb.inode_bitmap_lba,sb.inode_bitmap_sects,sb.inode_table_lba,\<br>    sb.inode_table_sects,sb.data_start_lba);   <br>    <br>    <span class="hljs-comment">//将上述在内存中定义好的超级块信息写入到硬盘对应分区的扇区1</span><br>    ide_write(hd,part-&gt;start_lba + boot_sector_sects,&amp;sb,super_block_sects);<br>    printk(<span class="hljs-string">&quot;    super_block_lba:0x%x\n&quot;</span>,part-&gt;start_lba + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">//找一个最大的数据缓冲区 我们的栈已经不足以满足我们的各种信息的储存了 之后还要把元信息给腾到硬盘中</span><br>    <span class="hljs-type">uint32_t</span> buf_size = (sb.block_bitmap_sects &gt;= sb.inode_bitmap_sects) ? sb.block_bitmap_sects : sb.inode_bitmap_sects;<br>    buf_size = ((buf_size &gt;= inode_table_sects) ? buf_size : inode_table_sects) * SECTOR_SIZE;<br>    <span class="hljs-comment">//申请缓冲空间 给元信息腾空间 设置成uint8_t* 原因是 先弄块位图的初始化</span><br>    <span class="hljs-type">uint8_t</span>* buf = (<span class="hljs-type">uint8_t</span>*)sys_malloc(buf_size);<br>    <br>    <span class="hljs-comment">/* 初始化块位图了 */</span><br>    buf[<span class="hljs-number">0</span>] |= <span class="hljs-number">0x1</span>;      <span class="hljs-comment">//因为第0个空闲块作为了根目录</span><br>    <span class="hljs-type">uint32_t</span> block_bitmap_last_byte = block_bitmap_bit_len / <span class="hljs-number">8</span>; <span class="hljs-comment">//先算算占用多少字节</span><br>    <span class="hljs-type">uint8_t</span> block_bitmap_last_bit  = block_bitmap_bit_len % <span class="hljs-number">8</span>; <span class="hljs-comment">//最后还有剩余多少位</span><br>    <span class="hljs-type">uint32_t</span> last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE); <span class="hljs-comment">//先除余数 算出来多少字节空的</span><br>    <br>    <br>    <span class="hljs-comment">//处理字节 把可能多的一字节全部置成1，也就是把空闲块位图占用的最后一个扇区的本不属于位图的部分直接全部置1，假装它们属于位图但已经被使用了，那其实和它们不属于该位图是一样的意义，方便以后对空闲块位图的读取直接用扇区的整数倍</span><br>    <span class="hljs-built_in">memset</span>(&amp;buf[block_bitmap_last_byte],<span class="hljs-number">0xff</span>,last_size); <span class="hljs-comment">//全部置1 保证不会被使用</span><br>    <span class="hljs-comment">//处理最后的位 有效位变成0</span><br>    <span class="hljs-type">uint8_t</span> bit_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(bit_idx &lt;= block_bitmap_last_bit)<br>    buf[block_bitmap_last_byte] &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; (bit_idx++));<span class="hljs-comment">//有效位</span><br>    <br>    <span class="hljs-comment">//把位图元信息给写到硬盘中 块位图的部分就结束了 还有inode位图 inode数组等着我们</span><br>    ide_write(hd,sb.block_bitmap_lba,buf,sb.block_bitmap_sects);<br>    <br>    <span class="hljs-comment">/*初始化inode位图，设置只支持4096个inode，因此inode位图刚好占用一个扇区*/</span><br>    <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,buf_size);<br>    buf[<span class="hljs-number">0</span>] |= <span class="hljs-number">0x1</span>;                                          <span class="hljs-comment">//第一个inode用于存根目录</span><br>    ide_write(hd,sb.inode_bitmap_lba,buf,sb.inode_bitmap_sects); <span class="hljs-comment">//第一个inode初始化在后面</span><br>    <br>    <span class="hljs-comment">/*初始化inode数组，将根目录对应的inode写入硬盘*/</span><br>    <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,buf_size);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>* <span class="hljs-title">i</span> =</span> (<span class="hljs-keyword">struct</span> inode*)buf;<span class="hljs-comment">//先初始化第一个inode 根目录所在的</span><br>    i-&gt;i_size = sb.dir_entry_size * <span class="hljs-number">2</span>;<span class="hljs-comment">//. 和 .. </span><br>    i-&gt;i_no   = <span class="hljs-number">0</span>;<br>    i-&gt;i_sectors[<span class="hljs-number">0</span>]  = sb.data_start_lba;<span class="hljs-comment">//根目录所在扇区就是最开始的第一个扇区</span><br>    <br>    ide_write(hd,sb.inode_table_lba,buf,sb.inode_table_sects);<br>    <br>    <span class="hljs-comment">/*写根目录的两个目录项*/</span><br>    <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,buf_size);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dir_entry</span>* <span class="hljs-title">p_de</span> =</span> (<span class="hljs-keyword">struct</span> dir_entry*)buf;<br>    <br>    <span class="hljs-built_in">memcpy</span>(p_de-&gt;filename,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//名称</span><br>    p_de-&gt;i_no = <span class="hljs-number">0</span>;<span class="hljs-comment">//根目录. inode仍然是自己</span><br>    p_de-&gt;f_type = FT_DIRECTORY;<br>    p_de++;<span class="hljs-comment">//移动到下一条目录项</span><br>    <br>    <span class="hljs-built_in">memcpy</span>(p_de-&gt;filename,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-number">2</span>);<br>    p_de-&gt;i_no = <span class="hljs-number">0</span>;<span class="hljs-comment">//根目录的父目录仍然是自己 因为自己是固定好的 根基</span><br>    p_de-&gt;f_type = FT_DIRECTORY;<br>    <br>    ide_write(hd,sb.data_start_lba,buf,<span class="hljs-number">1</span>);<span class="hljs-comment">//把根目录文件写到数据块的第一个扇区中</span><br>    <br>    printk(<span class="hljs-string">&quot;    root_dir_lba:0x%x\n&quot;</span>,sb.data_start_lba);<br>    printk(<span class="hljs-string">&quot;%s format done\n&quot;</span>,part-&gt;name);<br>    sys_free(buf);<br>&#125;<br><br><span class="hljs-comment">//除了挂载 还需要在内存中把超级块指针 块位图 i结点位图 i结点指针给初始化赋值了 方便使用</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">mount_partition</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_elem* pelem,<span class="hljs-type">int</span> arg)</span><br>&#123;<br>    <span class="hljs-type">char</span>* part_name = (<span class="hljs-type">char</span>*)arg;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span>* <span class="hljs-title">part</span> =</span> elem2entry(<span class="hljs-keyword">struct</span> partition,part_tag,pelem);<span class="hljs-comment">//得到分区指针 partition*</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(part-&gt;name,part_name))   <span class="hljs-comment">//字符串相匹配</span><br>    &#123;<br>    cur_part = part;   <span class="hljs-comment">//赋值指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk</span>* <span class="hljs-title">hd</span> =</span> cur_part-&gt;my_disk;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>* <span class="hljs-title">sb_buf</span> =</span> (<span class="hljs-keyword">struct</span> super_block*)sys_malloc(SECTOR_SIZE);<br>    <span class="hljs-keyword">if</span>(sb_buf == <span class="hljs-literal">NULL</span>)<br>        PANIC(<span class="hljs-string">&quot;alloc memory failed!&quot;</span>);<br>    <br>    <span class="hljs-built_in">memset</span>(sb_buf,<span class="hljs-number">0</span>,SECTOR_SIZE);<br>    ide_read(hd,cur_part-&gt;start_lba + <span class="hljs-number">1</span>,sb_buf,<span class="hljs-number">1</span>);<br>    <br>    cur_part-&gt;sb = sb_buf;<br>    <br>    cur_part-&gt;block_bitmap.bits = (<span class="hljs-type">uint8_t</span>*)sys_malloc(sb_buf-&gt;block_bitmap_sects * SECTOR_SIZE);<br>    <span class="hljs-keyword">if</span>(cur_part-&gt;block_bitmap.bits == <span class="hljs-literal">NULL</span>)<br>       PANIC(<span class="hljs-string">&quot;alloc memory failed!&quot;</span>);<br>    cur_part-&gt;block_bitmap.btmp_bytes_len = sb_buf-&gt;block_bitmap_sects * SECTOR_SIZE;<br>    ide_read(hd,sb_buf-&gt;block_bitmap_lba,cur_part-&gt;block_bitmap.bits,sb_buf-&gt;block_bitmap_sects);<br>    <br>        cur_part-&gt;inode_bitmap.bits = (<span class="hljs-type">uint8_t</span>*)sys_malloc(sb_buf-&gt;inode_bitmap_sects * SECTOR_SIZE);<br>        <span class="hljs-keyword">if</span>(cur_part-&gt;inode_bitmap.bits == <span class="hljs-literal">NULL</span>)<br>       PANIC(<span class="hljs-string">&quot;alloc memory failed!&quot;</span>);<br>    cur_part-&gt;inode_bitmap.btmp_bytes_len = sb_buf-&gt;inode_bitmap_sects * SECTOR_SIZE;<br>    ide_read(hd,sb_buf-&gt;inode_bitmap_lba,cur_part-&gt;inode_bitmap.bits,sb_buf-&gt;inode_bitmap_sects);<br>    <br>    list_init(&amp;cur_part-&gt;open_inodes);<br>    printk(<span class="hljs-string">&quot;mount %s done!\n&quot;</span>,part-&gt;name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//停止循环</span><br>    <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//继续循环</span><br>&#125;<br><br><span class="hljs-comment">//在磁盘上搜索文件系统，若没有则格式化分区创建文件系统</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">filesys_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> channel_no = <span class="hljs-number">0</span>,dev_no,part_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>* <span class="hljs-title">sb_buf</span> =</span> (<span class="hljs-keyword">struct</span> super_block*)sys_malloc(SECTOR_SIZE);<br>    <br>    <span class="hljs-keyword">if</span>(sb_buf == <span class="hljs-literal">NULL</span>)PANIC(<span class="hljs-string">&quot;alloc memory failed!&quot;</span>);<br>    printk(<span class="hljs-string">&quot;searching filesysteam......\n&quot;</span>);<br>    <span class="hljs-keyword">while</span>(channel_no &lt; channel_cnt)<br>    &#123;<br>    dev_no = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(dev_no &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dev_no == <span class="hljs-number">0</span>)<span class="hljs-comment">//跳过master.img主盘</span><br>        &#123;<br>        ++dev_no;<br>        <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk</span>* <span class="hljs-title">hd</span> =</span> &amp;channels[<span class="hljs-number">0</span>].devices[<span class="hljs-number">1</span>];<span class="hljs-comment">//得到硬盘指针</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span>* <span class="hljs-title">part</span> =</span> hd-&gt;prim_parts;<span class="hljs-comment">//先为主区创建文件系统</span><br>        <span class="hljs-keyword">while</span>(part_idx &lt; <span class="hljs-number">12</span>)<span class="hljs-comment">//4个主区 + 8个逻辑分区</span><br>        &#123;<br>        <span class="hljs-keyword">if</span>(part_idx == <span class="hljs-number">4</span>)<br>            part = hd-&gt;logic_parts;<br>        <span class="hljs-keyword">if</span>(part-&gt;sec_cnt != <span class="hljs-number">0</span>)<span class="hljs-comment">//分区存在 如果没有初始化 即所有成员都为0</span><br>        &#123;<br>            <span class="hljs-built_in">memset</span>(sb_buf,<span class="hljs-number">0</span>,SECTOR_SIZE);<br>            ide_read(hd,part-&gt;start_lba +<span class="hljs-number">1</span>,sb_buf,<span class="hljs-number">1</span>);<span class="hljs-comment">//读取超级块的扇区</span><br>            <br>            <span class="hljs-keyword">if</span>(sb_buf-&gt;magic != <span class="hljs-number">0x19590318</span>)<span class="hljs-comment">//还没有创建文件系统</span><br>            &#123;<br>            printk(<span class="hljs-string">&quot;formatting %s&#x27;s partition %s......\n&quot;</span>,\<br>            hd-&gt;name,part-&gt;name);<br>            partition_format(hd,part);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            printk(<span class="hljs-string">&quot;%s has filesystem\n&quot;</span>,part-&gt;name);<br>        &#125;<br>        ++part_idx;<br>        ++part;<span class="hljs-comment">//到下一个分区看</span><br>        &#125;<br>        ++dev_no;<span class="hljs-comment">//切换盘号</span><br>    &#125;<br>    ++channel_no;<span class="hljs-comment">//增加ide通道号</span><br>    &#125;<br>    sys_free(sb_buf);<br>    <span class="hljs-type">char</span> default_part[<span class="hljs-number">8</span>] = <span class="hljs-string">&quot;sdb1&quot;</span>;<span class="hljs-comment">//参数为int 4字节字符串指针传的进去</span><br>    list_traversal(&amp;partition_list,mount_partition,(<span class="hljs-type">int</span>)default_part);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在处理空闲块位图时，由于空闲块位图通常需要占用多个扇区，因此最后一个扇区很可能只用到了前半部分用来当做空闲块位图，后半部分则属于无效数据，直接将后半部分的无效数据全都置1，假装属于位图的一部分但已经被分配，则也相当于无效数据，方便直接以扇区为单位操作（个人感觉没什么意义）</p><p>上述函数，将inode数组的第0个设置为了根目录，并将根目录inode中第0个直接数据块指向了分区中数据块开始的第一个扇区，并在后面直接在数据开始的第一个扇区写入了根目录的两个目录项，因为每个目录文件都会有两个目录项数据，一个是<code>.</code>代表自己，一个是<code>..</code>代表上一级</p><p>Windows下系统的分区很简单，C、D盘直接摆在那，但是Linux下默认内核所在分区为默认分区，如果想要使用其它分区，则需要利用<code>mount</code>指令将其他分区挂载到默认分区的某个目录下，不用的时候再通过<code>umount</code>指令卸载<br>一般操作系统是安装到文件系统上的，例如我们平时装操作系统，都是装到类似C盘之类的地方，并利用文件系统将该盘格式化后再正式安装操作系统，因此文件系统在操作系统之前已经存在，但我们简单点，只实现简单的挂载功能：直接选择待操作的分区。<br>挂载分区的实质是把该分区文件系统的元信息从硬盘上读出来加载到内存中。</p><p><img src="/../img/14.7.png" title="将文件系统初始化"></p><p>上图是执行第一次之后的系统，因为文件系统只要在第一次为每个分区格式化后，是会保存到硬盘里的，也就是说再次执行后不会进行格式化。</p><h2 id="14-3-文件描述符简介"><a href="#14-3-文件描述符简介" class="headerlink" title="14.3 文件描述符简介"></a>14.3 文件描述符简介</h2><p>Linux中所有文件操作都是基于文件描述符，简单介绍一下文件描述符和inode的区别：</p><ol><li>文件描述符描述的对象是文件的操作，inode更像是描述文件的内存存储管理</li><li>如果多个进程打开一个文件，或者一个进程打开多次同一个文件，每次被打开的时候偏移量是可以指定的，并且不同次打开的偏移量互相之间不影响，那么这种偏移量应该记录在哪里，inode只记录与存储有关的信息，因此Linux提供了称为“文件结构”的数据结构。<br><img src="/../img/14.8.png" title="文件结构"></li><li>文件结构中存储有文件偏移量，文件对应inode指针，文件打开标志等信息</li><li>Linux把所有文件结构组织到一起形成数组统一管理，这个数组叫做文件表</li></ol><p>文件描述符：</p><ol><li>是一个整型数字，通过open返回的一个数字</li><li>是位于进程PCB文件描述符数组的一个下标</li><li>在Linux中每个进程都会有单独的，完全相同的一套文件描述符，这些文件描述符被组织称文件描述符数组统一管理，文件描述符数组中前三个都是标准文件描述符，0是标准输入，1是标准输出，2是标准错误</li><li>从图文件结构我们可以看到，一个文件结构占最少十几个字节，一个文件可能会对应多个文件结构，因此进程形成的文件表会很庞大，PCB是放不下的，因此PCB只放一个文件描述符数组，通过数组在文件表中找到对应文件结构，这个文件表放在其他地方，是全局的<br><img src="/../img/14.9.png" title="文件描述符与inode关联关系"></li></ol><p>Linux通过文件描述符查找文件数据块的过程：</p><ol><li>某进程将文件描述符作为参数提交给文件系统</li><li>文件系统用此文件描述符在该进程PCB中的文件描述符数组索引对应元素</li><li>根据对应元素，在文件表中找到对应下标，通过下标对应的文件结构中的inode，最终找到数据块</li></ol><p>open操作的本质就是创建文件描述符：</p><ol><li>在全局的inode队列中新建一个inode</li><li>在全局的文件表中的空位填充文件结构，使fd_inode指向第一步新建的inode</li><li>在PCB的文件描述符数组中找到空位使里面的值指向上一步文件结构的下标。</li></ol><p>先改进PCB，在定义和初始化里加入文件描述符数组</p><h2 id="14-4-文件操作的相关基础函数"><a href="#14-4-文件操作的相关基础函数" class="headerlink" title="14.4 文件操作的相关基础函数"></a>14.4 文件操作的相关基础函数</h2><p>内容太多，不列举了，详情参考github</p><h2 id="14-5-创建文件"><a href="#14-5-创建文件" class="headerlink" title="14.5 创建文件"></a>14.5 创建文件</h2><p>在创建文件前，我们已经将sdb1挂载，也就是现在操作的分区是sdb1<br><img src="/../img/14.10.png" title="当前系统sdb1的可用起始扇区"><br>可以看到可用数据的起始扇区和root的起始扇区是一样的0xA6B，这是合理的，因为root根目录本身也是文件的一种，只是被固定放到了可用扇区的起始位置<br><img src="/../img/14.11.png" title="0xA6B*512字节处的数据"><br>我们来看从盘slave对应的位置，也就是0xA6B*512字节处的数据，该处存放的是根目录文件，目录中的内容是目录项，每个目录项包括三部分内容：16字节的文件名，4字节的inode编号，4字节的文件类型，一共24字节。因此红色框和蓝色框分别是两个目录项。<br>先来看红色框，前16字节只有0x2e可用数据，0x2e是字符<code>.</code>的ascii码，因为每个目录一定会存在两个目录项在开头，分别是<code>.</code>当前目录和<code>..</code>上一级目录，接下来4字节inode编号为0，因为root根目录当前目录就是自己，而根目录的inode编号是0，后面4字节文件类型为02，也就是指向的文件是目录文件。<br>再来看蓝色框，前16字节有0x2e2e，也就是<code>..</code>，根目录的上级目录指向自己，因此inode也是0，后面同红色框。</p><p>现在我们在主函数中调用创建函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   process_execute(u_prog_a, <span class="hljs-string">&quot;u_prog_a&quot;</span>);<br>   process_execute(u_prog_b, <span class="hljs-string">&quot;u_prog_b&quot;</span>); <br>   thread_start(<span class="hljs-string">&quot;k_thread_a&quot;</span>, <span class="hljs-number">31</span>, k_thread_a, <span class="hljs-string">&quot;argA &quot;</span>);<br>   thread_start(<span class="hljs-string">&quot;k_thread_b&quot;</span>, <span class="hljs-number">31</span>, k_thread_b, <span class="hljs-string">&quot;argB &quot;</span>);  <br>   sys_open(<span class="hljs-string">&quot;/file1&quot;</span>,O_CREAT);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/14.12.png" title="执行创建函数后0xA6B*512字节处的数据"><br>创建文件后，我们在根目录下创建了一个file1文件，这个文件暂时没有数据，因为它在根目录下，所以根目录文件里的目录项会多出一项，也就是图上的绿色框，前16字节是文件名file1，中间4个字节是inode编号为3，同时最后四个字节是1，证明文件类型为普通文件。</p><h2 id="14-6-文件的打开与关闭"><a href="#14-6-文件的打开与关闭" class="headerlink" title="14.6 文件的打开与关闭"></a>14.6 文件的打开与关闭</h2><p>上一节我们已经在根目录下创建了一个file1文件<br>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   <span class="hljs-type">uint32_t</span> fd = sys_open(<span class="hljs-string">&quot;/file1&quot;</span>,O_RDONLY);<br>   printk(<span class="hljs-string">&quot;fd_no : %d\n&quot;</span>,fd);<br>   sys_close(fd);<br>   printk(<span class="hljs-string">&quot;fd_no : %d has closed\n&quot;</span>);<br>   fd = sys_open(<span class="hljs-string">&quot;/file1&quot;</span>,O_RDONLY);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/14.13.png" title="执行file1文件的打开与关闭"></p><h2 id="14-7-文件的写入"><a href="#14-7-文件的写入" class="headerlink" title="14.7 文件的写入"></a>14.7 文件的写入</h2><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   <span class="hljs-type">uint32_t</span> fd = sys_open(<span class="hljs-string">&quot;/file1&quot;</span>,O_RDWR);<br>   printk(<span class="hljs-string">&quot;fd:%d\n&quot;</span>,fd);<br>   sys_write(fd,<span class="hljs-string">&quot;hello,world\n&quot;</span>,<span class="hljs-number">12</span>);<br>   sys_close(fd);<br>   printk(<span class="hljs-string">&quot;fd_no : %d has closed\n&quot;</span>,fd);<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/14.14.png" title="执行对file1文件的写入"><br>因为重复执行了两遍，所以会有重复的两段内容</p><h2 id="14-8-文件的读取"><a href="#14-8-文件的读取" class="headerlink" title="14.8 文件的读取"></a>14.8 文件的读取</h2><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>   <br>   <br>   <span class="hljs-type">uint32_t</span> fd = sys_open(<span class="hljs-string">&quot;/file1&quot;</span>,O_RDONLY);<br>   <span class="hljs-type">int</span> read_bytes = sys_read(fd,buf,<span class="hljs-number">12</span>);<br>   printk(<span class="hljs-string">&quot;1_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br>   read_bytes = sys_read(fd,buf,<span class="hljs-number">12</span>);<br>   printk(<span class="hljs-string">&quot;2_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br>   read_bytes = sys_read(fd,buf,<span class="hljs-number">12</span>);<br>   printk(<span class="hljs-string">&quot;3_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br>   sys_close(fd);<br><br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/14.15.png" title="执行对file1文件的读取并打印"><br>连续读取三次12字节，执行三次sys_read函数，可以看到第三次就没法读取了，因为如果连续执行sys_read函数，文件的读写指针也会连续，而不是每次sys_read函数都从文件头开始</p><h2 id="14-9-实现文件读写指针定位的功能"><a href="#14-9-实现文件读写指针定位的功能" class="headerlink" title="14.9 实现文件读写指针定位的功能"></a>14.9 实现文件读写指针定位的功能</h2><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>   <br>   <br>   <span class="hljs-type">uint32_t</span> fd = sys_open(<span class="hljs-string">&quot;/file1&quot;</span>,O_RDONLY);<br>   <span class="hljs-type">int</span> read_bytes = sys_read(fd,buf,<span class="hljs-number">12</span>);<br>   printk(<span class="hljs-string">&quot;1_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br>   read_bytes = sys_read(fd,buf,<span class="hljs-number">12</span>);<br>   printk(<span class="hljs-string">&quot;2_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br>   read_bytes = sys_read(fd,buf,<span class="hljs-number">12</span>);<br>   printk(<span class="hljs-string">&quot;3_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br><br>   printk(<span class="hljs-string">&quot;________ SEEK_SET 0 ________\n&quot;</span>);<br>   sys_lseek(fd,<span class="hljs-number">0</span>,SEEK_SET);<br>   <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(buf));<br>   read_bytes = sys_read(fd,buf,<span class="hljs-number">25</span>);<br>   printk(<span class="hljs-string">&quot;4_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br><br>   printk(<span class="hljs-string">&quot;________ SEEK_SET 6 ________\n&quot;</span>);<br>   sys_lseek(fd,<span class="hljs-number">6</span>,SEEK_SET);<br>   <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(buf));<br>   read_bytes = sys_read(fd,buf,<span class="hljs-number">5</span>);<br>   printk(<span class="hljs-string">&quot;5_ read %d bytes:\n%s\n&quot;</span>,read_bytes,buf);<br>   <br>   printk(<span class="hljs-string">&quot;________ SEEK_CUR 1________\n&quot;</span>);<br>   sys_lseek(fd,<span class="hljs-number">1</span>,SEEK_CUR);<br>   <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(buf));<br>   read_bytes = sys_read(fd,buf,<span class="hljs-number">24</span>);<br>   printk(<span class="hljs-string">&quot;6_ read %d bytes:\n%s&quot;</span>,read_bytes,buf);<br><br>   sys_close(fd);<br><br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>证明了系统调用sys_lseek的可行性</p><h2 id="14-10-实现文件删除功能"><a href="#14-10-实现文件删除功能" class="headerlink" title="14.10 实现文件删除功能"></a>14.10 实现文件删除功能</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   printk(<span class="hljs-string">&quot;/file1 delete %s!\n&quot;</span>,sys_unlink(<span class="hljs-string">&quot;/file1&quot;</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;done&quot;</span> : <span class="hljs-string">&quot;fail&quot;</span>);<br><br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/14.16.png" title="执行对file1文件的删除"><br>linux对文件删除的函数是sys_unlink</p><h2 id="14-11-创建目录"><a href="#14-11-创建目录" class="headerlink" title="14.11 创建目录"></a>14.11 创建目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>   put_str(<span class="hljs-string">&quot;I am kernel\n&quot;</span>);<br>   init_all();<br><br>   intr_enable();<br>   printk(<span class="hljs-string">&quot;/dir1/subdir1 create %s!\n&quot;</span>,(sys_mkdir(<span class="hljs-string">&quot;/dir1/subdir1&quot;</span>) == <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;done&quot;</span> : <span class="hljs-string">&quot;fail&quot;</span>);<br>   printk(<span class="hljs-string">&quot;/dir1 create %s!\n&quot;</span>,(sys_mkdir(<span class="hljs-string">&quot;/dir1&quot;</span>) == <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;done&quot;</span> : <span class="hljs-string">&quot;fail&quot;</span>);<br>   printk(<span class="hljs-string">&quot;/dir1/subdir1 create %s!\n&quot;</span>,(sys_mkdir(<span class="hljs-string">&quot;/dir1/subdir1&quot;</span>) == <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;done&quot;</span> : <span class="hljs-string">&quot;fail&quot;</span>);<br>   <span class="hljs-type">int</span> fd = sys_open(<span class="hljs-string">&quot;/dir1/subdir1/file2&quot;</span>,O_CREAT | O_RDWR);<br>   <span class="hljs-keyword">if</span>(fd != <span class="hljs-number">-1</span>)<br>   &#123;<br>        printk(<span class="hljs-string">&quot;/dir1/subdir1/file2 create done!\n&quot;</span>);<br>        sys_write(fd,<span class="hljs-string">&quot;Catch me if u can!\n&quot;</span>,<span class="hljs-number">19</span>);<br>        sys_lseek(fd,<span class="hljs-number">0</span>,SEEK_SET);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        sys_read(fd,buf,<span class="hljs-number">19</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;/dir1/subdir1/file2 says:\n%s&quot;</span>,buf);<br>        sys_close(fd);<br>   &#125;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/14.17.png" title="执行对目录的创建"><br>linux对目录创建的函数是sys_mkdir</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“C++ Primer Plus” 第一到七章 笔记总结</title>
    <link href="/2025/01/09/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E4%B8%80%E5%88%B0%E4%B8%83%E7%AB%A0%20%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    <url>/2025/01/09/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E7%AC%AC%E4%B8%80%E5%88%B0%E4%B8%83%E7%AB%A0%20%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a>第三章 处理数据</h1><ol><li>一般在32位系统和64位系统上，int类型通常是32位，即4个字节，在某些嵌入式系统或老旧架构上，可能是16位</li><li>头文件climits定义了很多符号常量来表示对类型的限制，例如<code>INT_MAX</code>表示int类型的最大值</li><li>c++11对单值变量的另一种初始化方式：利用大括号初始化器，如<code>int a&#123;5&#125;   //a初始化为5</code>，特点：<ul><li>采用这种方式时，可以使用&#x3D;连接也可以不使用</li><li>大括号内也可以是空的，这样默认初始化为0</li><li>有助于更好的防范类型转换错误</li><li>让大括号初始化器可初始化所有类型，让初始化更统一，便于新手学习</li></ul></li><li>对于整型常量，c++编译器一般将其存储为int类型，除非有别的理由，例如有后缀或者十六进制数之类的</li><li>编译器提供隐式转换，例如<code>bool start = -100</code>，会被隐式转化为false</li><li>c++使用<code>const</code>关键字限定常量，限定的常量不可修改，即具有只读的属性，注意，应在声明中对const进行初始化；语言中可以用<code>#define</code>来进行常量声明，但c++的const更好，理由：<ul><li>能够明确指定类型 <code>const int a = 1</code></li><li>可以使用c++的作用域规则将定义限制在特定的函数或者文件中</li><li>可用于更复杂的类型，例如数组或struct</li></ul></li><li>浮点数float的运算速度比较慢，并且在运算时有时候会有精度问题：<code>2.34E22f + 1.0f - 2.34E22f</code>理论上应该是1，但实际程序输出0.因为浮点数能表示的精度大概在6到8位，而小数点前23位只能表示前6到8位，如果加1是加在第23位上，在计算机眼里相当于没加，因为精度不够，只能看到前6到8位，所以程序会直接输出0</li><li>c++在进行算术运算时，如果两个操作数是不同类型，c++会通过校验表把它们转为统一类型再计算</li><li>c++11可以用大括号的初始化方式进行列表初始化，但对类型转换的要求更加严格，不允许出现缩窄(narrowing)，即变量的类型可能无法表示赋给它的值。例如<code>int x = 66;     char c &#123;x&#125;;</code>是不被允许的，在编译器看来x是个变量，数值可能远大于char能表示的范围。</li><li>强制转换的格式如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(<span class="hljs-type">int</span>) x     <span class="hljs-comment">//C风格</span><br><span class="hljs-type">int</span>(x)      <span class="hljs-comment">//纯粹C++风格</span><br></code></pre></td></tr></table></figure>使用第二种c++风格，想法是，让强制类型转换看起来像是函数调用。</li></ol><h1 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><ol><li>只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组</li><li>初始化数组时，提供的值可以少于数组的元素数目，空缺的会自动补0</li><li>如果初始化为{1}，则第一个元素为1，后面元素为0<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">//第一个元素被赋值0，后面的元素默认补充为0</span><br><span class="hljs-type">int</span> b[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>&#125;;     <span class="hljs-comment">//第一个元素被赋值为1，后面的元素默认补充为0</span><br></code></pre></td></tr></table></figure></li><li>c++11数组的初始化：<ul><li>初始化数组时，可省略&#x3D;号</li><li>可不在大括号内包含任何东西，这会默认所有元素设置为0</li><li>禁止缩窄转换</li></ul></li><li>浮点数转换为整数是缩窄操作</li></ol><h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><ol><li>C利用字符数组来定义一个字符串，我们来看以下代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;S&#x27;</span>;   <span class="hljs-comment">//正确</span><br><span class="hljs-type">char</span> b = <span class="hljs-string">&quot;S&quot;</span>;   <span class="hljs-comment">//错误，因为&quot;S&quot;是字符串，实际上包括&#x27;S&#x27;和&#x27;\0&#x27;，并且&quot;S&quot;表示的是字符&#x27;S&#x27;所在的地址，这个操作将地址赋给字符，明显是错的</span><br></code></pre></td></tr></table></figure></li><li>c++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个</li><li><code>sizeof</code>函数计算整个数组的大小，<code>strlen</code>函数计算数组内字符串的长度，并且是可见字符，不包括\0。</li></ol><h2 id="4-3-string类简介"><a href="#4-3-string类简介" class="headerlink" title="4.3 string类简介"></a>4.3 string类简介</h2><ol><li>c++提供string类，可以更方便操作字符串</li><li>可以使用C风格字符串来初始化string对象，string与字符数组最大的区别就是，可以将string对象声明为简单变量，而不是一个数组</li><li>可以使用cin和cout来直接操纵string</li><li>也可以使用数组表示法来操控string里的某个字符</li><li>可以通过<code>str1 = str2 + str3;</code>拼接字符</li><li>string具有自动调整大小的功能</li></ol><h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4 结构体"></a>4.4 结构体</h2><ol><li>结构体比数组更灵活，可以存储不同类型的数据，结构体是c++OOP的基石</li><li>结构体的初始化，可以和数组一样，用大括号括起来，例如<code>student a = &#123;&quot;xiaoming&quot;, 5, 0.5&#125;;</code></li></ol><h2 id="4-5-共用体"><a href="#4-5-共用体" class="headerlink" title="4.5 共用体"></a>4.5 共用体</h2><ol><li>共用体是一种数据格式，能够存储不同的数据类型，但只能同时存储一个类型</li><li>定义的方式和结构体类似，把struct换成union</li><li>匿名共用体没有名称，其成员将成为位于相同地址的变量</li><li>共用体常用于节省内存</li><li>举了个例子：下述代码中的test只能在同一时间拥有一个类型的变量，换种说法，共用体就是一个变量，但是可以表示定义内的三种类型<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">bool</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-6-枚举"><a href="#4-6-枚举" class="headerlink" title="4.6 枚举"></a>4.6 枚举</h2><ol><li>枚举量是整型的话，可被提升为int类型，但int类型不能自动转换为枚举类型</li><li>一般而言省略枚举类型的名称，只是用来定义相关的符号常量</li></ol><h2 id="4-7-指针和自由存储空间"><a href="#4-7-指针和自由存储空间" class="headerlink" title="4.7 指针和自由存储空间"></a>4.7 指针和自由存储空间</h2><ol><li>OOP强调的是在运行阶段（而不是编译阶段）进行决策。例如一个数组，如果在编译阶段定死了容量只有20，那么如果运行时需要200个元素就会报错，如果定死容量在200，那么容易浪费空间。C++采用关键字new请求正确数量的内存分配以及使用指针来跟踪新分配的内存。</li><li><code>int* x, y;      //创建的是一个int*的变量和一个int的变量</code>   <code>int* x, *y;      //创建的是两个int*的变量</code> </li><li>C++在创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向数据的内存，例如下述经典错误：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* x;<br>*x = <span class="hljs-number">2233</span>;<br></code></pre></td></tr></table></figure>该代码是错误的，x确实是个指针，但并没有分配好指向哪里。</li><li>一定要在*指针之前，将指针初始化为一个确定的、适当的地址</li><li>指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值</li><li>常规变量定义时的值一般存储在栈上，new分配的内存块通常在堆上</li><li>使用new创建数组时，要注意delete的时候加中括号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> [] x;        <span class="hljs-comment">//方括号告诉程序，应该释放整个数组，而不是指针指向的元素</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="第五章-循环和关系表达式"><a href="#第五章-循环和关系表达式" class="headerlink" title="第五章 循环和关系表达式"></a>第五章 循环和关系表达式</h1><p>感觉基本都会了，跳过跳过</p><h1 id="第六章-分支语句和逻辑运算符"><a href="#第六章-分支语句和逻辑运算符" class="headerlink" title="第六章 分支语句和逻辑运算符"></a>第六章 分支语句和逻辑运算符</h1><p>好像也都会了，就里面涉及与cin和cout相似的文件操作不怎么熟，后面的章节有对cin和cout的详细描述，那就后面再看吧，也跳过跳过</p><h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><ol><li>要分清楚不同的参数传递方法，例如形参，引用参数，指针参数</li><li>在c++中，当且仅当用于函数头或函数原型时，<code>int* x</code>和<code>int x[]</code>的含义是相同的</li><li><code>const</code>与指针的联合使用，看下述代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* x;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> y;<br></code></pre></td></tr></table></figure>第一个声明中的const用来防止修改x指向的数据，也就是<code>*x</code>的值无法修改，但是可以直接改变x的值，也就是可以<code>x = &amp;z</code>；<br>第二个声明中的const用来防止修改y本身，也就是<code>y = &amp;z</code>不被允许，但是可以进行<code>*y</code>；</li><li>函数的参数是二维数组时，应该如何写函数原型：<ul><li>已知列数、已知行数：void func(int arr[3][4]);</li><li>已知列数、行数不确定：void func(int (*arr)[4]);</li><li>行数和列数都不确定：void func(int** arr, int rows, int cols);</li><li>使用 std::vector（推荐方法）：void func(std::vector&lt;std::vector<int>&gt;&amp; arr);</li></ul></li><li>函数指针的一些声明：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;     <span class="hljs-comment">//声明了一个函数pf，接收参数类型为int，返回一个double数据</span><br><span class="hljs-function"><span class="hljs-type">double</span>* <span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;       <span class="hljs-comment">//声明了一个函数pf，接收参数类型为int，返回一个double*数据</span><br><span class="hljs-built_in">double</span> (*pf)(<span class="hljs-type">int</span>);      <span class="hljs-comment">//声明了一个函数指针pf，该函数指针pf指向的函数是一个接收参数类型为int，返回一个double数据的函数</span><br><span class="hljs-type">double</span>* (*pf)(<span class="hljs-type">int</span>);     <span class="hljs-comment">//声明了一个函数指针pf，该函数指针pf指向的函数是一个接收参数类型为int，返回一个double*数据的函数</span><br><br><span class="hljs-comment">//假设有多个函数声明，都是接收参数类型为int，返回一个double数据，一共有f1，f2，f3三个函数声明</span><br><span class="hljs-type">double</span>* *(*pa[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>) = &#123;f1, f2, f3&#125;;      <span class="hljs-comment">//定义了一个函数指针数组pa，数组有三个元素，分别是三个函数f1f2f3</span><br><span class="hljs-type">double</span>* *(*(*pa)[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>) = &#123;f1, f2, f3&#125;;   <span class="hljs-comment">//定义了一个函数指针数组指针pa，指针指向的数组有三个元素，分别是三个函数f1f2f3</span><br><br><span class="hljs-comment">//上述定义太麻烦了，利用typedef或者c++11的auto更好</span><br><span class="hljs-keyword">auto</span> pc = &amp;pa;      <span class="hljs-comment">//pc的值设为了pa的地址，也就是pc是个指针，指向pa</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span>* (*pf)(<span class="hljs-type">int</span>);<br>pf pa[<span class="hljs-number">3</span>] = &#123;f1, f2, f3&#125;;<br><span class="hljs-built_in">pf</span> (*pd)[<span class="hljs-number">3</span>] = &amp;pa;      <span class="hljs-comment">//和上述是一样的效果，但是代码更简单</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“C++ Primer Plus” 前言</title>
    <link href="/2025/01/09/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E5%89%8D%E8%A8%80/"/>
    <url>/2025/01/09/%E2%80%9CC++%20Primer%20Plus%E2%80%9D%20%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>大一就买的这本传世经典C++，当初草草的看了几页就没看了</p><p>不过当初也不可能看完，接触的代码、语言太少，看得慢的同时理解也不够深</p><p>现在已经有了比较多的C、C++编写经验，决定开始看这本书</p><p>前面六七章会快速过一遍，只记录自己遗漏的一些知识，因为很多都已经会了</p><p>重点学习c++本身的特性，面向对象，继承，多态，C++11等，以及c++和c的区别</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第十三章 硬盘驱动</title>
    <link href="/2025/01/08/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    <url>/2025/01/08/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="13-1-硬盘及分区表"><a href="#13-1-硬盘及分区表" class="headerlink" title="13.1 硬盘及分区表"></a>13.1 硬盘及分区表</h2><p>我们在加载最开始的boot.bin的时候，就已经创建了一个硬盘，用于当做系统的启动盘，此后我们的代码都是通过dd命令复制到这个硬盘上，从而正式引导操作系统的启动。</p><p>BIOS会在内存的物理地址0x475处存储主机上安装的硬盘数量，在目前的系统上利用bochs执行<code>xp/b 0x475</code>可以看到硬盘数量为0x01</p><p>利用bochs下的bximage命令，创建一个新的硬盘共80MB，CHS&#x3D;162&#x2F;16&#x2F;63，也就是柱面数162，磁头数16，每个磁道扇区数63，要同时在bochsrc里修改从盘的配置文件，我们将之后的文件系统安装到新的硬盘（从盘）上</p><p>文件系统：运行在操作系统中的软件模块，是操作系统提供的一套管理磁盘文件读写的方法和数据组织、存储形式。管理的对象是文件，管理的范围是分区，因此它建立在分区的基础上，每个分区都可以有不同的文件系统。</p><p>硬盘的分区，面，磁道，扇区：</p><ol><li>分区，从实质上说就是对硬盘的一种格式化，抽象地看，分区类似一个面按照不同的同心圆划分出来的不同区域。</li><li>面，硬盘是由一个或多个圆形薄膜叠加而成的，每个薄膜都有两个面，每个面都可以用来存储数据。每个面由一个专有的读写磁头。</li><li>磁道，在面上的圆周叫做磁道，现在一个面可以有多达50w个磁道，由于磁盘是旋转的，则连续写入的数据是排列在一个圆周上的。各面上磁道号相同的磁道合起来，称为一个柱面(Cylinder)。磁道从外侧计数，所以一般情况下C盘的读写速度最快。</li><li>扇区，一个磁道上可以容纳数KB的数据，而主机读写时往往并不需要一次读写那么多，于是，磁道又被划分成若干段，每段称为一个扇区。一个扇区一般存放512字节的数据。计算机对硬盘的读写，是以扇区为基本单位的。最小读取1个，最多读取256个。 一般一个磁道都被划分为63个扇区，柱面数（磁道数）和磁头数（盘片面数）都取决于实际配置</li></ol><p>因此，硬盘容量&#x3D;每磁道扇区数 * 柱面数 * 磁道数 * 512字节</p><p>重新回顾一下MBR，主引导扇区占512字节，其中前446字节是一些引导信息和硬盘参数，然后是64字节为分区表，最后是2字节的魔数0x55aa，分区表中每个表项相当于分区的描述符，占16字节，因此原则上只能有4个分区。<br>一块硬盘，最开始只能实现4个分区，也就是4个主分区。<br>后来的发展，4个分区不够用了，可以有一个分区作为扩展分区，用它来作为总扩展分区，里面可以分成很多个子扩展分区，每个子扩展分区在逻辑上看相当于一块硬盘。</p><h3 id="13-1-1-利用fdisk命令开始分区"><a href="#13-1-1-利用fdisk命令开始分区" class="headerlink" title="13.1.1 利用fdisk命令开始分区"></a>13.1.1 利用fdisk命令开始分区</h3><ol><li><code>fdisk -l ./slave.img</code>查看当前硬盘的分区表数据<br><img src="/../img/13.1.png"><br>可以发现此时分区表是空的，没有别的信息</li><li>利用fdisk开始分区<br><img src="/../img/13.2.png"></li><li>最终分区结果如下图：<br><img src="/../img/13.3.png"></li></ol><h3 id="13-1-2-磁盘分区表浅析"><a href="#13-1-2-磁盘分区表浅析" class="headerlink" title="13.1.2 磁盘分区表浅析"></a>13.1.2 磁盘分区表浅析</h3><p>磁盘分区表简称DPT，长度为64字节，本质上就是个长度为4的数组，数组元素为16字节</p><p>一块硬盘最开始的一个扇区作为MBR,MBR 的 512 字节包括 464 字节+ 64 字节的分区表 + 2 字节的魔数0x55aa。</p><p>接下来就是各个分区了，各个分区开始的扇区是 OBR， 用来引导操作系统的。（OS Boot Record）</p><p>在扩展分区里，每个子扩展分区在逻辑上看相当于一块硬盘。所以刚开始的一个扇区是MBR,但是要和真正的MBR区分，就叫做 EBR。</p><p>EBR 里有446字节 + 64 字节的分区表 + 2 字节魔数，分区表又指向逻辑分区。</p><p>理论上讲，总扩展分区可以扩展无限个子扩展分区，EBR 中的 64 字节的分区表，有 4 个分区表项，但是只用了 2 个，第一个用于指向逻辑分区，第二个用于链接下一个子扩展分区。（用链表的形式链接）<br><img src="/../img/13.4.png" title="MBR OBR EBR的关系"><br><img src="/../img/13.5.png" title="分区表结构"><br>根据分区表的结构，我们将slave.img的主引导扇区中的分区表打印出来：<br><img src="/../img/13.6.png" title="slave.img的主引导扇区MBR中的分区表"><br>可以看到，由于我们之前只设置了两个分区，分别是主分区1，以及分区4作为总扩展分区，因此只有前16字节和后16字节是有数据的<br>混乱的时候，可以重点看一下图：<strong>MBR OBR EBR的关系</strong></p><h2 id="13-2-硬盘驱动程序"><a href="#13-2-硬盘驱动程序" class="headerlink" title="13.2 硬盘驱动程序"></a>13.2 硬盘驱动程序</h2><p>驱动程序是让计算机和硬件通信的特殊程序，是对硬件接口的一种封装<br>硬盘上有两个ata通道，也称为IDE通道，第一个ata通道上的两个硬盘（主&#x2F;从）的中断信号挂在8259A从片上的IRQ14上，第二个ata通道上的两个硬盘（主&#x2F;从）的中断信号挂在8259A从片上的IRQ15上；而8259A从片是挂载在8259A主片上的IRQ2上的，因此在屏蔽中断寄存器中需要把IRQ2打开</p><p>interrupt.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*初始化8259A可编程中断控制器PIC*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">pic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-comment">/*初始化主片*/</span><br>   outb (PIC_M_CTRL, <span class="hljs-number">0x11</span>);   <span class="hljs-comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x20</span>);   <span class="hljs-comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x04</span>);   <span class="hljs-comment">// ICW3: IR2接从片. </span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x01</span>);   <span class="hljs-comment">// ICW4: 8086模式, 正常EOI</span><br><br>   <span class="hljs-comment">/* 初始化从片 */</span><br>   outb (PIC_S_CTRL, <span class="hljs-number">0x11</span>);    <span class="hljs-comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x28</span>);    <span class="hljs-comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x02</span>);    <span class="hljs-comment">// ICW3: 设置从片连接到主片的IR2引脚</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x01</span>);    <span class="hljs-comment">// ICW4: 8086模式, 正常EOI</span><br>   <br>   <span class="hljs-comment">/*开了键盘中断和定时器中断和IRQ2从片*/</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0xf8</span>);<br>   outb (PIC_S_DATA, <span class="hljs-number">0xbf</span>);<br><br>   put_str(<span class="hljs-string">&quot;pic_init done\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-2-1-前置函数的补充"><a href="#13-2-1-前置函数的补充" class="headerlink" title="13.2.1 前置函数的补充"></a>13.2.1 前置函数的补充</h3><p>用户态下我们实现了printf函数方便打印，函数里面本质是调用了系统调用write和格式化逻辑vsprintf，因此我们可以编写printk函数在内核态下完成打印，因为在内核态，所以不需要通过中断进行系统调用，实现更简单<br>stdio-kernel.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">printk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span><br>&#123;<br>    va_list args;<br>    va_start(args,format);<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">vsprintf</span>(buf,format,args);<br>    va_end(args);<br>    console_put_str(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>一直以来我们的系统都有个小bug，即线程调度时的准备队列如果是空的，就会直接触发ASSERT导致系统悬停，因此需要加一个休眠线程idle，当队列为空时，该线程则启动；同时补充线程yield功能，让线程具有主动放弃CPU的能力<br>在thread.c补充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">idle_thread</span>;</span>  <span class="hljs-comment">//休眠线程的PCB</span><br><br><span class="hljs-comment">/*系统空闲时运行的线程*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">idle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>    thread_block(TASK_BLOCKED);<span class="hljs-comment">//先阻塞后 被唤醒之后即通过命令hlt 使cpu挂起 直到外部中断cpu恢复</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;sti;hlt&quot;</span> : : :<span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*实现任务调度:将当前线程换下处理器，并在就绪队列中找到下一个可运行的线程，放上处理器*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span>(list_empty(&amp;thread_ready_list))  thread_unblock(idle_thread);<br>    ...<br>    process_activate(next);<br>    switch_to(cur, next);<br>&#125;<br><br><span class="hljs-comment">/*初始化线程环境*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    put_str(<span class="hljs-string">&quot;thread_init start\n&quot;</span>);<br>    list_init(&amp;thread_ready_list);<br>    list_init(&amp;thread_all_list);<br>    lock_init(&amp;pid_lock);<br>    make_main_thread();<br>    idle_thread = thread_start(<span class="hljs-string">&quot;idle&quot;</span>,<span class="hljs-number">10</span>,idle,<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//创建休眠进程</span><br>    put_str(<span class="hljs-string">&quot;thread_init done\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*主动让出cpu，换其他线程运行*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur</span> =</span> running_thread();<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();<br>    ASSERT(!elem_find(&amp;thread_ready_list,&amp;cur-&gt;general_tag));<br>    list_append(&amp;thread_ready_list,&amp;cur-&gt;general_tag);<span class="hljs-comment">//放到就绪队列末尾</span><br>    cur-&gt;status = TASK_READY;<span class="hljs-comment">//状态设置为READY 可被调度</span><br>    schedule();<br>    intr_set_status(old_status);<br>&#125;<br></code></pre></td></tr></table></figure><p>在线程环境初始化时，idle线程就会被创建并加入到准备队列中，因此idle线程会被调度执行一次，然后在自己的执行过程中阻塞自己让出cpu；当系统运行到线程调度发现准备队列为空时，则解除idle线程的阻塞，然后idle线程会继续执行自己的代码，通过<code>asm volatile (&quot;sti;hlt&quot; : : :&quot;memory&quot;);</code>主要是hlt命令使系统挂起，达到真正空闲，此时处理器只能被外部中断唤醒。</p><p>下面实现一个简单的休眠函数，在timer.c中补充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*休息n个时间中断期*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ticks_to_sleep</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> sleep_ticks)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> start_tick = ticks;<br>    <span class="hljs-keyword">while</span>(ticks - start_tick &lt; sleep_ticks)<br>    thread_yield();<br>&#125;<br><br><span class="hljs-comment">/*毫秒为单位 通过毫秒的中断数来调用ticks_to_sleep 来达到休息毫秒的作用*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mtime_sleep</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> m_seconds)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> sleep_ticks = DIV_ROUND_UP(m_seconds,mil_second_per_init);<br>    ASSERT(sleep_ticks &gt; <span class="hljs-number">0</span>);<br>    ticks_to_sleep(sleep_ticks);<br>&#125;<br></code></pre></td></tr></table></figure><p>参考硬盘控制器的主要端口寄存器</p><table><thead><tr><th><strong>IO端口</strong></th><th><strong>端口用途</strong></th><th><strong>Primary通道</strong></th><th><strong>Secondary通道</strong></th><th><strong>读操作时</strong></th><th><strong>写操作时</strong></th></tr></thead><tbody><tr><td>0x1f0</td><td>Data</td><td>0x1f0</td><td>0x170</td><td>Data</td><td>Data</td></tr><tr><td>0x1f1</td><td>Error</td><td>0x1f1</td><td>0x171</td><td>Error</td><td>Features</td></tr><tr><td>0x1f2</td><td>Sector count</td><td>0x1f2</td><td>0x172</td><td>Sector count</td><td>Sector count</td></tr><tr><td>0x1f3</td><td>LBA low</td><td>0x1f3</td><td>0x173</td><td>LBA low</td><td>LBA low</td></tr><tr><td>0x1f4</td><td>LBA mid</td><td>0x1f4</td><td>0x174</td><td>LBA mid</td><td>LBA mid</td></tr><tr><td>0x1f5</td><td>LBA high</td><td>0x1f5</td><td>0x175</td><td>LBA high</td><td>LBA high</td></tr><tr><td>0x1f6</td><td>Device</td><td>0x1f6</td><td>0x176</td><td>Device</td><td>Device</td></tr><tr><td>0x1f7</td><td>Status</td><td>0x1f7</td><td>0x177</td><td>Status</td><td>Command</td></tr><tr><td>0x3f6</td><td>Alternate status</td><td>0x3f6</td><td>0x376</td><td>Alternate status</td><td>Device Control</td></tr></tbody></table><p>接下来在ide.c 和 ide.h正式开始写硬盘驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ide.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio-kernel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sync.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;io.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;timer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memory.h&quot;</span></span><br><br><span class="hljs-comment">/*根据通道端口的基址，通过相对位置定义硬盘各寄存器的端口号*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_data(channel)   (channel-&gt;port_base + 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_error(channel)   (channel-&gt;port_base + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_sect_cnt(channel)    (channel-&gt;port_base + 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_lba_l(channel)  (channel-&gt;port_base + 3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_lba_m(channel)  (channel-&gt;port_base + 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_lba_h(channel)  (channel-&gt;port_base + 5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_dev(channel)  (channel-&gt;port_base + 6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_status(channel)  (channel-&gt;port_base + 7)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_cmd(channel)  (reg_status(channel))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_alt_status(channel)  (channel-&gt;port_base + 0x206)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> reg_ctl(channel)  reg_alt_status(channel)</span><br><br><span class="hljs-comment">/*控制块寄存器中的关键位*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_STAT_BSY    0X80<span class="hljs-comment">//硬盘忙</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_STAT_DRDY    0X40<span class="hljs-comment">//驱动器准备好啦</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_STAT_DRQ     0x8<span class="hljs-comment">//数据传输准备好了</span></span><br><span class="hljs-comment">/*device寄存器的一些关键位*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_DEV_MBS  0XA0<span class="hljs-comment">//MBS标志位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_DEV_LBA  0X40      <span class="hljs-comment">//标记是否开启LBA模式</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_DEV_DEV  0X10      <span class="hljs-comment">//标记区分主盘还是从盘</span></span><br><br><span class="hljs-comment">/*一些硬盘操作指令*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_IDENTIFY  0XEC<span class="hljs-comment">//identify指令</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_READ_SECTOR  0X20<span class="hljs-comment">//读扇区指令</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMD_WRITE_SECTOR  0X30<span class="hljs-comment">//写扇区指令</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max_lba  ((80*1024*1024/512) - 1) <span class="hljs-comment">//调试用，定义可读写的最大扇区数</span></span><br><br><span class="hljs-type">uint8_t</span> channel_cnt;  <span class="hljs-comment">//通道数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ide_channel</span> <span class="hljs-title">channels</span>[2];</span>  <span class="hljs-comment">//两个ide通道</span><br><br><span class="hljs-type">int32_t</span> ext_lba_base = <span class="hljs-number">0</span>;  <span class="hljs-comment">//记录总拓展分区lba 初始为0</span><br><span class="hljs-type">uint8_t</span> p_no = <span class="hljs-number">0</span>,l_no = <span class="hljs-number">0</span>;  <span class="hljs-comment">//记录硬盘主分区下标 逻辑分区下标</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">partition_list</span>;</span>  <span class="hljs-comment">//分区队列</span><br><br><span class="hljs-comment">//选择读写的硬盘</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">select_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> reg_device = BIT_DEV_MBS | BIT_DEV_LBA;<br>    <span class="hljs-keyword">if</span>(hd-&gt;dev_no == <span class="hljs-number">1</span>)    <span class="hljs-comment">//主盘0 从盘1</span><br>    reg_device |= BIT_DEV_DEV;<br>    outb(reg_dev(hd-&gt;my_channel),reg_device);<br>&#125;<br><br><span class="hljs-comment">//向硬盘控制器写入起始扇区和读写的扇区数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">select_sector</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> lba,<span class="hljs-type">uint8_t</span> sec_cnt)</span><br>&#123;<br>    ASSERT(lba &lt;= max_lba);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ide_channel</span>* <span class="hljs-title">channel</span> =</span> hd-&gt;my_channel;<br>    <br>    outb(reg_sect_cnt(channel),sec_cnt);<br>    outb(reg_lba_l(channel),lba);<br>    outb(reg_lba_m(channel),lba&gt;&gt;<span class="hljs-number">8</span>);<br>    outb(reg_lba_h(channel),lba&gt;&gt;<span class="hljs-number">16</span>);<br>    <br>    outb(reg_dev(channel),BIT_DEV_MBS | BIT_DEV_LBA | (hd-&gt;dev_no == <span class="hljs-number">1</span> ? BIT_DEV_DEV : <span class="hljs-number">0</span>) | lba &gt;&gt; <span class="hljs-number">24</span>);<br>&#125;<br><br><span class="hljs-comment">//向通道channel发命令cmd</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cmd_out</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ide_channel* channel,<span class="hljs-type">uint8_t</span> cmd)</span><br>&#123;<br>    channel-&gt;expecting_intr = <span class="hljs-literal">true</span>;<br>    outb(reg_cmd(channel),cmd);<br>&#125;<br><br><span class="hljs-comment">//从扇区读数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">read_from_sector</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint8_t</span> sec_cnt)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> size_in_byte;<br>    <span class="hljs-keyword">if</span>(sec_cnt == <span class="hljs-number">0</span>)<br>    size_in_byte = <span class="hljs-number">256</span>*<span class="hljs-number">512</span>;<br>    <span class="hljs-keyword">else</span><br>    size_in_byte = sec_cnt*<span class="hljs-number">512</span>;<br>    insw(reg_data(hd-&gt;my_channel),buf,size_in_byte/<span class="hljs-number">2</span>);<span class="hljs-comment">//读如数据到buf</span><br>&#125;<br><br><span class="hljs-comment">//将 sec_cnt 扇区数据写入硬盘</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write2sector</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint8_t</span> sec_cnt)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> size_in_byte;<br>    <span class="hljs-keyword">if</span>(sec_cnt == <span class="hljs-number">0</span>)size_in_byte = <span class="hljs-number">256</span>*<span class="hljs-number">512</span>;<br>    <span class="hljs-keyword">else</span>size_in_byte = sec_cnt * <span class="hljs-number">512</span>;<br>    outsw(reg_data(hd-&gt;my_channel),buf,size_in_byte/<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">//最多等待三十秒 任务应该都在30秒内完成  读取硬盘相应给了整整30秒</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">busy_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ide_channel</span>* <span class="hljs-title">channel</span> =</span> hd-&gt;my_channel;<br>    <span class="hljs-type">uint16_t</span> time_limit = <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">while</span>(time_limit -= <span class="hljs-number">10</span> &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(!(inb(reg_status(channel)) &amp; BIT_STAT_BSY))<br>        <span class="hljs-keyword">return</span> (inb(reg_status(channel)) &amp; BIT_STAT_DRQ);<br>    <span class="hljs-keyword">else</span>  mtime_sleep(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//从硬盘读取sec_cnt扇区到buf</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ide_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> lba,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint32_t</span> sec_cnt)</span><br>&#123;<br>    ASSERT(lba &lt;= max_lba);<br>    ASSERT(sec_cnt &gt; <span class="hljs-number">0</span>);<br>    lock_acquire(&amp;hd-&gt;my_channel-&gt;lock);<br>    <br>    select_disk(hd);<br>    <br>    <span class="hljs-type">uint32_t</span> secs_op;<br>    <span class="hljs-type">uint32_t</span> secs_done = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(secs_done &lt; sec_cnt)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((secs_done + <span class="hljs-number">256</span>) &lt;= sec_cnt)    secs_op = <span class="hljs-number">256</span>;<br>        <span class="hljs-keyword">else</span>secs_op = sec_cnt - secs_done;<br>    <br>        select_sector(hd,lba + secs_done, secs_op);<br>        cmd_out(hd-&gt;my_channel,CMD_READ_SECTOR); <span class="hljs-comment">//执行命令</span><br>        <br>        <span class="hljs-comment">/*在硬盘开始工作时 阻塞自己 完成读操作后唤醒自己*/</span><br>        sema_down(&amp;hd-&gt;my_channel-&gt;disk_done);<br>        <br>        <span class="hljs-comment">/*检测是否可读*/</span><br>        <span class="hljs-keyword">if</span>(!busy_wait(hd))<br>        &#123;<br>            <span class="hljs-type">char</span> error[<span class="hljs-number">64</span>];<br>            <span class="hljs-built_in">sprintf</span>(error,<span class="hljs-string">&quot;%s read sector %d failed!!!!\n&quot;</span>,hd-&gt;name,lba);<br>            PANIC(error);<br>        &#125;<br>        <br>      read_from_sector(hd,(<span class="hljs-type">void</span>*)((<span class="hljs-type">uint32_t</span>)buf +secs_done * <span class="hljs-number">512</span>),secs_op);<br>      secs_done += secs_op;<br>    &#125;<br>    lock_release(&amp;hd-&gt;my_channel-&gt;lock);   <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ide_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> lba,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint32_t</span> sec_cnt)</span><br>&#123;<br>    ASSERT(lba &lt;= max_lba);<br>    ASSERT(sec_cnt &gt; <span class="hljs-number">0</span>);<br>    lock_acquire(&amp;hd-&gt;my_channel-&gt;lock);<br>    <br>    select_disk(hd);<br>    <span class="hljs-type">uint32_t</span> secs_op;<br>    <span class="hljs-type">uint32_t</span> secs_done = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(secs_done &lt; sec_cnt)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((secs_done + <span class="hljs-number">256</span>) &lt;= sec_cnt)    secs_op = <span class="hljs-number">256</span>;<br>        <span class="hljs-keyword">else</span>secs_op = sec_cnt - secs_done;<br>        <br>    select_sector(hd,lba+secs_done,secs_op);<br>    cmd_out(hd-&gt;my_channel,CMD_WRITE_SECTOR);<br>    <br>    <span class="hljs-keyword">if</span>(!busy_wait(hd))<br>    &#123;<br>        <span class="hljs-type">char</span> error[<span class="hljs-number">64</span>];<br>        <span class="hljs-built_in">sprintf</span>(error,<span class="hljs-string">&quot;%s write sector %d failed!!!!!!\n&quot;</span>,hd-&gt;name,lba);<br>        PANIC(error);<br>    &#125;<br>    <br>    write2sector(hd,(<span class="hljs-type">void</span>*)((<span class="hljs-type">uint32_t</span>)buf + secs_done * <span class="hljs-number">512</span>),secs_op);<br>    <br>    <span class="hljs-comment">//硬盘响应期间阻塞</span><br>    sema_down(&amp;hd-&gt;my_channel-&gt;disk_done);<br>    secs_done += secs_op;<br>    &#125;<br>    lock_release(&amp;hd-&gt;my_channel-&gt;lock);<br>&#125;<br><br><span class="hljs-comment">//硬盘结束任务中断程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">intr_hd_handler</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> irq_no)</span><br>&#123;<br>    ASSERT(irq_no == <span class="hljs-number">0x2e</span> || irq_no == <span class="hljs-number">0x2f</span>);<br>    <span class="hljs-type">uint8_t</span> ch_no = irq_no - <span class="hljs-number">0x20</span> - <span class="hljs-number">0xe</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ide_channel</span>* <span class="hljs-title">channel</span> =</span> &amp;channels[ch_no];<br>    ASSERT(channel-&gt;irq_no == irq_no);<br>    <span class="hljs-keyword">if</span>(channel-&gt;expecting_intr)<br>    &#123;<br>channel-&gt;expecting_intr = <span class="hljs-literal">false</span>;<span class="hljs-comment">//结束任务了</span><br>sema_up(&amp;channel-&gt;disk_done);<br>inb(reg_status(channel));<br>    &#125;   <br>&#125;<br><br><span class="hljs-comment">//将dst中len个相邻字节交换位置存入buf 因为读入的时候字节顺序是反的 所以我们再反一次即可</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap_pairs_bytes</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dst,<span class="hljs-type">char</span>* buf,<span class="hljs-type">uint32_t</span> len)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> idx;<br>    <span class="hljs-keyword">for</span>(idx = <span class="hljs-number">0</span>;idx &lt; len;idx += <span class="hljs-number">2</span>)<br>    &#123;<br>    buf[idx+<span class="hljs-number">1</span>] = *(dst++);<br>    buf[idx]   = *(dst++);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">partition_scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> ext_lba)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_sector</span>* <span class="hljs-title">bs</span> =</span> sys_malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> boot_sector));<br>    ide_read(hd,ext_lba,bs,<span class="hljs-number">1</span>);<br>    <span class="hljs-type">uint8_t</span> part_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition_table_entry</span>* <span class="hljs-title">p</span> =</span> bs-&gt;partition_table; <span class="hljs-comment">//p为分区表开始的位置</span><br>    <span class="hljs-keyword">while</span>((part_idx++) &lt; <span class="hljs-number">4</span>)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;fs_type == <span class="hljs-number">0x5</span>) <span class="hljs-comment">//拓展分区</span><br>    &#123;<br>        <br>        <span class="hljs-keyword">if</span>(ext_lba_base != <span class="hljs-number">0</span>)<br>        &#123;<br>        partition_scan(hd,p-&gt;start_lba + ext_lba_base);<span class="hljs-comment">//继续递归转到下一个逻辑分区再次得到表</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//第一次读取引导块</span><br>        &#123;<br>        ext_lba_base = p-&gt;start_lba;<br>        partition_scan(hd,ext_lba_base);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;fs_type != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ext_lba == <span class="hljs-number">0</span>)<span class="hljs-comment">//主分区</span><br>        &#123;<br>        hd-&gt;prim_parts[p_no].start_lba = ext_lba + p-&gt;start_lba;<br>        hd-&gt;prim_parts[p_no].sec_cnt = p-&gt;sec_cnt;<br>        hd-&gt;prim_parts[p_no].my_disk = hd;<br>        list_append(&amp;partition_list,&amp;hd-&gt;prim_parts[p_no].part_tag);<br>        <span class="hljs-built_in">sprintf</span>(hd-&gt;prim_parts[p_no].name,<span class="hljs-string">&quot;%s%d&quot;</span>,hd-&gt;name,p_no+<span class="hljs-number">1</span>);<br>        p_no++;<br>        ASSERT(p_no&lt;<span class="hljs-number">4</span>);<span class="hljs-comment">//0 1 2 3 最多四个</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//其他分区</span><br>        &#123;<br>        hd-&gt;logic_parts[l_no].start_lba = ext_lba + p-&gt;start_lba;<br>        hd-&gt;logic_parts[l_no].sec_cnt = p-&gt;sec_cnt;<br>        hd-&gt;logic_parts[l_no].my_disk = hd;<br>        list_append(&amp;partition_list,&amp;hd-&gt;logic_parts[l_no].part_tag);<br>        <span class="hljs-built_in">sprintf</span>(hd-&gt;logic_parts[l_no].name,<span class="hljs-string">&quot;%s%d&quot;</span>,hd-&gt;name,l_no+<span class="hljs-number">5</span>); <span class="hljs-comment">//从5开始</span><br>        l_no++;<br>        <span class="hljs-keyword">if</span>(l_no &gt;= <span class="hljs-number">8</span>)<span class="hljs-keyword">return</span>; <span class="hljs-comment">//只支持8个</span><br>        &#125;<br>    &#125;<br>    ++p;<br>    &#125;<br>    sys_free(bs);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">partition_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_elem* pelem,<span class="hljs-type">int</span> arg)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span>* <span class="hljs-title">part</span> =</span> elem2entry(<span class="hljs-keyword">struct</span> partition,part_tag,pelem);<br>    printk(<span class="hljs-string">&quot;    %s  start_lba:0x%x,sec_cnt:0x%x\n&quot;</span>,part-&gt;name,part-&gt;start_lba,part-&gt;sec_cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//list_pop完</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">identify_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd)</span><br>&#123;<br>    <span class="hljs-type">char</span> id_info[<span class="hljs-number">512</span>];<br>    select_disk(hd);<br>    cmd_out(hd-&gt;my_channel,CMD_IDENTIFY);<br>    <br>    <span class="hljs-keyword">if</span>(!busy_wait(hd))<br>    &#123;<br>    <span class="hljs-type">char</span> error[<span class="hljs-number">64</span>];<br>    <span class="hljs-built_in">sprintf</span>(error,<span class="hljs-string">&quot;%s identify failed!!!!!!\n&quot;</span>);<br>    PANIC(error);<br>    &#125;<br>    read_from_sector(hd,id_info,<span class="hljs-number">1</span>);<span class="hljs-comment">//现在硬盘已经把硬盘的参数准备好了了 我们把参数读到自己的缓冲区中</span><br>    <br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">uint8_t</span> sn_start = <span class="hljs-number">10</span> * <span class="hljs-number">2</span>,sn_len = <span class="hljs-number">20</span>,md_start = <span class="hljs-number">27</span>*<span class="hljs-number">2</span>,md_len = <span class="hljs-number">40</span>;<br>    swap_pairs_bytes(&amp;id_info[sn_start],buf,sn_len);<br>    printk(<span class="hljs-string">&quot;    disk %s info:        SN: %s\n&quot;</span>,hd-&gt;name,buf);<br>    swap_pairs_bytes(&amp;id_info[md_start],buf,md_len);<br>    printk(<span class="hljs-string">&quot;    MODULE: %s\n&quot;</span>,buf);<br>    <span class="hljs-type">uint32_t</span> sectors = *(<span class="hljs-type">uint32_t</span>*)&amp;id_info[<span class="hljs-number">60</span>*<span class="hljs-number">2</span>];<br>    printk(<span class="hljs-string">&quot;    SECTORS: %d\n&quot;</span>,sectors);<br>    printk(<span class="hljs-string">&quot;    CAPACITY: %dMB\n&quot;</span>,sectors * <span class="hljs-number">512</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>);<br>&#125; <br><br><br><br><span class="hljs-comment">//初始化硬盘数据</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ide_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;ide_init start\n&quot;</span>);<br>    <span class="hljs-type">uint8_t</span> hd_cnt = *((<span class="hljs-type">uint8_t</span>*)(<span class="hljs-number">0x475</span>));     <span class="hljs-comment">//获取硬盘数量</span><br>    ASSERT(hd_cnt &gt; <span class="hljs-number">0</span>);<br>    channel_cnt = DIV_ROUND_UP(hd_cnt,<span class="hljs-number">2</span>);      <span class="hljs-comment">//两个硬盘对应一个ide 通过硬盘推ide</span><br>    ASSERT(channel_cnt &gt; <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ide_channel</span>* <span class="hljs-title">channel</span>;</span><br>    <span class="hljs-type">uint8_t</span> channel_no = <span class="hljs-number">0</span>,dev_no = <span class="hljs-number">0</span>;<br>    list_init(&amp;partition_list);<br>    <br>    <span class="hljs-comment">/*处理每个通道上的硬盘*/</span><br>    <span class="hljs-keyword">while</span>(channel_no &lt; channel_cnt)<br>    &#123;<br>    channel = &amp;channels[channel_no];<br>    <span class="hljs-built_in">sprintf</span>(channel-&gt;name,<span class="hljs-string">&quot;ide%d&quot;</span>,channel_no);<br>    <br>        <span class="hljs-comment">/*为每个通道初始化端口基址和中断向量*/</span><br>    <span class="hljs-keyword">switch</span>(channel_no)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    channel-&gt;port_base = <span class="hljs-number">0x1f0</span>;<span class="hljs-comment">//ide0 起始端口号0x1f0</span><br>    channel-&gt;irq_no    = <span class="hljs-number">0x2e</span>;<span class="hljs-comment">//8259a 中断引脚</span><br>    <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    channel-&gt;port_base = <span class="hljs-number">0x170</span>;<span class="hljs-comment">//ide1 起始端口号0x170</span><br>    channel-&gt;irq_no    = <span class="hljs-number">0x2f</span>;<br>    <span class="hljs-keyword">break</span>;<br>    &#125;<br>register_handler(channel-&gt;irq_no,intr_hd_handler);<br>    channel-&gt;expecting_intr = <span class="hljs-literal">false</span>;<span class="hljs-comment">//不期待中断</span><br>    lock_init(&amp;channel-&gt;lock);<br>    sema_init(&amp;channel-&gt;disk_done,<span class="hljs-number">0</span>);   <span class="hljs-comment">//初始化该通道为信号量0，即阻塞，直到硬盘完成后通过中断唤醒该线程</span><br>    <br>    <span class="hljs-keyword">while</span>(dev_no &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk</span>* <span class="hljs-title">hd</span> =</span> &amp;channel-&gt;devices[dev_no];<br>        hd-&gt;my_channel = channel;<br>        hd-&gt;dev_no = dev_no;<br>        <span class="hljs-built_in">sprintf</span>(hd-&gt;name,<span class="hljs-string">&quot;sd%c&quot;</span>,<span class="hljs-string">&#x27;a&#x27;</span> + channel_no * <span class="hljs-number">2</span> + dev_no);<br>        identify_disk(hd);<br>        <span class="hljs-keyword">if</span>(dev_no != <span class="hljs-number">0</span>)<br>        partition_scan(hd,<span class="hljs-number">0</span>);<br>        p_no = <span class="hljs-number">0</span>,l_no = <span class="hljs-number">0</span>;<br>        dev_no++;<br>    &#125;<br>    dev_no = <span class="hljs-number">0</span>;<br>    channel_no++;<br>    &#125;<br>    printk(<span class="hljs-string">&quot;\n    all partition info\n&quot;</span>);<br>    list_traversal(&amp;partition_list,partition_info,(<span class="hljs-type">int</span>)<span class="hljs-literal">NULL</span>);<br>    printk(<span class="hljs-string">&quot;ide_init done\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ide.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEVICE_IDE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVICE_IDE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bitmap.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sync.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span></span><br><br><span class="hljs-comment">//分区结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> start_lba;          <span class="hljs-comment">//起始扇区</span><br>    <span class="hljs-type">uint32_t</span> sec_cnt;            <span class="hljs-comment">//扇区数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk</span>* <span class="hljs-title">my_disk</span>;</span>        <span class="hljs-comment">//分区所属硬盘</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">part_tag</span>;</span>   <span class="hljs-comment">//所在队列中的标记</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];                <span class="hljs-comment">//分区名字</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>* <span class="hljs-title">sb</span>;</span>  <span class="hljs-comment">//本分区 超级块</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> <span class="hljs-title">block_bitmap</span>;</span>  <span class="hljs-comment">//块位图</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> <span class="hljs-title">inode_bitmap</span>;</span>  <span class="hljs-comment">//i结点位图</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">open_inodes</span>;</span>     <span class="hljs-comment">//本分区打开</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition_table_entry</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> bootable;  <span class="hljs-comment">//是否可引导</span><br>    <span class="hljs-type">uint8_t</span> start_head;  <span class="hljs-comment">//开始磁头号</span><br>    <span class="hljs-type">uint8_t</span> start_sec;  <span class="hljs-comment">//开始扇区号</span><br>    <span class="hljs-type">uint8_t</span> start_chs;  <span class="hljs-comment">//起始柱面号</span><br>    <span class="hljs-type">uint8_t</span> fs_type;  <span class="hljs-comment">//分区类型</span><br>    <span class="hljs-type">uint8_t</span> end_head;  <span class="hljs-comment">//结束磁头号</span><br>    <span class="hljs-type">uint8_t</span> end_sec;  <span class="hljs-comment">//结束扇区号</span><br>    <span class="hljs-type">uint8_t</span> end_chs;  <span class="hljs-comment">//结束柱面号</span><br>    <span class="hljs-type">uint32_t</span> start_lba;  <span class="hljs-comment">//本分区起始的lba地址</span><br>    <span class="hljs-type">uint32_t</span> sec_cnt;  <span class="hljs-comment">//本扇区数目</span><br>&#125; __attribute__ ((packed));<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">boot_sector</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> other[<span class="hljs-number">446</span>];  <span class="hljs-comment">//446 + 64 + 2 446是拿来占位置的</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition_table_entry</span> <span class="hljs-title">partition_table</span>[4];</span>  <span class="hljs-comment">//分区表中4项 64字节</span><br>    <span class="hljs-type">uint16_t</span> signature;<span class="hljs-comment">//最后的标识标志 魔数0x55 0xaa</span><br>&#125; __attribute__ ((packed));<br><br><span class="hljs-comment">//硬盘</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];      <span class="hljs-comment">//本硬盘的名称</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ide_channel</span>* <span class="hljs-title">my_channel</span>;</span>    <span class="hljs-comment">//这块硬盘归属于哪个ide通道</span><br>    <span class="hljs-type">uint8_t</span> dev_no;      <span class="hljs-comment">//0表示主盘 1表示从盘</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span> <span class="hljs-title">prim_parts</span>[4];</span>  <span class="hljs-comment">//主分区顶多是4个</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span> <span class="hljs-title">logic_parts</span>[8];</span> <span class="hljs-comment">//逻辑分区最多支持8个</span><br>&#125;;<br><br><span class="hljs-comment">// ata 通道结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ide_channel</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];      <span class="hljs-comment">//ata通道名称</span><br>    <span class="hljs-type">uint16_t</span> port_base;      <span class="hljs-comment">//本通道的起始端口号</span><br>    <span class="hljs-type">uint8_t</span>  irq_no;      <span class="hljs-comment">//本通道所用的中断号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">lock</span>;</span>                <span class="hljs-comment">//通道锁 一个硬盘一通道 不能同时</span><br>    <span class="hljs-type">bool</span> expecting_intr;      <span class="hljs-comment">//期待硬盘中断的bool</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">disk_done</span>;</span>      <span class="hljs-comment">//用于阻塞 唤醒驱动程序  和锁不一样 把自己阻塞后 把cpu腾出来</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">disk</span> <span class="hljs-title">devices</span>[2];</span>      <span class="hljs-comment">//一通道2硬盘 1主1从</span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ide_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">select_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">select_sector</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> lba,<span class="hljs-type">uint8_t</span> sec_cnt)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">cmd_out</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ide_channel* channel,<span class="hljs-type">uint8_t</span> cmd)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">read_from_sector</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint8_t</span> sec_cnt)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">write2sector</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint8_t</span> sec_cnt)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">busy_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ide_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> lba,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint32_t</span> sec_cnt)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ide_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> lba,<span class="hljs-type">void</span>* buf,<span class="hljs-type">uint32_t</span> sec_cnt)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">intr_hd_handler</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> irq_no)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap_pairs_bytes</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dst,<span class="hljs-type">char</span>* buf,<span class="hljs-type">uint32_t</span> len)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">identify_disk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* fd)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">partition_scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disk* hd,<span class="hljs-type">uint32_t</span> ext_lba)</span>;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">partition_info</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_elem* pelem,<span class="hljs-type">int</span> arg)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>最后，我们的系统硬盘信息如下：<br><img src="/../img/13.7.png"></p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第十二章 系统调用和堆内存管理</title>
    <link href="/2025/01/06/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <url>/2025/01/06/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="12-1-Linux系统调用浅析"><a href="#12-1-Linux系统调用浅析" class="headerlink" title="12.1 Linux系统调用浅析"></a>12.1 Linux系统调用浅析</h2><p>用户进程有时候也需要一定的能力去完成部分功能，例如在屏幕打印东西，但操作系统不允许用户进程对屏幕进行操作，因此用户进程需要请操作系统帮忙完成这些操作，操作系统会提供不同功能的接口给用户调用，这些接口就是系统调用。</p><p>Linux系统调用是用中断门来实现的，通过软中断int来主动发起中断信号，Linux只使用一个中断向量号即0x80来代表所有系统调用，处理器通过触发int 0x80来触发系统调用，在eax中写入子功能号，中断处理程序通过eax的值来判断用户进程申请哪种系统调用。</p><p>现在C运行库glibc提供了一个间接的系统调用，函数原型是<code>int syscall(int number, ...)</code>，输入的第一个参数是系统调用号，后面的…代表支持可变参数；这种调用形式更灵活，用户可以通过统一的形式直接进行系统调用，是当前版本Linux进行系统调用的主要方式。</p><p>也可以通过_syscall进行直接的系统调用，该函数族由操作系统提供，但如今已经被废弃，因为不够灵活，只能最多支持6个参数<br>我们模仿_syscall先实现简单的系统调用</p><h2 id="12-2-系统调用的实现"><a href="#12-2-系统调用的实现" class="headerlink" title="12.2 系统调用的实现"></a>12.2 系统调用的实现</h2><p>操作系统的系统调用相当于一个接口，接口的一端暴露给用户，属于用户空间，接口的另一端是与之对应的内核实现，属于内核空间。以获取用户进程pid为例，用户通过调用<code>getpid</code>函数返回任务pid，这是属于用户进程使用的接口，接口的另一端对应的内核函数才是关键，该内核函数就是系统调用子功能对应的函数<code>sys_getpid</code>，由它负责找出pid。</p><p>分为4个步骤实现一个系统调用：</p><ol><li>用中断号0x80作为系统调用的入口</li><li>在IDT中安装0x80对应的中断描述符，并注册好对应的中断处理例程</li><li>建立系统调用子功能表syscall_table，利用eax寄存器中的子功能号来索引对应处理函数</li><li>用宏实现用户空间系统调用接口_syscall，我们这里只支持最大3个参数的系统调用，因此只需要完成_syscall[0-3]，eax为子功能号，ebx保存第一个参数，ecx保存第二个参数，edx保存第三个参数</li></ol><p>下面根据上述步骤分别实现<br>增加0x80号中断描述符<br>interrupt.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_CNT 0x81       <span class="hljs-comment">//目前总共支持的中断数</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">syscall_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <span class="hljs-comment">//系统调用对应的中断入口例程</span><br><br><span class="hljs-comment">/*初始化中断描述符表*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">idt_desc_init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> lastindex = IDT_DESC_CNT - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; IDT_DESC_CNT; i++)&#123;<br>        make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);<br>    &#125;<br>    make_idt_desc(&amp;idt[lastindex], IDT_DESC_ATTR_DPL3,syscall_handler);<br>    put_str(<span class="hljs-string">&quot;idt_desc_init done!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意的是，给0x80对应的中断描述符初始化时，要将属性中的dpl设置为用户特权级3，这样触发0x80中断时才不会触发GP异常<br>tips：之前进程线程切换的时候不需要将定时中断的中断描述符设置dpl为3，用户进程也能触发，是因为根本不是由用户代码触发的定时器中断，是由硬件触发的，硬件定时器触发的中断不受进程的特权级限制。无论当前进程是在用户态还是内核态，硬件中断（如时钟中断）都会触发并由操作系统内核进行处理。</p><p>实现系统调用接口<br>模仿旧版Linux过时的系统调用接口_syscall<br>syscall.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall0(NUMBER) (&#123; \</span><br><span class="hljs-meta">    int retval;\</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;int $0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(retval) : <span class="hljs-string">&quot;a&quot;</span>(NUMBER) : <span class="hljs-string">&quot;memory&quot;</span>); retval; \</span><br><span class="hljs-meta">    &#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall1(NUMBER, ARG1) (&#123; \</span><br><span class="hljs-meta">    int retval;\</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;int $0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(retval) : <span class="hljs-string">&quot;a&quot;</span>(NUMBER) , <span class="hljs-string">&quot;b&quot;</span>(ARG1) : <span class="hljs-string">&quot;memory&quot;</span>); retval; \</span><br><span class="hljs-meta">    &#125;)</span><br>    <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall2(NUMBER, ARG1, ARG2) (&#123; \</span><br><span class="hljs-meta">    int retval;\</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;int $0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(retval) : <span class="hljs-string">&quot;a&quot;</span>(NUMBER) , <span class="hljs-string">&quot;b&quot;</span>(ARG1) , <span class="hljs-string">&quot;c&quot;</span>(ARG2): <span class="hljs-string">&quot;memory&quot;</span>); retval; \</span><br><span class="hljs-meta">    &#125;)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _syscall3(NUMBER, ARG1, ARG2, ARG3) (&#123; \</span><br><span class="hljs-meta">    int retval;\</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;int $0x80&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span>(retval) : <span class="hljs-string">&quot;a&quot;</span>(NUMBER) , <span class="hljs-string">&quot;b&quot;</span>(ARG1) , <span class="hljs-string">&quot;c&quot;</span>(ARG2), <span class="hljs-string">&quot;d&quot;</span>(ARG3): <span class="hljs-string">&quot;memory&quot;</span>); retval; \</span><br><span class="hljs-meta">    &#125;)</span><br></code></pre></td></tr></table></figure><p>增加0x80号中断处理例程<br>kernel.S</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">global</span> syscall_handler<br><span class="hljs-symbol">syscall_handler:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-number">0</span>      <span class="hljs-comment">;中断错误码0</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">fs</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">gs</span><br>    <span class="hljs-keyword">pushad</span><br>    <br>    <span class="hljs-keyword">push</span> <span class="hljs-number">0x80</span>     <span class="hljs-comment">; 不管是否需要参数,都一律压入中断向量号,调试时很方便</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span>     <span class="hljs-comment">;第三个参数</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span>     <span class="hljs-comment">;第二个参数</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span>     <span class="hljs-comment">;第一个参数</span><br>    <br>    <span class="hljs-keyword">call</span> [syscall_table + <span class="hljs-built_in">eax</span>*<span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">add</span>  <span class="hljs-built_in">esp</span>,<span class="hljs-number">12</span><br>    <br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span> + <span class="hljs-number">8</span>*<span class="hljs-number">4</span>],<span class="hljs-built_in">eax</span>     <span class="hljs-comment">;返回值给放到eax中 eax前面有 中断号+EDI+ESI+EBP+ESP+EBX+EDX+ECX </span><br>    <span class="hljs-keyword">jmp</span> intr_exit<br></code></pre></td></tr></table></figure><p>触发0x80中断时，系统现在idt中找到0x80对应的中断描述符，再根据中断描述符找到系统调用对应的中断例程syscall_handler，然后执行这段函数，根据传入的系统调用号对应系统调用表找到对应函数的入口执行。</p><p>初始化系统调用<br>syscall-init.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> syscall_nr 32</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* syscall;<br>syscall syscall_table[syscall_nr];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscall_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    put_str(<span class="hljs-string">&quot;syscall_init start\n&quot;</span>);<br>    syscall_table[SYS_GETPID] = sys_getpid;<br>    syscall_table[SYS_WRITE] = sys_write;<br>    syscall_table[SYS_MALLOC] = sys_malloc;<br>    syscall_table[SYS_FREE] = sys_free;<br>    put_str(<span class="hljs-string">&quot;syscall_init done\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有了系统调用表syscall_table，在表里面分别存入不同系统调用对应的sys_xxx函数，才算真正完成系统调用的编写。</p><h2 id="12-3-实现系统调用write与可变参数的printf"><a href="#12-3-实现系统调用write与可变参数的printf" class="headerlink" title="12.3 实现系统调用write与可变参数的printf"></a>12.3 实现系统调用write与可变参数的printf</h2><p>gcc编译器提供了三个宏，用来帮助需要可变参数的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_start(ap,v) ap = (va_list)&amp;v          <span class="hljs-comment">//ap指向第一个固定参数v</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_arg(ap,t)   *((t*)(ap +=4))   <span class="hljs-comment">//ap指向下一个参数并返回其值</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_end(ap)ap = NULL           <span class="hljs-comment">//清空ap</span></span><br></code></pre></td></tr></table></figure><p>我们一直使用的printf函数，其实核心在于内部的两个函数：用于格式化的vsprintf函数 和 用于输出到屏幕的write系统调用</p><p>总结一下添加系统调用的三个步骤：</p><ol><li>在syscall.h中添加新的子功能号</li><li>在syscall.c中添加系统调用的用户接口</li><li>在syscall-init.c中添加内核对应的子功能处理函数，并在syscall_table完成注册</li></ol><p>先来实现write系统调用<br>syscall.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SYSCALL_NR</span></span><br><span class="hljs-class">&#123;</span><br>    SYS_GETPID,<br>    SYS_WRITE<br>&#125;;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>;<br></code></pre></td></tr></table></figure><p>syscall.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>    <span class="hljs-keyword">return</span> _syscall1(SYS_WRITE, str);<br>&#125;<br></code></pre></td></tr></table></figure><p>syscall-init.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>&#123;<br>    console_put_str(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(str);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscall_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    put_str(<span class="hljs-string">&quot;syscall_init start\n&quot;</span>);<br>    syscall_table[SYS_GETPID] = sys_getpid;<br>    syscall_table[SYS_WRITE] = sys_write;<br>    put_str(<span class="hljs-string">&quot;syscall_init done\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来完成stdio.c，里面就是关于格式化字符串里的格式化部分，核心函数是vsprintf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_start(ap,v) ap = (va_list)&amp;v          <span class="hljs-comment">//ap指向第一个固定参数v</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_arg(ap,t)   *((t*)(ap +=4))   <span class="hljs-comment">//ap指向下一个参数并返回其值</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> va_end(ap)ap = NULL           <span class="hljs-comment">//清空ap</span></span><br><br><span class="hljs-comment">//将整型转换成字符</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">itoa</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> value,<span class="hljs-type">char</span>** buf_ptr_addr,<span class="hljs-type">uint8_t</span> base)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> m = value % base;<br>    <span class="hljs-type">uint32_t</span> i = value / base;  <span class="hljs-comment">//除数为0即最高位了 输出即可 没到零继续即可</span><br>    <span class="hljs-keyword">if</span>(i)<br>    itoa(i,buf_ptr_addr,base);<br>    <span class="hljs-keyword">if</span>(m &lt; <span class="hljs-number">10</span>)                  <span class="hljs-comment">//m小于10的数</span><br>    *((*buf_ptr_addr)++) = m + <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//m大于10的数</span><br>    *((*buf_ptr_addr)++) = m + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">//将带有格式的format转换为纯字符串str</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">vsprintf</span><span class="hljs-params">(<span class="hljs-type">char</span>* str,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format,va_list ap)</span><br>&#123;<br>    <span class="hljs-type">char</span>* buf_ptr = str;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* index_ptr = format;<br>    <span class="hljs-type">char</span> index_char = *index_ptr;<br>    <span class="hljs-type">int32_t</span> arg_int;<br>    <span class="hljs-type">char</span>* arg_str;<br>    <span class="hljs-keyword">while</span>(index_char)<span class="hljs-comment">//挨个挨个字符来弄</span><br>    &#123;<br>    <span class="hljs-keyword">if</span>(index_char != <span class="hljs-string">&#x27;%&#x27;</span>)<br>    &#123;<br>        *(buf_ptr++) = index_char;<br>        index_char = *(++index_ptr);<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    index_char = *(++index_ptr);<br>    <span class="hljs-keyword">switch</span>(index_char)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>        arg_str = va_arg(ap,<span class="hljs-type">char</span>*);<br>        <span class="hljs-built_in">strcpy</span>(buf_ptr,arg_str);<br>        buf_ptr += <span class="hljs-built_in">strlen</span>(arg_str);<br>        index_char = *(++index_ptr);<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br>        arg_int = va_arg(ap,<span class="hljs-type">int</span>);<br>        itoa(arg_int,&amp;buf_ptr,<span class="hljs-number">16</span>);<br>        index_char = *(++index_ptr);<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>        arg_int = va_arg(ap,<span class="hljs-type">int</span>);<br>        <span class="hljs-keyword">if</span>(arg_int &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            arg_int = <span class="hljs-number">0</span> - arg_int;<br>            *(buf_ptr++) = <span class="hljs-string">&#x27;-&#x27;</span>;<br>        &#125;<br>        itoa(arg_int,&amp;buf_ptr,<span class="hljs-number">10</span>);<br>        index_char = *(++index_ptr);<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>        *(buf_ptr++) = va_arg(ap,<span class="hljs-type">char</span>);<br>        index_char = *(++index_ptr);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(str);<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span><br>&#123;<br>    va_list args;<br>    <span class="hljs-type">uint32_t</span> retval;<br>    va_start(args,format);<span class="hljs-comment">//args指向char* 的指针 方便指向下一个栈参数</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    retval = <span class="hljs-built_in">vsprintf</span>(buf,format,args);<br>    va_end(args);<br>    write(buf);<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="12-4-完善堆内存管理"><a href="#12-4-完善堆内存管理" class="headerlink" title="12.4 完善堆内存管理"></a>12.4 完善堆内存管理</h2><p>之前我们实现的内存分配都是以页为单位的，每次分配的最小内存是4KB，但当我们只需要使用几十字节之类的小内存时，使用之前的方式就没法满足需求了，因此要引入别的内存管理结构</p><p>引入arena，arena是一个提供内存分配的数据结构，分为两个部分，一部分是元信息，另一部分是内存池区域。<br>元数据用来描述自己内存池中空闲块的数量，大约占12字节</p><p>内存池区域包含许多内存块，我们把每个内存块命名为mem_block，它们是内存分配粒度更细的资源，最终给用户分配的就是这么一个内存块mem_block</p><p>每个类型的arena起始只有一个，会占用1页的内存，只有当某个类型的arena的内存块被分配完毕后，才会创建下一个arena进行分配</p><p>为每一种规格的内存块创建一个内存块描述符，即mem_block_desc，在其中记录内存块规格的大小，以及位于所有同类arena中的空闲内存块链表</p><p>我们这里内存块设计成只有7个规格，即16 32 64 128 256 512 1024字节<br><img src="/../img/194fc78882ef32d27438cefb1ca1c744.png" title="arena与mem_block_desc的逻辑关系"></p><p>下面将根据上述原理介绍代码的实现<br>memory.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_CNT 7      <span class="hljs-comment">//内存块描述符的个数</span></span><br><br><span class="hljs-comment">/*内存块*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">free_elem</span>;</span>     <span class="hljs-comment">//list_elem是链表元素</span><br>&#125;;<br><br><span class="hljs-comment">/*内存块描述符*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block_desc</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> block_size;            <span class="hljs-comment">//内存块大小，例如16字节，64字节</span><br>    <span class="hljs-type">uint32_t</span> block_per_arena;       <span class="hljs-comment">//本arena中可容纳此mem_block的数量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">free_list</span>;</span>        <span class="hljs-comment">//目前可用的mem_block链表</span><br>&#125;;<br><br><span class="hljs-comment">/*内存仓库*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arena</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block_desc</span>* <span class="hljs-title">desc</span>;</span>        <span class="hljs-comment">//此arena关联的mem_block_desc</span><br>    <span class="hljs-type">uint32_t</span> cnt;           <span class="hljs-comment">//large为true，cnt代表页框数，为false，代表空闲mem_block数量</span><br>    <span class="hljs-type">bool</span> large; <br>&#125;;<br></code></pre></td></tr></table></figure><p>memory.c中添加了新的函数和结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block_desc</span> <span class="hljs-title">k_block_descs</span>[<span class="hljs-title">DESC_CNT</span>];</span>  <span class="hljs-comment">//内核内存块描述符数组</span><br><br><span class="hljs-comment">/*内存块初始化*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">block_desc_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mem_block_desc* desc_array)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> desc_idx,block_size = <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">for</span>(desc_idx = <span class="hljs-number">0</span>;desc_idx &lt; DESC_CNT;desc_idx++)<br>    &#123;<br>    desc_array[desc_idx].block_size = block_size;<br>    desc_array[desc_idx].block_per_arena = (PG_SIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> arena)) / block_size;<br>    list_init(&amp;desc_array[desc_idx].free_list);<br>    block_size *= <span class="hljs-number">2</span>;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>进程有自己的空间，为了实现用户进程的堆内存管理，在pcb中增加内存块描述符数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*PCB结构体，存储进程或线程的基本信息*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span>* self_kstack;                          <span class="hljs-comment">//当前线程对应的内核栈</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">task_status</span> <span class="hljs-title">status</span>;</span>                        <span class="hljs-comment">//线程状态</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];<br>    <span class="hljs-type">uint8_t</span> priority;      <span class="hljs-comment">//特权级</span><br>    <span class="hljs-type">uint8_t</span> ticks;              <span class="hljs-comment">//每次在处理器上执行的时间滴答数</span><br>    <span class="hljs-type">uint32_t</span> elapsed_ticks;     <span class="hljs-comment">//此任务执行了多久，即此任务从上cpu运行后至今占用了多少cpu滴答数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">general_tag</span>;</span>       <span class="hljs-comment">//用于线程在一般的队列中的节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">all_list_tag</span>;</span>      <span class="hljs-comment">//用于线程在线程队列中的节点</span><br>    <span class="hljs-type">uint32_t</span>* pgdir;        <span class="hljs-comment">//进程自己页表的虚拟地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtual_addr</span> <span class="hljs-title">userprog_vaddr</span>;</span>     <span class="hljs-comment">//用户进程的虚拟地址池</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block_desc</span> <span class="hljs-title">u_block_desc</span>[<span class="hljs-title">DESC_CNT</span>];</span>   <span class="hljs-comment">//用户进程内存块描述符</span><br>    <span class="hljs-type">uint32_t</span> stack_magic;      <span class="hljs-comment">//越界检查  因为我们pcb上面的就是我们要用的栈了 到时候还要越界检查</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>memory.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//返回arena中第idx个内存块的地址 空间布局为 arena元信息+n个内存块</span><br><span class="hljs-keyword">struct</span> mem_block* <span class="hljs-title function_">arena2block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> arena* a,<span class="hljs-type">uint32_t</span> idx)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> mem_block*)((<span class="hljs-type">uint32_t</span>)a + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> arena) + idx * a-&gt;desc-&gt;block_size);<br>&#125;<br><br><span class="hljs-comment">//返回内存块b所在的arena地址</span><br><span class="hljs-keyword">struct</span> arena* <span class="hljs-title function_">block2arena</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mem_block* b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> arena*)((<span class="hljs-type">uint32_t</span>)b &amp; <span class="hljs-number">0xfffff000</span>);<br>&#125;<br><br><span class="hljs-comment">//在堆中申请size字节内存</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">sys_malloc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> size)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pool_flags</span> <span class="hljs-title">PF</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span>* <span class="hljs-title">mem_pool</span>;</span><br>    <span class="hljs-type">uint32_t</span> pool_size;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block_desc</span>* <span class="hljs-title">descs</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur_thread</span> =</span> running_thread();<br>    <br>    <span class="hljs-keyword">if</span>(cur_thread-&gt;pgdir == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>    PF = PF_KERNEL;<br>    pool_size = kernel_pool.pool_size;<br>    mem_pool = &amp;kernel_pool;<br>    descs = k_block_descs;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    PF = PF_USER;<br>    pool_size = user_pool.pool_size;<br>    mem_pool = &amp;user_pool;<br>    descs = cur_thread-&gt;u_block_desc;<br>    &#125;<br>    <span class="hljs-comment">//size 超出空间大小或者为 0 负数</span><br>    <span class="hljs-keyword">if</span>(!(size &gt; <span class="hljs-number">0</span> &amp;&amp; size &lt; pool_size))<br>    &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arena</span>* <span class="hljs-title">a</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block</span>* <span class="hljs-title">b</span>;</span><br>    lock_acquire(&amp;mem_pool-&gt;lock);<br>    <br>    <span class="hljs-comment">//超过页框直接分配页框</span><br>    <span class="hljs-keyword">if</span>(size &gt; <span class="hljs-number">1024</span>)<br>    &#123;<br>    <span class="hljs-type">uint32_t</span> page_cnt = DIV_ROUND_UP(size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> arena),PG_SIZE);<br>    a = malloc_page(PF,page_cnt);<br>    <span class="hljs-keyword">if</span>(a != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,page_cnt * PG_SIZE);<br>    a-&gt;desc = <span class="hljs-literal">NULL</span>;<br>    a-&gt;cnt  = page_cnt;<br>    a-&gt;large = <span class="hljs-literal">true</span>;    <br>    lock_release(&amp;mem_pool-&gt;lock);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)(a+<span class="hljs-number">1</span>); <span class="hljs-comment">//返回地址 struct arena + sizeof(struct arena)</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    lock_release(&amp;mem_pool-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    <span class="hljs-type">uint8_t</span> desc_idx;<br>    <span class="hljs-keyword">for</span>(desc_idx = <span class="hljs-number">0</span>;desc_idx &lt; DESC_CNT;desc_idx++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(size &lt;= descs[desc_idx].block_size)<br>        &#123;<br>        <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//已经空了</span><br>    <span class="hljs-keyword">if</span>(list_empty(&amp;descs[desc_idx].free_list))<br>    &#123;<br>        a = malloc_page(PF,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>        lock_release(&amp;mem_pool-&gt;lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,PG_SIZE);<br>        <br>        a-&gt;desc = &amp;descs[desc_idx];<br>        a-&gt;large = <span class="hljs-literal">false</span>;<br>        a-&gt;cnt = descs[desc_idx].block_per_arena;<br>        <span class="hljs-type">uint32_t</span> block_idx;<br>        <br>        <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();<br>        <br>        <span class="hljs-keyword">for</span>(block_idx = <span class="hljs-number">0</span>;block_idx &lt; descs[desc_idx].block_per_arena;++block_idx)<br>        &#123;<br>        b = arena2block(a,block_idx);<br>        ASSERT(!elem_find(&amp;a-&gt;desc-&gt;free_list,&amp;b-&gt;free_elem));<br>        list_append(&amp;a-&gt;desc-&gt;free_list,&amp;b-&gt;free_elem);<br>        &#125;<br>        intr_set_status(old_status);<br>    &#125;<br>    <br>    b = (<span class="hljs-keyword">struct</span> mem_block*)list_pop(&amp;(descs[desc_idx].free_list));<br>    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,descs[desc_idx].block_size);<br>    <br>    a = block2arena(b);<br>    --a-&gt;cnt;<br>    lock_release(&amp;mem_pool-&gt;lock);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-5-内存的释放"><a href="#12-5-内存的释放" class="headerlink" title="12.5 内存的释放"></a>12.5 内存的释放</h2><p>堆的内存分配后，应该要及时回收内存，也就是内存的释放，与分配内存时的步骤完全相反即可</p><ol><li>在物理地址池中释放物理页地址</li><li>在页表中去掉虚拟地址的映射，将虚拟地址对应的pte的P位置0</li><li>在虚拟地址池中释放虚拟地址</li></ol><p>memory.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*将物理地址pg_phy_addr回收到物理内存池*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pfree</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> pg_phy_addr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span>* <span class="hljs-title">mem_pool</span>;</span><br>    <span class="hljs-type">uint32_t</span> bit_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(pg_phy_addr &gt;= user_pool.phy_addr_start)<br>    &#123;<br>    mem_pool = &amp;user_pool;<br>    bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    mem_pool = &amp;kernel_pool;<br>    bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE;<br>    &#125;<br>    bitmap_set(&amp;mem_pool-&gt;pool_bitmap,bit_idx,<span class="hljs-number">0</span>);<span class="hljs-comment">//全部置0</span><br>&#125;<br><br><span class="hljs-comment">/*去掉页表中虚拟地址vaddr的映射，只去掉vaddr对应的pte*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">page_table_pte_remove</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>* pte = pte_ptr(vaddr);<br>    *pte = ~PG_P_1;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;invlpg %0&quot;</span>::<span class="hljs-string">&quot;m&quot;</span>(vaddr):<span class="hljs-string">&quot;memory&quot;</span>)</span>;<span class="hljs-comment">//更新tlb</span><br>&#125;<br><br><span class="hljs-comment">/*在虚拟地址池中释放以_vaddr起始的连续pg_cnt个虚拟页地址*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vaddr_remove</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> pool_flags pf,<span class="hljs-type">void</span>* _vaddr,<span class="hljs-type">uint32_t</span> pg_cnt)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> bit_idx_start = <span class="hljs-number">0</span>,vaddr = (<span class="hljs-type">uint32_t</span>)_vaddr,cnt = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span>(pf == PF_KERNEL)<br>    &#123;<br>    bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;<br>    <span class="hljs-keyword">while</span>(cnt &lt; pg_cnt)<br>    &#123;<br>        bitmap_set(&amp;kernel_vaddr.vaddr_bitmap,bit_idx_start + (cnt++),<span class="hljs-number">0</span>);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    <span class="hljs-keyword">struct</span> task_struct* cur_thread = running_thread();<br>    bit_idx_start = (vaddr - cur_thread-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;<br>    <span class="hljs-keyword">while</span>(cnt &lt; pg_cnt)<br>    &#123;<br>        bitmap_set(&amp;cur_thread-&gt;userprog_vaddr.vaddr_bitmap,bit_idx_start + (cnt++),<span class="hljs-number">0</span>);<br>    &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*释放以虚拟地址vaddr为起始的cnt个物理页框*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mfree_page</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> pool_flags pf,<span class="hljs-type">void</span>* _vaddr,<span class="hljs-type">uint32_t</span> pg_cnt)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> pg_phy_addr;<br>    <span class="hljs-type">uint32_t</span> vaddr = (<span class="hljs-type">int32_t</span>)_vaddr,page_cnt = <span class="hljs-number">0</span>;<br>    ASSERT(pg_cnt &gt;= <span class="hljs-number">1</span> &amp;&amp; vaddr % PG_SIZE == <span class="hljs-number">0</span>);<br>    pg_phy_addr = addr_v2p(vaddr);<br>    <br>    ASSERT((pg_phy_addr % PG_SIZE) == <span class="hljs-number">0</span> &amp;&amp; pg_phy_addr &gt;= <span class="hljs-number">0x102000</span>);<br>    <br>    <span class="hljs-keyword">if</span>(pg_phy_addr &gt;= user_pool.phy_addr_start)<br>    &#123;<br>    vaddr -= PG_SIZE;<br>    <span class="hljs-keyword">while</span>(page_cnt &lt; pg_cnt)<br>    &#123;<br>        vaddr += PG_SIZE;<br>        pg_phy_addr = addr_v2p(vaddr);<br>        ASSERT((pg_phy_addr % PG_SIZE) == <span class="hljs-number">0</span> &amp;&amp; pg_phy_addr &gt;= user_pool.phy_addr_start);<br>        pfree(pg_phy_addr);<br>        page_table_pte_remove(vaddr);<br>        page_cnt++;<br>    &#125;<br>    vaddr_remove(pf,_vaddr,pg_cnt);<br>   &#125;<br>   <span class="hljs-keyword">else</span><br>   &#123;<br>   vaddr -= PG_SIZE;<br>   <span class="hljs-keyword">while</span>(page_cnt &lt; pg_cnt)<br>   &#123;<br>       vaddr += PG_SIZE;<br>       pg_phy_addr = addr_v2p(vaddr);<br>       ASSERT((pg_phy_addr % PG_SIZE) == <span class="hljs-number">0</span> &amp;&amp; pg_phy_addr &gt;= kernel_pool.phy_addr_start &amp;&amp; pg_phy_addr &lt; user_pool.phy_addr_start);<br>       pfree(pg_phy_addr);<br>       page_table_pte_remove(vaddr);<br>       page_cnt++;<br>   &#125;<br>   vaddr_remove(pf,_vaddr,pg_cnt);<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/*回收内存ptr*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sys_free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span><br>&#123;<br>    ASSERT(ptr != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pool_flags</span> <span class="hljs-title">PF</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span>* <span class="hljs-title">mem_pool</span>;</span><br>    <br>    <span class="hljs-keyword">if</span>(running_thread()-&gt;pgdir == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        ASSERT((<span class="hljs-type">uint32_t</span>)ptr &gt;= K_HEAP_START);<br>        PF = PF_KERNEL;<br>        mem_pool = &amp;kernel_pool;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        PF = PF_USER;<br>        mem_pool = &amp;user_pool;<br>    &#125;<br>    <br>    lock_acquire(&amp;mem_pool-&gt;lock);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block</span>* <span class="hljs-title">b</span> =</span> ptr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">arena</span>* <span class="hljs-title">a</span> =</span> block2arena(b);<br>    <br>    ASSERT(a-&gt;large == <span class="hljs-number">0</span> || a-&gt;large == <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(a-&gt;desc == <span class="hljs-literal">NULL</span> &amp;&amp; a-&gt;large == <span class="hljs-literal">true</span>)<br>    &#123;<br>        mfree_page(PF,a,a-&gt;cnt);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        list_append(&amp;a-&gt;desc-&gt;free_list,&amp;b-&gt;free_elem);<br>        <span class="hljs-keyword">if</span>(++a-&gt;cnt == a-&gt;desc-&gt;block_per_arena)<br>        &#123;<br>        <span class="hljs-type">uint32_t</span> block_idx;<br>        <span class="hljs-keyword">for</span>(block_idx = <span class="hljs-number">0</span>;block_idx &lt; a-&gt;desc-&gt;block_per_arena;block_idx++)<br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block</span>* <span class="hljs-title">b</span> =</span> arena2block(a,block_idx);<br>            ASSERT(elem_find(&amp;a-&gt;desc-&gt;free_list,&amp;b-&gt;free_elem));<br>            list_remove(&amp;b-&gt;free_elem);<br>        &#125;<br>        mfree_page(PF,a,<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    lock_release(&amp;mem_pool-&gt;lock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第十一章 用户进程</title>
    <link href="/2025/01/05/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <url>/2025/01/05/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>一直以来，我们的程序都是在最高特权级0级下工作，现在我们将实现特权级为3的用户进程</p><h2 id="11-1-任务状态段TSS"><a href="#11-1-任务状态段TSS" class="headerlink" title="11.1 任务状态段TSS"></a>11.1 任务状态段TSS</h2><p>由处理器维护，用于存储当前任务（线程或进程）运行所需的状态信息，包括寄存器值、段选择器、堆栈指针等内容。<br>TSS是早期CPU厂商为了实现多任务切换而为CPU专门设计的一个结构，即使现在我们已经不使用TSS来完成任务的切换，但由于该结构在CPU的存在，我们依然要使用它完成少部分功能，大部分的任务切换工作交给PCB完成，参考第九章</p><p>TSS和其他段一样，本质上是一片存储数据的内存区域，因此也需要一个段描述符来描述，称为TSS描述符，也需要在GDT中注册<br><img src="/../img/b6604fe0bc10c9de0f23976bc28ea42f.jpeg" title="TSS段描述符"><br>针对该描述符，主要解释B位，也就是繁忙位，繁忙的意思是：一方面指此任务是当前正在CPU运行的任务，另一方面是指此任务嵌套调用了新的任务，因此暂时被挂起</p><p>TSS描述符是用来描述TSS的，现在介绍下TSS<br><img src="/../img/20160924135346461.png" title="32位TSS结构"></p><ul><li>TSS里存储的几乎都是寄存器的数据，这些寄存器就是任务运行中的最新状态</li><li>TSS中有三组栈，分别是SS0,SS1,SS2,esp0,esp1,esp2 分别是CPU在不同特权级下使用的栈，最低特权级为3，因此不用存储特权级3的栈，这三组栈仅仅试用由低权级跳到高权级时使用。Linux只使用了特权级0和特权级3，因此我们也只设置特权级0的栈SS0和esp0</li><li>TSS是CPU原生支持的架构，因此CPU会自己维护它，即任务被换下时CPU会自动将当前任务寄存器的状态存入TSS对应位置，当任务被换上时CPU会自动根据对应TSS的内容将寄存器的状态更新到相应位置，TSS由用户提供，CPU自动维护</li><li>寄存器TR始终指向当前任务的TSS，任务切换就是改变TR的指向，TR寄存器中存储的是TSS的选择子，TSS要在GDT中注册描述符</li></ul><h2 id="11-2-CPU原生支持的任务切换方式"><a href="#11-2-CPU原生支持的任务切换方式" class="headerlink" title="11.2 CPU原生支持的任务切换方式"></a>11.2 CPU原生支持的任务切换方式</h2><p>这里属于额外知识，了解原生支持的任务切换模式，并了解为什么不选用这种方式</p><p>中断处理程序和任务切换的区别：<br>在CPU眼里，只有TSS切换了才代表任务切换，中断处理程序只是服务中断的，任务切换是更复杂的调度行为，例如，一个任务中触发中断，进入到了内核态执行中断服务代码，但此时CPU的TR寄存器中存储的TSS没有改变，因此任务没有切换，当中断返回后同理，任务也没有切换。但如果中断函数是执行另外一个任务，那么此时就会发生任务切换，有点像是任务嵌套。</p><p>可以通过中断+任务门的方式进行任务切换，具体操作：</p><ol><li>从任务门中找到TSS选择子</li><li>用这个TSS选择子在GDT中找到TSS描述符</li><li>判断TSS描述符是否符合规范，例如P位是否为1</li><li>从TR寄存器中获取旧的TSS位置，保存好旧的状态，并将旧的TSS地址存入到新的TSS中</li><li>TR寄存器指向新的TSS</li><li>新的TSS中描述符的B位置1，表示嵌套调用，同时eflags的NT位置1</li><li>开始执行新任务</li><li>执行完成后，调用iret返回旧任务，操作与上述相反即可。</li></ol><p>也可以通过jmp、call进行任务切换，类似上述中断+任务门的流程</p><h2 id="11-3-现代操作系统采用的任务切换方式"><a href="#11-3-现代操作系统采用的任务切换方式" class="headerlink" title="11.3 现代操作系统采用的任务切换方式"></a>11.3 现代操作系统采用的任务切换方式</h2><p>根据11.2可知，每次切换任务需要进行的操作太多了，又要找TSS又要设置各种位，时间上浪费的比较多，同时一个任务要关联一个TSS，但GDT最多只有8192个段描述符可以注册，任务的增添与替换需要频繁改动GDT，也很浪费时间</p><p>但我们必须在CPU的环境下编写程序，而且TSS中对各个特权级的栈地址的保留也是我们必须要用的，因此我们只使用TSS中的栈地址的功能，因为用户进程一般是通过中断转移特权级的，因此我们使用TSS中0特权级下的栈给用户进行转移。</p><p>Linux为每个CPU创建一个TSS，在各个CPU上的所有任务共享同一个TSS，在进程切换时，只需要更改TSS中的SS0以及esp0为新任务的内核栈即可<br>在从特权级3进入到特权级0时，CPU自动从TR寄存器中找到TSS，再找到SS0和esp0，然后手动执行一系列push指令将任务的状态保存在0特权级的栈中（是PCB吗？）<br>这样避免了重复加载TR寄存器，因为需要从内存中找到TSS选择子加载到TR寄存器，内存是很慢的在CPU眼里，远不如直接操控寄存器修改寄存器的值</p><h2 id="11-4-定义并初始化TSS"><a href="#11-4-定义并初始化TSS" class="headerlink" title="11.4 定义并初始化TSS"></a>11.4 定义并初始化TSS</h2><p>global.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_G_4K1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_D_321</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_L0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_AVL0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_P1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_00</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_11</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_22</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_33</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_S_CODE1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_S_DATADESC_S_CODE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_S_SYS0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_TYPE_CODE8</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_TYPE_DATA 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_TYPE_TSS  9</span><br><br><span class="hljs-comment">/*KERNEL段*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_CODE   ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_DATA   ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_STACK          SELECTOR_K_DATA </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_GS           ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-comment">/*这里是TSS*/</span><br><span class="hljs-comment">/*USER段*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_U_CODE     ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_U_DATA   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_U_STACK   SELECTOR_U_DATA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ATTR_HIGH   ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_CODE_ATTR_LOW_DPL3    ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_DATA_ATTR_LOW_DPL3    ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)</span><br><br><span class="hljs-comment">//--------------   TSS描述符属性  ------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TSS_DESC_D 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0X0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TSS_ATTR_LOW  ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  SELECTOR_TSS  ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><br><span class="hljs-comment">/*描述符结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gdt_desc</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint16_t</span> limit_low_word;<br>    <span class="hljs-type">uint16_t</span> base_low_word;<br>    <span class="hljs-type">uint8_t</span>  base_mid_byte;<br>    <span class="hljs-type">uint8_t</span>  attr_low_byte;<br>    <span class="hljs-type">uint8_t</span>  limit_high_attr_high;<br>    <span class="hljs-type">uint8_t</span>  base_high_byte;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码是一些定义，重点在下面的tss.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tss.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_SIZE 4096</span><br><br><span class="hljs-comment">/*任务状态段tss结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> backlink;<br>    <span class="hljs-type">uint32_t</span>* esp0;<br>    <span class="hljs-type">uint32_t</span> ss0;<br>    <span class="hljs-type">uint32_t</span>* esp1;<br>    <span class="hljs-type">uint32_t</span> ss1;<br>    <span class="hljs-type">uint32_t</span>* esp2;<br>    <span class="hljs-type">uint32_t</span> ss2;<br>    <span class="hljs-type">uint32_t</span> cr3;<br>    <span class="hljs-type">uint32_t</span> (*eip) (<span class="hljs-type">void</span>);<br>    <span class="hljs-type">uint32_t</span> eflags;<br>    <span class="hljs-type">uint32_t</span> eax;<br>    <span class="hljs-type">uint32_t</span> ecx;<br>    <span class="hljs-type">uint32_t</span> edx;<br>    <span class="hljs-type">uint32_t</span> ebx;<br>    <span class="hljs-type">uint32_t</span> esp;<br>    <span class="hljs-type">uint32_t</span> ebp;<br>    <span class="hljs-type">uint32_t</span> esi;<br>    <span class="hljs-type">uint32_t</span> edi;<br>    <span class="hljs-type">uint32_t</span> es;<br>    <span class="hljs-type">uint32_t</span> cs;<br>    <span class="hljs-type">uint32_t</span> ss;<br>    <span class="hljs-type">uint32_t</span> ds;<br>    <span class="hljs-type">uint32_t</span> fs;<br>    <span class="hljs-type">uint32_t</span> gs;<br>    <span class="hljs-type">uint32_t</span> ldt;<br>    <span class="hljs-type">uint32_t</span> trace;<br>    <span class="hljs-type">uint32_t</span> io_base;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tss</span> <span class="hljs-title">tss</span>;</span><br><br><span class="hljs-comment">/*更新tss中的esp0字段的值为pthread的0级栈*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_tss_esp</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* pthread)</span>&#123;<br>    tss.esp0 = (<span class="hljs-type">uint32_t</span>*)((<span class="hljs-type">uint32_t</span>)pthread + PG_SIZE);<br>&#125;<br><br><span class="hljs-comment">/*创建一个gdt描述符*/</span><br><span class="hljs-keyword">struct</span> gdt_desc <span class="hljs-title function_">make_gdt_desc</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* desc_addr,<span class="hljs-type">uint32_t</span> limit,<span class="hljs-type">uint8_t</span> attr_low,<span class="hljs-type">uint8_t</span> attr_high)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gdt_desc</span> <span class="hljs-title">desc</span>;</span><br>    <span class="hljs-type">uint32_t</span> desc_base = (<span class="hljs-type">uint32_t</span>) desc_addr;<br>    desc.limit_low_word =  limit &amp; <span class="hljs-number">0x0000ffff</span>;<br>    desc.base_low_word = desc_base &amp; <span class="hljs-number">0x0000ffff</span>;<br>    desc.base_mid_byte = ((desc_base &amp; <span class="hljs-number">0x00ff0000</span>) &gt;&gt; <span class="hljs-number">16</span>);<br>    desc.attr_low_byte = (<span class="hljs-type">uint8_t</span>)(attr_low);<br>    desc.limit_high_attr_high = (((limit &amp; <span class="hljs-number">0x000f0000</span>) &gt;&gt; <span class="hljs-number">16</span>) + (<span class="hljs-type">uint8_t</span>)(attr_high));<br>    desc.base_high_byte = desc_base &gt;&gt; <span class="hljs-number">24</span>;<br>    <span class="hljs-keyword">return</span> desc;<br>&#125;<br><br><span class="hljs-comment">/*在gdt中创建tss并重新加载gdt*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">tss_init</span><span class="hljs-params">()</span><br>&#123;<br>    put_str(<span class="hljs-string">&quot;tss_init start\n&quot;</span>);<br>    <span class="hljs-type">uint32_t</span> tss_size = <span class="hljs-keyword">sizeof</span>(tss);<br>    <span class="hljs-built_in">memset</span>(&amp;tss,<span class="hljs-number">0</span>,tss_size);<br>    tss.ss0 = SELECTOR_K_STACK;     <span class="hljs-comment">//平坦模式，堆栈段和数据段使用同一段</span><br>    tss.io_base = tss_size;     <span class="hljs-comment">//tss段没有io图</span><br>    <br>    <span class="hljs-comment">//之前在loader.S中，设置了gdt的前四个段，分别是：</span><br>    <span class="hljs-comment">//0：保留，不可用。   1：代码段   2：数据段和栈段     3：显存段</span><br>    <span class="hljs-comment">//gdt在内存的位置为0x0903，或者也可以是0xc0000903，下面新增加三个段，分别是tss段，DPL为3的用户代码段、DPL为3的用户数据段</span><br>    *((<span class="hljs-keyword">struct</span> gdt_desc*)<span class="hljs-number">0xc0000923</span>) = make_gdt_desc((<span class="hljs-type">uint32_t</span>*)&amp;tss,tss_size<span class="hljs-number">-1</span>,TSS_ATTR_LOW,TSS_ATTR_HIGH); <br>    *((<span class="hljs-keyword">struct</span> gdt_desc*)<span class="hljs-number">0xc000092b</span>) = make_gdt_desc((<span class="hljs-type">uint32_t</span>*)<span class="hljs-number">0</span>,<span class="hljs-number">0xfffff</span>,GDT_CODE_ATTR_LOW_DPL3,\<br>           GDT_ATTR_HIGH);<br>    *((<span class="hljs-keyword">struct</span> gdt_desc*)<span class="hljs-number">0xc0000933</span>) = make_gdt_desc((<span class="hljs-type">uint32_t</span>*)<span class="hljs-number">0</span>,<span class="hljs-number">0xfffff</span>,GDT_DATA_ATTR_LOW_DPL3,\<br>           GDT_ATTR_HIGH);<br>    <span class="hljs-type">uint64_t</span> gdt_operand = \<br>    ((<span class="hljs-number">8</span>*<span class="hljs-number">7</span> - <span class="hljs-number">1</span>) | ((<span class="hljs-type">uint64_t</span>)(<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xc0000903</span> &lt;&lt; <span class="hljs-number">16</span>));<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lgdt %0&quot;</span> :: <span class="hljs-string">&quot;m&quot;</span>(gdt_operand))</span>;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;ltr %w0&quot;</span> :: <span class="hljs-string">&quot;r&quot;</span>(SELECTOR_TSS))</span>;<br>    put_str(<span class="hljs-string">&quot;tss_init and ltr done\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码有几个需要注意的地方</p><ol><li><code>void update_tss_esp(struct task_struct* pthread)</code> 这个函数更新tss中的esp0字段的值为pthread的0级栈，也就是该线程pthread的PCB所在页的最顶端，此栈地址是用户从用户态进入到内核态时所用的栈</li><li>之前在loader.S中，设置了gdt的前四个段，分别是：0：保留，不可用。   1：代码段   2：数据段和栈段     3：显存段， gdt在内存的位置为0x0903，或者也可以是0xc0000903，新增加三个段，分别是tss段，DPL为3的用户代码段、DPL为3的用户数据段</li></ol><h2 id="11-5-实现用户进程"><a href="#11-5-实现用户进程" class="headerlink" title="11.5 实现用户进程"></a>11.5 实现用户进程</h2><p>我们将在第9章实现内核线程的基础上实现用户进程，进程与线程的区别是进程拥有独立的地址空间，也就是有自己的页表<br>首先修改一些内存管理的一些操作<br>memory.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*在pf标识的内存池中申请pg_cnt个虚拟页，成功则返回虚拟页的地址，失败返回NULL*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">vaddr_get</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> pool_flags pf,<span class="hljs-type">uint32_t</span> pg_cnt)</span><br>&#123;<br>    <span class="hljs-type">int</span> vaddr_start = <span class="hljs-number">0</span>,bit_idx_start = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">uint32_t</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(pf == PF_KERNEL)     <span class="hljs-comment">//内核池</span><br>    &#123;<br>    bit_idx_start = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap,pg_cnt); <span class="hljs-comment">//在bitmap中申请连续位，申请成功则返回初始位的下标</span><br>    <span class="hljs-keyword">if</span>(bit_idx_start == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(cnt &lt; pg_cnt)<br>    bitmap_set(&amp;kernel_vaddr.vaddr_bitmap,bit_idx_start + (cnt++),<span class="hljs-number">1</span>);   <span class="hljs-comment">//从bit_idx_start开始连续pg_cnt个位都设为1</span><br>    vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;   <span class="hljs-comment">//申请到的虚拟地址起始页是虚拟地址开始位置+bitmap申请到的起始位*4K</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>        <span class="hljs-comment">//用户池，已实现</span><br>    &#123;<br>        <span class="hljs-keyword">struct</span> task_struct* cur = running_thread();     <span class="hljs-comment">//每个进程都有自己的虚拟池</span><br>    bit_idx_start = bitmap_scan(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap,pg_cnt);<br>    <span class="hljs-keyword">if</span>(bit_idx_start == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(cnt &lt; pg_cnt)<br>    bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap,bit_idx_start + (cnt++),<span class="hljs-number">1</span>);<br>    vaddr_start = cur-&gt;userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;<br>    ASSERT((<span class="hljs-type">uint32_t</span>)vaddr_start &lt; (<span class="hljs-number">0xc0000000</span> - PG_SIZE));<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)vaddr_start;<br>&#125;<br><br><span class="hljs-comment">/*在用户空间中申请pg_cnt页的内存，并返回其虚拟地址*/</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">get_user_pages</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> pg_cnt)</span>&#123;<br>    lock_acquire(&amp;user_pool.lock);<span class="hljs-comment">//用户进程可能会产生冲突 大部分时间都在用户进程 内核进程可以理解基本不会冲突</span><br>    <span class="hljs-type">void</span>* vaddr = malloc_page(PF_USER,pg_cnt);<br>    <span class="hljs-keyword">if</span>(vaddr != <span class="hljs-literal">NULL</span>)<span class="hljs-built_in">memset</span>(vaddr,<span class="hljs-number">0</span>,pg_cnt*PG_SIZE);<br>    lock_release(&amp;user_pool.lock);<br>    <span class="hljs-keyword">return</span> vaddr;<br>&#125;<br><br><span class="hljs-comment">/*在用户空间或者内核空间分配一页内存，并将虚拟地址vaddr与其做映射*/</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">get_a_page</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> pool_flags pf,<span class="hljs-type">uint32_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span>* <span class="hljs-title">mem_pool</span> =</span> (pf == PF_KERNEL) ? &amp;kernel_pool : &amp;user_pool;<br>    lock_acquire(&amp;mem_pool-&gt;lock);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur</span> =</span> running_thread();<br>    <span class="hljs-type">int32_t</span> bit_idx = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-comment">//虚拟地址位图置1</span><br>    <span class="hljs-keyword">if</span>(cur-&gt;pgdir != <span class="hljs-literal">NULL</span> &amp;&amp; pf == PF_USER)<br>    &#123;<br>    bit_idx = (vaddr - cur-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;<br>    ASSERT(bit_idx &gt; <span class="hljs-number">0</span>);<br>    bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap,bit_idx,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur-&gt;pgdir == <span class="hljs-literal">NULL</span> &amp;&amp; pf == PF_KERNEL) <br>    &#123;<br>    bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;<br>    ASSERT(bit_idx &gt; <span class="hljs-number">0</span>);<br>    bitmap_set(&amp;kernel_vaddr.vaddr_bitmap,bit_idx,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    PANIC(<span class="hljs-string">&quot;get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page&quot;</span>);<br>    <br>    <span class="hljs-type">void</span>* page_phyaddr = palloc(mem_pool);<br>    <span class="hljs-keyword">if</span>(page_phyaddr == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    page_table_add((<span class="hljs-type">void</span>*)vaddr,page_phyaddr);<br>    lock_release(&amp;mem_pool-&gt;lock);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)vaddr;<br>&#125;<br><br><span class="hljs-comment">/* 得到虚拟地址映射的物理地址 */</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">addr_v2p</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>* pte = pte_ptr(vaddr);<br>    <span class="hljs-keyword">return</span> ((*pte &amp; <span class="hljs-number">0xfffff000</span>) + (vaddr &amp; <span class="hljs-number">0x00000fff</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>一直以来我们都是在特权级0下工作，包括创建用户进程也是，但我们如何从特权0迈向特权3呢，一般情况下CPU不允许从高特权级转向低特权级，除了中断和调用门返回的情况，因此我们可以利用这个 返回 ，假装回到特权级3</p><p>process.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tss.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;process.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;console.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">intr_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;    <span class="hljs-comment">//声明了外部函数，退出中断的出口</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">thread_ready_list</span>;</span>      <span class="hljs-comment">//就绪队列</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">thread_all_list</span>;</span>        <span class="hljs-comment">//所有任务队列</span><br><br><span class="hljs-comment">/*构建用户进程的上下文信息*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_process</span><span class="hljs-params">(<span class="hljs-type">void</span>* filename_)</span><br>&#123;<br>    <span class="hljs-comment">//schedule线程调度后 来到这里</span><br>    <span class="hljs-comment">//特权级0级 到 3级通过 iretd &quot;欺骗&quot; cpu  把用户进程的环境给准备好 iretd即进入</span><br>    <span class="hljs-type">void</span>* function = filename_;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur</span> =</span> running_thread();<br>    cur -&gt; self_kstack += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> thread_stack);      <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_stack</span>* <span class="hljs-title">proc_stack</span> =</span> (<span class="hljs-keyword">struct</span> intr_stack*)cur -&gt; self_kstack;<br>    <span class="hljs-comment">//proc_stack指向了PCB里intr_stack栈的最低处</span><br>    proc_stack-&gt;edi = proc_stack-&gt;esi = proc_stack-&gt;ebp = proc_stack-&gt;esp_dummy = <span class="hljs-number">0</span>;<br>    proc_stack-&gt;ebx = proc_stack-&gt;edx = proc_stack-&gt;ecx = proc_stack-&gt;eax = <span class="hljs-number">0</span>;<br>    proc_stack-&gt;gs = <span class="hljs-number">0</span>;         <span class="hljs-comment">//操作系统不允许用户访问显存，因此显存段寄存器初始化为0</span><br>    proc_stack-&gt;ds = proc_stack-&gt;es = proc_stack-&gt;fs = SELECTOR_U_DATA;<span class="hljs-comment">//数据段选择子</span><br>    proc_stack-&gt;eip = function;<span class="hljs-comment">//函数地址 ip</span><br>    proc_stack-&gt;cs = SELECTOR_U_CODE;<span class="hljs-comment">//cs ip cs选择子</span><br>    proc_stack-&gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);<span class="hljs-comment">//不能够关闭中断 ELFAG_IF_1 不然会导致无法调度</span><br>    proc_stack-&gt;esp = (<span class="hljs-type">void</span>*)((<span class="hljs-type">uint32_t</span>)get_a_page(PF_USER,USER_STACK3_VADDR) + PG_SIZE);<span class="hljs-comment">//栈空间在0xc0000000以下一页的地方 当然物理内存是操作系统来分配</span><br>    proc_stack-&gt;ss = SELECTOR_U_DATA;<span class="hljs-comment">//数据段选择子</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;movl %0,%%esp;jmp intr_exit&quot;</span>: : <span class="hljs-string">&quot;g&quot;</span>(proc_stack) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">/*激活进程或者线程的页表*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">page_dir_activate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* p_thread)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> pagedir_phy_addr = <span class="hljs-number">0x100000</span>; <span class="hljs-comment">//之前设置的页目录表的物理地址</span><br>    <span class="hljs-keyword">if</span>(p_thread-&gt;pgdir != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>    pagedir_phy_addr = addr_v2p((<span class="hljs-type">uint32_t</span>)p_thread-&gt;pgdir); <span class="hljs-comment">//得到实际页目录地址</span><br>    &#125;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;movl %0,%%cr3&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(pagedir_phy_addr) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">/*激活线程或进程的页表，更新tss中的esp0为进程的特权级0的栈*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">process_activate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* p_thread)</span><br>&#123;<br>    page_dir_activate(p_thread);<br>    <br>    <span class="hljs-comment">//tss切换需要</span><br>    <span class="hljs-keyword">if</span>(p_thread-&gt;pgdir)<br>    update_tss_esp(p_thread);<br>&#125;<br><br><span class="hljs-comment">/*创建页目录表，成功则返回页目录的虚拟地址，将当前页表的表示内核空间的pde复制，使用户进程目录表中的第768-1023个页目录项用内核所在页目录的第768-1023个页目录项代替*/</span><br><span class="hljs-type">uint32_t</span>* <span class="hljs-title function_">create_page_dir</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>* page_dir_vaddr = get_kernel_pages(<span class="hljs-number">1</span>);<span class="hljs-comment">//在内核内存池中申请一页</span><br>    <span class="hljs-keyword">if</span>(page_dir_vaddr == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>    console_put_str(<span class="hljs-string">&quot;create_page_dir: get_kernel_page failed!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">uint32_t</span>*)((<span class="hljs-type">uint32_t</span>)page_dir_vaddr + <span class="hljs-number">0x300</span>*<span class="hljs-number">4</span>),(<span class="hljs-type">uint32_t</span>*)(<span class="hljs-number">0xfffff000</span>+<span class="hljs-number">0x300</span>*<span class="hljs-number">4</span>),<span class="hljs-number">1024</span>); <span class="hljs-comment">// 将内核页目录项的第768项后的256项都复制给用户空间的页目录表对应的页目录项</span><br>    <br>    <span class="hljs-type">uint32_t</span> new_page_dir_phy_addr = addr_v2p((<span class="hljs-type">uint32_t</span>)page_dir_vaddr);                    <br>    page_dir_vaddr[<span class="hljs-number">1023</span>] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;                    <span class="hljs-comment">//最后一项是页目录项自己的地址</span><br>    <span class="hljs-keyword">return</span> page_dir_vaddr;     <br>&#125;<br><br><span class="hljs-comment">/*创建用户进程的虚拟地址位图*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">create_user_vaddr_bitmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* user_prog)</span><br>&#123;<br>    user_prog-&gt;userprog_vaddr.vaddr_start = USER_VADDR_START; <span class="hljs-comment">//位图开始管理的位置</span><br>    <span class="hljs-type">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="hljs-number">0xc0000000</span> - USER_VADDR_START)/ PG_SIZE / <span class="hljs-number">8</span>,PG_SIZE); <span class="hljs-comment">//向上取整取虚拟页数</span><br>    user_prog-&gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);<br>    user_prog-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (<span class="hljs-number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="hljs-number">8</span>;<br>    bitmap_init(&amp;user_prog-&gt;userprog_vaddr.vaddr_bitmap);<br>&#125;<br><br><span class="hljs-comment">/*创建用户进程filename，并将其加入就绪队列等待执行*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">process_execute</span><span class="hljs-params">(<span class="hljs-type">void</span>* filename,<span class="hljs-type">char</span>* name)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">thread</span> =</span> get_kernel_pages(<span class="hljs-number">1</span>);  <span class="hljs-comment">//分配一页空间 得到pcb</span><br>    init_thread(thread,name,default_prio); <span class="hljs-comment">//初始化pcb</span><br>    create_user_vaddr_bitmap(thread); <span class="hljs-comment">//为虚拟地址位图初始化 分配空间</span><br>    thread_create(thread,start_process,filename); <span class="hljs-comment">//创造线程 start_process 之后通过start_process intr_exit跳转到用户进程</span><br>    thread-&gt;pgdir = create_page_dir(); <span class="hljs-comment">//把页目录表的地址分配了 并且把内核的页目录都给复制过去 这样操作系统对每个进程都可见</span><br>    block_desc_init(thread -&gt; u_block_desc);<br><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();     <br>    ASSERT(!elem_find(&amp;thread_ready_list,&amp;thread-&gt;general_tag));<br>    list_append(&amp;thread_ready_list,&amp;thread-&gt;general_tag);     <span class="hljs-comment">//添加线程 start_process到就绪队列中</span><br>    <br>    ASSERT(!elem_find(&amp;thread_all_list,&amp;thread-&gt;all_list_tag));<br>    list_append(&amp;thread_all_list,&amp;thread-&gt;all_list_tag);<br>    intr_set_status(old_status);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关键点：</p><ul><li><code>void start_process(void* filename_)</code> 构建用户进程的上下文信息，让用户进程的PCB的内核栈指向中断栈，可以理解为用户进程是通过中断栈来保护上下文的，内核线程是通过线程栈来保护上下文的？根据C程序的内存布局，我们将用户进程栈的位置设置为虚拟地址3GB的最高位</li><li>每个进程都有独立的虚拟地址空间，本质上就是各个进程都有自己的单独的页表空间，但cr3寄存器只有一个，所以切换进程时也需要切换cr3寄存器中的数据，换上与之配套的页表，用户进程的切换还需要更新tss中的0级栈</li><li>操作系统是被所有用户进程共享的，因此即使用户进程有自己独立的页表，但是页目录项的高256项都是一样的，也就是指向操作系统内核，我们需要将内核页表的页目录高256位复制给每个用户进程的页表，并修改每个用户进程的页目录的最后一项，不能指向内核的页目录，应该指向用户进程自己的页目录</li></ul><p>用户线程的调度，schedule函数需要加入激活任务页表的函数<code>void process_activate(struct task_struct* p_thread)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*实现任务调度:将当前线程换下处理器，并在就绪队列中找到下一个可运行的线程，放上处理器*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span>&#123;<br>    ASSERT(intr_get_status() == INTR_OFF);      <span class="hljs-comment">//？？？为什么要关中断，在哪里关了 ！在锁那里</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur</span> =</span> running_thread();     <span class="hljs-comment">//获取当前线程的PCB</span><br>    <span class="hljs-keyword">if</span>(cur -&gt; status == TASK_RUNNING)&#123;<br>        <span class="hljs-comment">//如果当前线程只是因为时间片到期了，则将其重新放到准备队列中，</span><br>        ASSERT(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));<br>        list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);<br>        cur -&gt; ticks = cur -&gt; priority;<br>        cur -&gt; status = TASK_READY;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//如果当前线程还需要某些条件才能重新上CPU，则暂时不放入准备队列中</span><br>    &#125;<br>    ASSERT(!list_empty(&amp;thread_ready_list));    <span class="hljs-comment">//为了避免队列里无线程可用的情况，暂时用断言来保证</span><br>    <span class="hljs-comment">//获取准备队列中的队首线程PCB，将其状态设置为running，并通过switch_to切换寄存器影响</span><br>    thread_tag = list_pop(&amp;thread_ready_list);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">next</span> =</span> (<span class="hljs-keyword">struct</span> task_struct*)((<span class="hljs-type">uint32_t</span>)thread_tag &amp; <span class="hljs-number">0xfffff000</span>);<br>    next -&gt; status = TASK_RUNNING;<br>    process_activate(next);<br>    switch_to(cur, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们以创建一个进程为例，看下述代码：<br>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>process_exeute(u_prog_a, <span class="hljs-string">&quot;user_prog_a&quot;</span>);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">u_prog_a</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        test_var_a++;<br>    &#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p><strong>我们来看<code>void process_execute(void* filename,char* name)</code>这个函数的整体实现逻辑：</strong></p><ol><li>先创建进程的身份证，也就是PCB，通过<code>get_kernel_pages</code>函数给PCB结构<code>task_struct</code>分配一页。进程的PCB虽然是用户进程，但是是存储在内核空间里的，PCB 是操作系统用于管理和调度进程的关键数据结构，包含了很多敏感的和系统级的信息，必须由内核来保护和访问。</li><li>调用<code>init_thread</code>函数初始化进程的PCB，这一步与内核线程PCB的初始化时一致的</li><li>调用<code>create_user_vaddr_bitmap</code>函数初始化用户进程PCB中的虚拟地址位图，在init_thread函数中并没有初始化虚拟地址位图，因为内核线程不需要这一项<ul><li>PCB中用户进程虚拟地址位图包含了位图和起始虚拟地址，需要分别初始化</li><li>将用户进程虚拟地址位图管理的起始虚拟地址设置为0x8048000，这个数字属于历史延续下来的传统</li><li>4G的空间，用户能够管理的独立空间只有3G，因为高1G空间属于操作系统，所有用户进程都是共享这1G空间的</li><li>因此用户能够管理的范围是0xc0000000-0x8048000，位图每个位管理4KB，利用这一点设计位图的大小</li></ul></li><li>调用<code>thread_create(thread,start_process,filename);</code> 创造线程（在这里可以叫做进程）<ul><li>复习tips：当初在创建内核线程的时候，就是调用thread_create函数，在里面将<code>kernel_thread</code>放入内核栈（内核线程的话是线程栈）的eip位置，将函数和函数参数放入内核栈占位元素后面，到时通过<code>iret</code>将内核栈（线程栈）里的<code>kernel_thread</code>弹出到eip寄存器，CPU将会跳转到kernel_thread函数，此时栈空间没有发生变化，因为特权级没有变化，所以可以通过参数与占位符的相对位置，执行function(func_arg)，详情参考第九章</li><li>用户进程中调用thread_create函数时，也是一样让用户进程PCB的内核栈指向了线程栈的位置，并同样将<code>kernel_thread</code>放入线程栈的eip位置，只不过所有用户进程都会通过<code>kernel_thread</code>执行<code>start_process(filename)</code>函数，而不是像内核线程一样直接执行不同线程对应的function(func_arg)。</li></ul></li><li>用户进程的PCB里的pgdir元素也需要赋值，该元素存储的是用户进程使用的页目录，调用<code>create_page_dir</code>函数，如果是内核线程的话则不用，因为线程没有自己的页表空间<ul><li>调用<code>get_kernel_pages</code>在内核内存池中申请一页内存</li><li>申请的该页作为用户进程的页目录，为了保持操作系统的共享，将内核页目录项的第768项后的256项都复制给用户空间的页目录表对应的页目录项</li><li>但有一点需要更新，要把最后一项更新为页目录项自己的地址，不更新的话通过虚拟地址0xfffff000找到的就是内核自己的页表空间下的页目录了，但我们需要通过用户进程独立的页表空间也能找到用户进程的页目录</li><li>返回分配好的页目录的虚拟地址</li></ul></li><li>关闭中断，保证原子性</li><li>通过<code>list_append(&amp;thread_ready_list,&amp;thread-&gt;general_tag)</code>将用户进程添加到准备队列中，同理添加到全部队列中</li><li>重新恢复第六步之前的中断状态。</li><li>总结上述步骤：和内核线程创建相比，多给了用户进程独立的页表空间，多准备了用户空间下的虚拟地址池，通过位图管理。添加到准备队列后，会被schedule调度，schedule中会通过<code>process_activate</code>函数激活进程页表，并切换进程上处理器，该函数内容如下：<ul><li>调用<code>page_dir_activate(p_thread);</code>函数激活进程页表，其实就是将对应页目录的物理地址加载到cr3寄存器中</li><li>调用<code>void update_tss_esp(struct task_struct* pthread)</code>更新tss中的esp0字段的值为pthread的0级栈，其实就是进程PCB的页框顶部</li></ul></li><li>如果轮训到了用户进程，上一个任务的schedule的最后会通过<code>switch_to(cur, next);</code>将用户进程提到处理器，也就是执行kernel_thread函数，而在用户进程里，就进一步去执行start_process(filename)函数</li><li>介绍<code>void start_process(void* filename_)</code>函数，构建用户进程的上下文信息<ul><li>将用户进程的内核栈设置指向中断栈，原因：用户进程的三个特征是用特权级3的栈，处于特权级3，有自己独立的页表空间； 目前只完成了有自己独立的页表空间，调度器在内核中实现，要将特权级0降到特权级3，通过中断返回指令iretd “欺骗” cpu </li><li>让用户进程PCB的内核栈指向中断栈，而不是之前的线程栈</li><li>根据中断栈的数据结构，初始化栈内各个元素，例如各通用寄存器初始化为0；gs初始化为0因为操作系统不允许用户访问显存；ds、es、fs，ss初始化为SELECTOR_U_DATA，也就是用户空间的数据段选择子，该选择子的RPL为3；cs寄存器初始化SELECTOR_U_CODE，eip初始化为要执行的用户进程的实际函数function的地址；为esp栈空间设置为0xc0000000；</li><li>上述SELECTOR_U_DATA，用户空间的数据段选择子，可以在gdt中找到，在<code>tss_init</code>中设置了tss段，DPL为3的用户代码段、DPL为3的用户数据段</li><li>将用户进程PCB的中断栈赋给此时的esp，并调用<code>intr_exit</code>函数，该函数在kernel.S中定义，就是中断调用后，恢复上下文的函数，通过调用该函数模拟此时是从中断返回的状态，最后通过iret指令将用户进程PCB内核栈（中断栈）中的段寄存器，代码寄存器cs，eip寄存器更新，此时这几个寄存器内的RPL，DPL都为3</li><li>上述，即通过假装从中断返回，完成了将特权级从0降低到3的过程。</li></ul></li></ol><p><strong>进一步地，考虑有三个任务，分别是内核线程A，用户进程B，内核线程C，调度的时候是栈是如何切换的呢？？</strong><br>要从三个任务都还没开始过的时候考虑！包括main函数也是主线程，其实一共有四个任务</p><ol><li>创建A,B,C，内核栈初始化为PCB线程栈的位置，各个线程所用的栈都是在自己的PCB中</li><li>main线程执行完毕后，（我们在loader进入main函数时，已经将esp移到0xc009f000处，作为main主线程的PCB的栈顶，PCB占一页，所以主线程PCB起始地址为0xc009e000），进入到schedule进行调度，进而执行switch_to保护上下文，这里有个关键的操作是，根据ABI规则push4个寄存器用来保护上下文，将最新的栈顶指针存放到PCB的第一个元素，也就是内核栈selt_kstack中，那么此时main线程的内核栈指向的就是切换前自己PCB中栈顶esp的位置。</li><li>switch_to通过参数传递，切换到下一个任务，也就是内核线程A，将此时系统的esp更新为A的PCB中的第一个元素内核栈selt_kstack指向的位置；如果A是第一次被调度执行，那么此时A的内核栈指向PCB中线程栈的位置，然后根据线程栈的结构不断pop，最后通过ret将要执行A的函数加载到处理器中。</li><li>同样地，A时间片到期后要进入调度函数，通过switch_to保护上下文，将最新的栈顶指针存放到PCB的第一个元素内核栈中，此时A的PCB的内核栈不再和初始化时一样指向线程栈的位置</li><li>这里进一步推测，我们不确定A线程函数操作了什么，可能包含对栈的操作，那么此时PCB结构中线程栈的结构就会被破坏，但是线程栈也已经没用了，因为它最大的作用就是在第一次执行线程的时候帮助找到函数的入口位置，而后下处理器时，只要根据ABI规则保护好寄存器，并将最新的栈顶存在PCB的内核栈位置即可。也就是说，PCB的线程栈主要在第一次调用时帮助找到函数入口，后面主要充当的是线程自己的栈的作用以及用来保护上下文，结构不一定和之前的线程栈结构一样。</li><li>切换到用户进程B时，要激活进程页表，并更新tss中的esp0字段，其实就是将esp0更新为PCB的页框顶，ss0在tss初始化时，因为使用的是平坦模型，所以统一默认就是内核数据段&#x2F;栈段，不需要改变。</li><li>B的PCB中内核栈指向中断栈的位置，此时会将esp也指向中断栈，通过模仿中断返回，不断将设定好的寄存器内容pop到各个寄存器中。</li><li>通过“模仿”中断返回，完成特权级从0到3的变化，此时几个段寄存器内的RPL，DPL都为3，因为进入到了用户态，所以此时进程是有自己用户态下的栈的，物理内存是多少不知道，因为关键代码是：<code>proc_stack-&gt;esp = (void*)((uint32_t)get_a_page(PF_USER,USER_STACK3_VADDR) + PG_SIZE)</code>，因此用户态下的栈是在用户虚拟内存0xc0000000以下一页的地方，对应的物理内存是多少是不固定的。同时段寄存器ss也会变成用户态数据段的选择子。</li><li>用户进程B的时间片结束后，要进入调度函数，如果下一个任务也是用户进程，那么操作和第6和7步一样；如果下一个任务是内核线程C，那么此时就需要完成从特权级3到特权级0的变化</li><li>因为下一个任务是内核线程C，所以不需要切换tss，只需要把页目录更换为内核的页目录，然后通过中断进入switch_to进入上下文的保存（通过中断，用户进程可以暂时拥有特权级0的权限），当中断发生在特权级3时，tss就派上用场了，处理器会自动将tss中的ss0和esp0取出，用以作为处理中断的堆栈，也就是此时的esp变成了用户进程B的PCB的页框顶部，然后通过中断的上下文保护，switch_to的上下文保护，将用户进程B的状态保存到用户进程在特权级0下的栈中，随后进行任务切换。</li><li>随着不断地调度进行，假设现在又轮到线程A切换到进程B，那么此时的操作和上述45678步差不多，只不过此时通过switch_to以及中断退出的上下文恢复不是去执行初始化时候的<code>start_process(filename)</code>函数，而是直接把用户进程的上一个状态的上下文恢复到对应寄存器中。</li></ol><p><strong>其实说到底都是靠中断</strong><br><strong>所以目前实现的只有内核线程和用户进程，那用户线程或者内核进程呢？</strong></p><p>真正的用户进程是在哪里实现的，也是在main里直接调用吗？和文件系统有关，以后研究。</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第十章 输入输出系统</title>
    <link href="/2025/01/04/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <url>/2025/01/04/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="10-1-锁"><a href="#10-1-锁" class="headerlink" title="10.1 锁"></a>10.1 锁</h2><p>锁的出现是用来解决多个线程访问公共资源的问题<br>公共资源：可以是公共的内存、硬件等，总之就是被许多任务共享的一套资源<br>临界区：指程序中那些访问公共资源的指令代码<br>互斥：是指任何时刻公共资源只能被单个任务独享，即只能有一个任务在自己的临界区执行（执行临界区的代码也就是访问公共资源），关中断是实现互斥最简单的方法<br>竞争条件：也就是多个任务竞争锁的条件</p><p>信号量：是多线程编程中的重要同步工作，锁是其中的一个应用，信号量用于保证线程顺序执行，资源访问控制，线程间协调，启动与终止控制，构建灵活、高效的并发机制。</p><p>在完成锁的设计之前，我们先完成线程阻塞和解除阻塞的函数<br>thread.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*当前线程将自己阻塞，并把线程状态标记为stat*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_block</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> task_status stat)</span>&#123;<br>    <span class="hljs-comment">//只有TASK_BLOCKED TASK_WAITING TASK_HANGING 这三种状态，才不会被调度</span><br>    ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || stat == TASK_HANGING));<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();       <span class="hljs-comment">//关中断</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur</span> =</span> running_thread();<br>    <span class="hljs-comment">//更改当前线程的状态，这样再进行schedule就不会放到准备队列中，完成阻塞</span><br>    cur -&gt; status = stat;<br>    schedule();<br>    <span class="hljs-comment">//下面代码在阻塞解除之前都不会执行</span><br>    intr_set_status(old_status);<br>&#125;<br><br><span class="hljs-comment">/*将线程pthread解除阻塞*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_unblock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* pthread)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();<br>    ASSERT(((pthread-&gt;status == TASK_BLOCKED) || (pthread-&gt;status == TASK_WAITING) || (pthread-&gt;status == TASK_HANGING)));<br>    <span class="hljs-keyword">if</span>(pthread-&gt;status != TASK_READY)<br>    &#123;<br>    <span class="hljs-comment">//被阻塞线程 不应该存在于就绪队列中）</span><br>    ASSERT(!elem_find(&amp;thread_ready_list,&amp;pthread-&gt;general_tag));<br>    <span class="hljs-keyword">if</span>(elem_find(&amp;thread_ready_list,&amp;pthread-&gt;general_tag))<br>        PANIC(<span class="hljs-string">&quot;thread_unblock: blocked thread in ready_list\n&quot;</span>); <span class="hljs-comment">//debug.h中定义过</span><br>    <span class="hljs-comment">//让阻塞了很久的任务放在就绪队列最前面</span><br>    list_push(&amp;thread_ready_list,&amp;pthread-&gt;general_tag);<br>    <span class="hljs-comment">//状态改为就绪态</span><br>    pthread-&gt;status = TASK_READY;<br>    &#125;<br>    intr_set_status(old_status);<br>&#125;<br></code></pre></td></tr></table></figure><p>在时间片内，线程被换下处理器都是出于主动或资源，因此只有线程自己才能阻塞自己，但阻塞后需要别的线程将自己唤醒<br>接下来完成锁的实现<br>sync.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>;</span>  <span class="hljs-comment">// 前向声明，避免包含 thread.h</span><br><br><span class="hljs-comment">/*信号量结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span>&#123;</span><br>    <span class="hljs-type">uint8_t</span> value;  <span class="hljs-comment">//信号量值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">waiters</span>;</span>    <span class="hljs-comment">//处于该信号量值上等待阻塞的所有线程</span><br>&#125;;<br><br><span class="hljs-comment">/*锁结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">holder</span>;</span> <span class="hljs-comment">//锁的持有者</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> <span class="hljs-title">semaphore</span>;</span> <span class="hljs-comment">//锁的信号量</span><br>    <span class="hljs-type">uint32_t</span> holder_repeat_nr;  <span class="hljs-comment">//锁的持有者重复申请锁的次数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>sync.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sync.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><br><span class="hljs-comment">/*初始化信号量*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sema_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore* psema, <span class="hljs-type">uint8_t</span> value)</span>&#123;<br>    psema -&gt; value = value;<br>    list_init(&amp;psema -&gt; waiters);<br>&#125;<br><br><span class="hljs-comment">/*初始化锁*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock* plock)</span>&#123;<br>    plock -&gt; holder = <span class="hljs-literal">NULL</span>;<br>    plock -&gt; holder_repeat_nr = <span class="hljs-number">0</span>;<br>    sema_init(&amp;plock -&gt; semaphore, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*信号量down操作*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sema_down</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore* psema)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();<br>    <span class="hljs-keyword">while</span>(psema -&gt; value == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//若value为0，表示已经被别人持有</span><br>        ASSERT(!elem_find(&amp;psema-&gt;waiters,&amp;(running_thread()-&gt;general_tag)));<br>        <span class="hljs-comment">//当前的线程不应该在信号量的waiters队列中</span><br>        <span class="hljs-keyword">if</span>(elem_find(&amp;psema-&gt;waiters,&amp;(running_thread()-&gt;general_tag)))<br>        PANIC(<span class="hljs-string">&quot;sema_down: seme_down thread already in ready_list\n&quot;</span>);<br>        list_append(&amp;psema-&gt;waiters,&amp;(running_thread()-&gt;general_tag));  <span class="hljs-comment">//添加到等待队列</span><br>    thread_block(TASK_BLOCKED);                                     <span class="hljs-comment">//阻塞并切换线程</span><br>    &#125;<br>    <span class="hljs-comment">//若value为1或者被唤醒后执行下述代码</span><br>    psema -&gt; value--;<br>    ASSERT(psema-&gt;value == <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//恢复之前的中断状态</span><br>    intr_set_status(old_status);<br>&#125;<br><br><span class="hljs-comment">//信号量value增加,唤醒线程，把它重新加入准备队列中</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sema_up</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore* psema)</span><br>&#123;<br>    <span class="hljs-comment">//关中断，保证原子操作</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();<br>    ASSERT(!psema-&gt;value);<br>    <span class="hljs-keyword">if</span>(!list_empty(&amp;psema-&gt;waiters))<br>    &#123;<br>    thread_unblock((<span class="hljs-keyword">struct</span> task_struct*)((<span class="hljs-type">uint32_t</span>)list_pop(&amp;psema-&gt;waiters) &amp; <span class="hljs-number">0xfffff000</span>));<br>    &#125;<br>    psema-&gt;value++;<br>    ASSERT(psema-&gt;value == <span class="hljs-number">1</span>);<br>    intr_set_status(old_status);<br>&#125;<br><br><span class="hljs-comment">//获取锁资源</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock* plock)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(plock-&gt;holder != running_thread())<br>    &#123;<br>    sema_down(&amp;plock-&gt;semaphore);<span class="hljs-comment">//如果已经被占用 则会被阻塞</span><br>    plock-&gt;holder = running_thread();<span class="hljs-comment">//之前被阻塞的线程 继续执行 没被阻塞直接继续即可</span><br>    ASSERT(!plock-&gt;holder_repeat_nr);<br>    plock-&gt;holder_repeat_nr = <span class="hljs-number">1</span>;<span class="hljs-comment">//访问数为1</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>++plock-&gt;holder_repeat_nr;<br>&#125;<br><br><span class="hljs-comment">//释放锁资源</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lock* plock)</span><br>&#123;<br>    ASSERT(plock-&gt;holder == running_thread());<span class="hljs-comment">//释放锁的线程必须是其拥有者</span><br>    <span class="hljs-keyword">if</span>(plock-&gt;holder_repeat_nr &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">//减少到的当前一个线程 次数只有一次访问这个锁时 才允许到下面</span><br>    &#123;<br>    --plock-&gt;holder_repeat_nr;<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ASSERT(plock-&gt;holder_repeat_nr == <span class="hljs-number">1</span>);<span class="hljs-comment">//举个例子 该线程在拥有锁时 两次获取锁 第二次肯定是无法获取到的</span><br>    <span class="hljs-comment">//但是必须同样也要有两次release才算彻底释放 不然只有第一次的relase</span><br>    <span class="hljs-comment">//第二次都不需要release 就直接释放了 肯定是不行的</span><br>    plock-&gt;holder = <span class="hljs-literal">NULL</span>;<br>    plock-&gt;holder_repeat_nr = <span class="hljs-number">0</span>;<br>    sema_up(&amp;plock-&gt;semaphore);   <br>&#125;<br><br></code></pre></td></tr></table></figure><p>分步讲解一个线程如何获取锁，以看清上述代码：</p><ol><li>首先需要定义一个锁，该锁用来管理某个公共资源，因此需要初始化。理论上该锁应该是全局的。</li><li>某个线程想获得锁，进入临界区，可以调用<code>void lock_acquire(struct lock* plock)</code>函数获取锁的资源<ul><li>判断当前锁的持有者是不是当前申请获得锁的线程</li><li>如果是，说明是这个线程在已经持有锁的情况下重复申请锁，因此锁的holder_repeat_nr需要自加</li><li>如果不是，则该线程调用<code>void sema_down(struct semaphore* psema)</code>函数<ul><li>判断信号量是否已经为0，是则说明锁已经被别人持有，将该线程添加到信号量为0的等待队列中并阻塞</li><li>如果不是，说明信号量为1，要么是锁还未被人持有，要么是锁被人持有后又被释放了</li><li>若value为1或者上述线程阻塞又被唤醒后，执行让信号量自减，说明锁被该线程持有</li><li>恢复之前中断的状态</li></ul></li><li>线程成功获取锁，将锁的持有者改为当前线程，并设置holder_repeat_nr为1</li></ul></li><li>线程执行完临界区后，需要及时释放锁，调用<code>void lock_release(struct lock* plock)</code><ul><li>如果锁的holder_repeat_nr大于1，说明是在获得锁之后重复申请了至少一次的锁，那么释放锁的操作只要让holder_repeat_nr自减就可以</li><li>如果锁的holder_repeat_nr等于1，则清空锁的持有者，并置holder_repeat_nr为0</li><li>调用<code>void sema_up(struct semaphore* psema)</code>使信号量增加<ul><li>解除阻塞，解除的对象是信号量为0的等待队列中的队首的线程</li><li>让信号量自加为1，说明锁可用</li></ul></li></ul></li></ol><h2 id="10-2-用锁实现终端输出"><a href="#10-2-用锁实现终端输出" class="headerlink" title="10.2 用锁实现终端输出"></a>10.2 用锁实现终端输出</h2><p>上一节实现了锁，这一节来应用锁<br>我们的系统只有一个终端，因此所有输出内容都在这个终端上，因此终端上的显示内容也就作为了公共资源，需要加锁<br>console.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;console.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../thread/sync.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">console_lock</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">console_init</span><span class="hljs-params">()</span><br>&#123;<br>    lock_init(&amp;console_lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">console_acquire</span><span class="hljs-params">()</span><br>&#123;<br>    lock_acquire(&amp;console_lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">console_release</span><span class="hljs-params">()</span><br>&#123;<br>    lock_release(&amp;console_lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">console_put_str</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span><br>&#123;<br>    console_acquire();<br>    put_str(str);<br>    console_release();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">console_put_int</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> num)</span><br>&#123;<br>    console_acquire();<br>    put_int(num);<br>    console_release();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">console_put_char</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> chr)</span><br>&#123;<br>    console_acquire();<br>    put_char(chr);<br>    console_release();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="10-3-从键盘上获取输入"><a href="#10-3-从键盘上获取输入" class="headerlink" title="10.3 从键盘上获取输入"></a>10.3 从键盘上获取输入</h2><p>涉及到键盘驱动，以及环形输入缓冲区的设计，即生产者-消费者模型，先暂时跳过</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第九章 线程</title>
    <link href="/2025/01/02/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <url>/2025/01/02/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="9-1-进程、线程、调度的一些理解"><a href="#9-1-进程、线程、调度的一些理解" class="headerlink" title="9.1 进程、线程、调度的一些理解"></a>9.1 进程、线程、调度的一些理解</h2><ol><li>通俗地讲，一个进程可以完成一项工作，执行这项工作的程序就是进程，该工作可能由很多个子工作构成，我们需要让进程尽可能多的“同时”完成多个子工作，提升效率，完成这些子工作的程序就叫做线程。</li><li>单核CPU在一个时刻只能执行一个线程，通过多任务调度看起来像是并行执行多个线程，其实是因为不同线程快速切换才给人这种错觉，多核CPU在一个时刻可以真正并行执行多个线程。</li><li>上述多任务调度是由任务调度器来控制的，任务调度器是操作系统的功能之一，通过不同的调度算法，例如最经典的时间片轮转算法完成不同任务的调度。</li><li>任务调度的调度单元是执行流，其实每个进程或线程都是一段执行流，在调度时要保存好执行流的上下文环境，例如栈、寄存器映像、内存等。我们要给任何想单独上处理器的代码块准备好以来的上下文环境，使之成为执行流，即调度单元。</li><li>任务调度必定涉及到不同任务的切换，切换就会有损耗。</li><li>进程的创建需要大量资源，程序必须在获得运行所需要的资源后才能成为进程，包括进程所使用的栈、寄存器映像等。其实如果想要实现多并发的效果，那么多进程就可以实现，但是进程的创建都需要大量的资源（例如：PCB、硬盘资源等），因此开销就变大了；而且创建时需要大量的资源，也是需要更多的时间，因此导致速度变慢了，因此需要线程进行提速，提出了可以 共享 两字，先创建一个进程并且分配好资源，后续创建的进程创建时只需要分配一个简单PCB，然后 共享 第一个进程的文件描述表、内存硬盘等资源，从而使开销减小、速度更快。而后续的进程便是轻量级进程—-线程。</li><li>可以认为，线程是在进程基础之上的二次并发。</li><li>进程可以分为单线程进程和多线程进程。进程&#x3D;线程+资源</li><li>线程就是执行流，真正上处理器运行的其实都叫做线程，进程中的线程才是一个个的执行实体、执行流，因此，经调度器送上处理器执行的程序都是线程。</li><li>进程是操作系统进行资源分配的基本单位，线程是操作系统进行调度的基本单位。</li><li>我们接下来要实现的代码，是在内核中实现线程，即线程表在内核中，线程由操作系统负责调度。</li></ol><h2 id="9-2-在内核空间实现线程"><a href="#9-2-在内核空间实现线程" class="headerlink" title="9.2 在内核空间实现线程"></a>9.2 在内核空间实现线程</h2><p>操作系统为每个进程提供一个PCB，它就是进程的身份证，用来记录与此进程相关的信心，例如进程状态，PID，优先级等</p><p>thread.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*自定义一个通用函数类型，将在很多线程函数中作为形参类型*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread_func</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span>;<br><br><span class="hljs-comment">/*存储进程或线程，即统称为任务的状态*/</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">task_status</span></span><br><span class="hljs-class">&#123;</span><br>    TASK_RUNNING, <span class="hljs-comment">// 0</span><br>    TASK_READY,   <span class="hljs-comment">// 1</span><br>    TASK_BLOCKED, <span class="hljs-comment">// 2</span><br>    TASK_WAITING, <span class="hljs-comment">// 3</span><br>    TASK_HANGING, <span class="hljs-comment">// 4</span><br>    TASK_DIED     <span class="hljs-comment">// 5</span><br>&#125;;<br><br><span class="hljs-comment">/*程序的中断栈，用于发生中断时保存程序的上下文，对应kernel.S中intr%1entry里压入栈的数据*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intr_stack</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> vec_no; <span class="hljs-comment">//中断号</span><br>    <span class="hljs-type">uint32_t</span> edi;<br>    <span class="hljs-type">uint32_t</span> esi;<br>    <span class="hljs-type">uint32_t</span> ebp;<br>    <span class="hljs-type">uint32_t</span> esp_dummy;<br>    <span class="hljs-type">uint32_t</span> ebx;<br>    <span class="hljs-type">uint32_t</span> edx;<br>    <span class="hljs-type">uint32_t</span> ecx;<br>    <span class="hljs-type">uint32_t</span> eax;<br>    <span class="hljs-type">uint32_t</span> gs;<br>    <span class="hljs-type">uint32_t</span> fs;<br>    <span class="hljs-type">uint32_t</span> es;<br>    <span class="hljs-type">uint32_t</span> ds;<br>    <span class="hljs-comment">//以下由cpu从低特权级进入高特权级时压入</span><br>    <span class="hljs-type">uint32_t</span> err_code;<br>    <span class="hljs-type">void</span> (*eip) (<span class="hljs-type">void</span>);        <span class="hljs-comment">//这里声明了一个函数指针 </span><br>    <span class="hljs-type">uint32_t</span> cs;<br>    <span class="hljs-type">uint32_t</span> eflags;<br>    <span class="hljs-type">void</span>* esp;<br>    <span class="hljs-type">uint32_t</span> ss;<br>&#125;;<br><br><span class="hljs-comment">/*线程栈，保护线程环境*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_stack</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span> ebp;   <span class="hljs-comment">//根据ABI规则，在c语言的函数需要调用汇编编写的函数时，要保护ebp，ebx，edi，esi，esp这五个寄存器的值</span><br>    <span class="hljs-type">uint32_t</span> ebx;   <span class="hljs-comment">//esp的值通过调用约定保证</span><br>    <span class="hljs-type">uint32_t</span> edi;<br>    <span class="hljs-type">uint32_t</span> esi;<br><br>    <span class="hljs-type">void</span> (*eip) (thread_func* func,<span class="hljs-type">void</span>* func_arg); <span class="hljs-comment">//和下面的相互照应 以ret 汇编代码进入kernel_thread函数调用</span><br>    <br>    <span class="hljs-type">void</span> (*unused_retaddr);                         <span class="hljs-comment">//占位数 在栈顶站住了返回地址的位置 因为是汇编ret </span><br>    thread_func* function;                          <span class="hljs-comment">//进入kernel_thread要调用的函数地址</span><br>    <span class="hljs-type">void</span>* func_arg;      <span class="hljs-comment">//参数指针</span><br>&#125;;<br><br><span class="hljs-comment">/*PCB结构体，存储进程或线程的基本信息*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span>* self_kstack;                          <span class="hljs-comment">//当前线程对应的内核栈</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">task_status</span> <span class="hljs-title">status</span>;</span>                        <span class="hljs-comment">//线程状态</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];<br>    <span class="hljs-type">uint8_t</span> priority;      <span class="hljs-comment">//特权级</span><br>    <span class="hljs-type">uint8_t</span> ticks;              <span class="hljs-comment">//每次在处理器上执行的时间滴答数</span><br>    <span class="hljs-type">uint32_t</span> elapsed_ticks;     <span class="hljs-comment">//此任务执行了多久，即此任务从上cpu运行后至今占用了多少cpu滴答数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">general_tag</span>;</span>       <span class="hljs-comment">//用于线程在一般的队列中的节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span> <span class="hljs-title">all_list_tag</span>;</span>      <span class="hljs-comment">//用于线程在线程队列中的节点</span><br>    <span class="hljs-type">uint32_t</span>* pgdir;        <span class="hljs-comment">//进程自己页表的虚拟地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtual_addr</span> <span class="hljs-title">userprog_vaddr</span>;</span>     <span class="hljs-comment">//用户进程的虚拟地址池</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mem_block_desc</span> <span class="hljs-title">u_block_desc</span>[<span class="hljs-title">DESC_CNT</span>];</span>   <span class="hljs-comment">//用户进程内存块描述符</span><br>    <span class="hljs-type">uint32_t</span> stack_magic;      <span class="hljs-comment">//越界检查  因为我们pcb上面的就是我们要用的栈了 到时候还要越界检查</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>thread.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*由kernel_thread去执行funciton*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kernel_thread</span><span class="hljs-params">(thread_func* function, <span class="hljs-type">void</span>* func_arg)</span>&#123;<br>    intr_enable();      <span class="hljs-comment">//在执行线程的函数前要打开中断，避免时钟中断被屏蔽，导致无法通过时钟中断调度其它线程</span><br>    function(func_arg);<br>&#125;<br><br><span class="hljs-comment">/*创建线程栈，将要执行的函数和对应传参放入栈中*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* pthread, thread_func function, <span class="hljs-type">void</span>* func_arg)</span>&#123;<br>    pthread -&gt; self_kstack -= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> intr_stack);    <span class="hljs-comment">//预留中断栈的位置</span><br>    pthread -&gt; self_kstack -= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> thread_stack);  <span class="hljs-comment">//预留线程栈的位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_stack</span>* <span class="hljs-title">kthread_stack</span> =</span> (<span class="hljs-keyword">struct</span> thread_stack*)pthread -&gt; self_kstack;  <span class="hljs-comment">//创建一个线程栈，指向对应位置，要注意C语言的结构体是从低内存排到高内存的</span><br>    kthread_stack -&gt; eip = kernel_thread;<br>    kthread_stack -&gt; function = function;<br>    kthread_stack -&gt; func_arg = func_arg;<br>    kthread_stack -&gt; ebp = kthread_stack -&gt; ebx = kthread_stack -&gt; esi = kthread_stack -&gt; edi = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*初始化线程的基本信息*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* pthread, <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> prio)</span>&#123;<br>    <span class="hljs-built_in">memset</span>(pthread, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*pthread));   <br>    pthread -&gt; pid = allocate_pid();<br>    <span class="hljs-built_in">strcpy</span>(pthread -&gt; name, name);<br>    <span class="hljs-keyword">if</span>(pthread == main_thread)&#123;<br>        pthread -&gt; status = TASK_RUNNING;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        pthread -&gt; status = TASK_READY;<br>    &#125;<br>    pthread -&gt; ticks = prio;<br>    pthread -&gt; elapsed_ticks = <span class="hljs-number">0</span>;<br>    pthread -&gt; pgdir = <span class="hljs-literal">NULL</span>;<br>    pthread -&gt; priority = prio;<br>    pthread -&gt; stack_magic = <span class="hljs-number">0x19870916</span>;    <span class="hljs-comment">//魔数，可以随意设置</span><br>    pthread -&gt; self_kstack = (<span class="hljs-type">uint32_t</span>*)((<span class="hljs-type">uint32_t</span>)pthread + PG_SIZE);  <span class="hljs-comment">//设置线程在内核态下栈顶的位置</span><br>&#125;<br><br><span class="hljs-comment">/*创建优先级为prio的线程，线程名为name，所实行的函数为function(func_arg)*/</span><br><span class="hljs-comment">/*无论是用户的还是内核的线程，PCB都是在内核空间的*/</span><br><span class="hljs-keyword">struct</span> task_struct* <span class="hljs-title function_">thread_start</span><span class="hljs-params">(<span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> prio, thread_func function, <span class="hljs-type">void</span>* func_arg)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">thread</span> =</span> get_kernel_pages(<span class="hljs-number">1</span>);   <span class="hljs-comment">//从内核池分配一页用来存放PCB指针thread，此时thread指向PCB的最低地址</span><br>    init_thread(thread, name, prio);    <span class="hljs-comment">//  初始化线程的基本信息</span><br>    thread_create(thread, function, func_arg);  <span class="hljs-comment">//创建对应的线程栈</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %0,%%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret&quot;</span> : : <span class="hljs-string">&quot;g&quot;</span>(thread-&gt;self_kstack) :<span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">//栈顶的位置为 thread-&gt;self_kstack </span><br>    <span class="hljs-keyword">return</span> thread;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>本小节只是让线程跑起来，因此比较简陋，代码后面还会修改，逻辑是：</p><ol><li>调用<code>struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg)</code>，创建优先级为prio的线程，线程名为name，所实行的函数为function(func_arg)，具体流程为：<ul><li>从内核池分配一页用来存放PCB指针thread，此时thread指向PCB的最低地址</li><li>调用<code>void init_thread(struct task_struct* pthread, char* name, int prio)</code>初始化线程的基本信息<ul><li>其中<code>pthread -&gt; self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE)</code>设置线程在内核态下栈顶的位置</li><li>其中<code>pthread -&gt; stack_magic = 0x19870916;</code>是魔数，防止入栈操作过多破坏PCB低处的线程信息</li></ul></li><li>调用<code>void thread_create(struct task_struct* pthread, thread_func function, void* func_arg)</code>创建对应的线程栈，将要执行的函数和对应传参放入栈中<ul><li>预留中断栈和线程栈的位置</li><li>给线程栈里的值进行赋值，其中<code>kthread_stack -&gt; eip = kernel_thread;</code> <code>kthread_stack -&gt; function = function;</code> <code>kthread_stack -&gt; func_arg = func_arg;</code> 用来给线程栈要调用的函数以及相应的函数参数赋值，由kernel_thread去执行funciton</li></ul></li><li>这里暂时用汇编测试，<code>asm volatile(&quot;movl %0,%%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret&quot; : : &quot;g&quot;(thread-&gt;self_kstack) :&quot;memory&quot;)</code><ul><li>现将esp赋值为thread-&gt;self_kstack，也就是线程栈的栈顶</li><li>按照线程栈的结构，根据ABI规则开始pop四个寄存器</li><li>执行 ret ，这个操作会把栈顶的数据作为返回地址送上处理器的EIP寄存器，此时栈顶数据为<code>kthread_stack -&gt; eip = kernel_thread;</code>也就是kernel_thread函数的地址，同时还会将后面的参数function，func_arg弹出，这样程序会去执行kernel_thread函数，在这个函数里执行function(func_arg);</li></ul></li></ul></li><li>可以在其他地方通过直接调用thread_start函数创建线程</li><li>只创建一个线程的话，不进行调度，其实就是创建好PCB等一系列目前没用的东西（多线程调度才用），然后通过ret去执行一个函数。</li></ol><p><strong>三个疑问</strong><br>为什么一定要用ret来实现？</p><p>为什么要用kernel_thread函数来实现，不能直接ret返回到实际要执行的函数function吗？</p><p>线程栈里的占位数有什么用？（已解决）<br>答：</p><ol><li>我们来看这句代码<code>asm volatile(&quot;movl %0,%%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret&quot; : : &quot;g&quot;(thread-&gt;self_kstack) :&quot;memory&quot;)</code>，将esp设置为线程栈的栈顶，然后按照ABI规则pop四个寄存器，然后执行ret，ret会将此时栈顶指向的数据作为返回地址加载到cs寄存器中以便下一步执行，那么ret之后栈的结构变为：栈顶esp（占位数），esp+4（函数地址function），esp+8（函数参数func_arg），由于只执行了ret，因此当前处理器会去执行ret弹出的返回地址，在这里也就是去执行kernel_thread这个函数。</li><li>我们再来看一个函数调用的时候会发生什么，执行call+函数的时候，会将函数的参数从右到左压入栈，然后压入函数的返回地址（也就是主线程执行完该函数后执行的下一句程序），该函数的参数通过返回地址+4，返回地址+8等进行获取。</li><li>结合两者看，此时cpu执行着kernel_thread函数，栈的结构为：栈顶esp（占位数），esp+4（函数地址function），esp+8（函数参数func_arg），获得该函数的参数需要通过本来压入栈的该函数的返回地址+4 +8等获得，但是这里并没有像传统的call进行压栈等操作，因此占位数的作用就是占这个位置，假装自己是返回地址，通过这个位置模仿函数调用时完成对参数的读取，这样才能获得两个参数：函数地址function，函数参数func_arg。</li></ol><h2 id="9-3-双向链表"><a href="#9-3-双向链表" class="headerlink" title="9.3 双向链表"></a>9.3 双向链表</h2><p>通过双向列表实现队列，队列在进程的就绪队列，锁的等待队列中用到，直接放代码<br>list.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;list.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><br><span class="hljs-comment">//初始化双向链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">list_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* <span class="hljs-built_in">list</span>)</span><br>&#123;<br>    <span class="hljs-built_in">list</span>-&gt;head.prev = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">list</span>-&gt;head.next = &amp;<span class="hljs-built_in">list</span>-&gt;tail;<br>    <span class="hljs-built_in">list</span>-&gt;tail.prev = &amp;<span class="hljs-built_in">list</span>-&gt;head;<br>    <span class="hljs-built_in">list</span>-&gt;tail.next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//把链表 elem放在 before前面</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">list_insert_before</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_elem* before,<span class="hljs-keyword">struct</span> list_elem* elem)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();<br>       <br>    elem-&gt;next = before;<br>    elem-&gt;prev = before-&gt;prev;<br>    before-&gt;prev-&gt;next = elem;<br>    before-&gt;prev = elem;<br>    <br>    intr_set_status(old_status); <br>    <br>&#125;<br><br><span class="hljs-comment">//添加元素到链表队首</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">list_push</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* plist,<span class="hljs-keyword">struct</span> list_elem* elem)</span><br>&#123;<br>    list_insert_before(plist-&gt;head.next,elem);<br>&#125;<br><br><span class="hljs-comment">//添加元素到链表队尾</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">list_append</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* plist,<span class="hljs-keyword">struct</span> list_elem* elem)</span><br>&#123;<br>    list_insert_before(&amp;plist-&gt;tail,elem);<br>&#125;<br><br><span class="hljs-comment">//让pelem脱离链表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">list_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_elem* pelem)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span> =</span> intr_disable();<br>    <br>    pelem-&gt;prev-&gt;next = pelem-&gt;next;<br>    pelem-&gt;next-&gt;prev = pelem-&gt;prev;<br>    <br>    intr_set_status(old_status);<br>&#125;<br><br><span class="hljs-comment">//让链表的第一个元素脱离链表</span><br><span class="hljs-keyword">struct</span> list_elem* <span class="hljs-title function_">list_pop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* plist)</span><br>&#123;<br>    ASSERT(plist-&gt;head.next != &amp;plist-&gt;tail);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">ret</span> =</span> plist-&gt;head.next;<br>    list_remove(plist-&gt;head.next);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">list_empty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* plist)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (plist-&gt;head.next == &amp;plist-&gt;tail ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">list_len</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* plist)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">next</span> =</span> plist-&gt;head.next;<br>    <span class="hljs-keyword">while</span>(next != &amp;plist-&gt;tail)<br>    &#123;<br>    next = next-&gt;next;<br>    ++ret;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">struct</span> list_elem* <span class="hljs-title function_">list_traversal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* plist,function func,<span class="hljs-type">int</span> arg)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">elem</span> =</span> plist-&gt;head.next;<br>    <span class="hljs-keyword">if</span>(list_empty(plist))<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(elem != &amp;plist-&gt;tail)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(func(elem,arg))<span class="hljs-keyword">return</span> elem;<br>    elem = elem-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">elem_find</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* plist,<span class="hljs-keyword">struct</span> list_elem* obj_elem)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">ptr</span> =</span> plist-&gt;head.next;<br>    <span class="hljs-keyword">while</span>(ptr != &amp;plist-&gt;tail)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(ptr == obj_elem)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>    ptr = ptr-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="9-4-多线程调度"><a href="#9-4-多线程调度" class="headerlink" title="9.4 多线程调度"></a>9.4 多线程调度</h2><p>thread.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">main_thread</span>;</span>        <span class="hljs-comment">//主线程main的PCB</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">thread_ready_list</span>;</span>      <span class="hljs-comment">//就绪队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">thread_all_list</span>;</span>        <span class="hljs-comment">//所有任务队列</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">pid_lock</span>;</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_elem</span>* <span class="hljs-title">thread_tag</span>;</span>        <span class="hljs-comment">//保存队列中的线程节点</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">switch_to</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* cur,<span class="hljs-keyword">struct</span> task_struct* next)</span>;<br><br><span class="hljs-comment">/*获取当前线程的PCB*/</span><br><span class="hljs-keyword">struct</span> task_struct* <span class="hljs-title function_">running_thread</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">uint32_t</span> esp;<br>    <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;mov %%esp, %0&quot;</span> : <span class="hljs-string">&quot;=g&quot;</span> (esp));<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> task_struct*)(esp &amp; <span class="hljs-number">0xfffff000</span>);     <span class="hljs-comment">//各个线程所用的栈都是在自己的PCB中，且我们设定PCB占一页，所以取高20位就是PCB的地址</span><br>&#125;<br><br><span class="hljs-comment">/*将kernel中的main函数完善为主线程*/</span><br><span class="hljs-comment">/*main早已运行，我们在loader进入kernel时mov esp， 0xc009f000, 就是预留PCB的*/</span><br><span class="hljs-comment">/*因此main的PCB地址为0xc009e000，不需要get_kernel_pages额外分配一页*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">make_main_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    main_thread = running_thread();<br>    init_thread(main_thread, <span class="hljs-string">&quot;main&quot;</span>, <span class="hljs-number">31</span>);<br>    <span class="hljs-comment">//main函数是当前线程，肯定不在准备队列中，因此添加到全部队列中</span><br>    ASSERT(!elem_find(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag));  <br>    list_append(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag);       <br>&#125;<br><br><span class="hljs-comment">/*创建优先级为prio的线程，线程名为name，所实行的函数为function(func_arg)*/</span><br><span class="hljs-comment">/*无论是用户的还是内核的线程，PCB都是在内核空间的*/</span><br><span class="hljs-keyword">struct</span> task_struct* <span class="hljs-title function_">thread_start</span><span class="hljs-params">(<span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> prio, thread_func function, <span class="hljs-type">void</span>* func_arg)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">thread</span> =</span> get_kernel_pages(<span class="hljs-number">1</span>);   <span class="hljs-comment">//从内核池分配一页用来存放PCB指针thread，此时thread指向PCB的最低地址</span><br>    init_thread(thread, name, prio);    <span class="hljs-comment">//  初始化线程的基本信息</span><br>    thread_create(thread, function, func_arg);  <span class="hljs-comment">//创建对应的线程栈</span><br><br>    ASSERT(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));    <span class="hljs-comment">//确保该线程之前就不在就绪队列中</span><br>    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);       <span class="hljs-comment">//加入就绪队列</span><br><br>    ASSERT(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));    <span class="hljs-comment">//确保该线程之前就不在全部队列中</span><br>    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);       <span class="hljs-comment">//加入全部线程队列</span><br><br>    <span class="hljs-keyword">return</span> thread;<br>&#125;<br></code></pre></td></tr></table></figure><p>调度器主要任务是读写就绪队列，增删里面的节点，节点是PCB里的general_tag，我们的调度机制才用轮询调度，也就是按顺序一个一个执行，线程的prio越大，优先级越高，tick越大，每发生一次时钟中断，tick–，当tick为0时调度器把当前线程换下，选择另一个线程上处理器<br>完整的调度过程需要三部分配合：</p><ol><li>时钟中断处理函数</li><li>调度器schedule</li><li>任务切换函数switch_to</li></ol><p>首先看时钟中断处理函数<br>timer.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> ticks;     <span class="hljs-comment">//ticks是内核开启时钟中断以来总共的滴答数</span><br><br><span class="hljs-comment">/*时钟的中断处理函数*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">intr_timer_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur_thread</span> =</span> running_thread();  <span class="hljs-comment">//获取当前线程的PCB</span><br>    ASSERT(cur_thread -&gt; stack_magic == <span class="hljs-number">0x19870916</span>);        <span class="hljs-comment">//判断该线程的线程栈是否有溢出</span><br>    cur_thread -&gt; elapsed_ticks++;      <span class="hljs-comment">//让当前线程占用cpu的总时间++</span><br>    ticks++;        <span class="hljs-comment">//ticks是内核开启时钟中断以来总共的滴答数</span><br>    <span class="hljs-comment">//如果当前线程的tick用完了，则下CPU，进入调度函数，如果没用完，则继续该线程，并让该线程的tick自减</span><br>    <span class="hljs-keyword">if</span>(cur_thread -&gt; ticks == <span class="hljs-number">0</span>)&#123;<br>        schedule();<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cur_thread -&gt; ticks--;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    put_str(<span class="hljs-string">&quot;timer_init start!\n&quot;</span>);<br>    frequency_set(COUNTER0_PORT,COUNTER0_NO,READ_WRITE_LATCH,COUNTER_MODE,COUNTER0_VALUE);<br>    register_handler(<span class="hljs-number">0x20</span>, intr_timer_handler);      <span class="hljs-comment">//注册时钟中断处理程序的代码</span><br>    put_str(<span class="hljs-string">&quot;timer_init done!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>interrupt.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*在中断处理程序数组第vector_no个元素中注册安装中断处理程序funciton*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">register_handler</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> vector_no, intr_handler function)</span>&#123;<br>    idt_table[vector_no] = function;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成时钟中断函数的注册，即写在中断描述符表idt里，当发生时钟中断时，中断向量号为0x20，在idt找到对应的函数入口去执行，每来一次中断便让当前线程的ticks–</p><p>实现任务调度schedule<br>thread.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*实现任务调度:将当前线程换下处理器，并在就绪队列中找到下一个可运行的线程，放上处理器*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span>&#123;<br>    ASSERT(intr_get_status() == INTR_OFF);      <span class="hljs-comment">//？？？为什么要关中断，在哪里关了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur</span> =</span> running_thread();     <span class="hljs-comment">//获取当前线程的PCB</span><br>    <span class="hljs-keyword">if</span>(cur -&gt; status == TASK_RUNNING)&#123;<br>        <span class="hljs-comment">//如果当前线程只是因为时间片到期了，则将其重新放到准备队列中，</span><br>        ASSERT(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));<br>        list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);<br>        cur -&gt; ticks = cur -&gt; priority;<br>        cur -&gt; status = TASK_READY;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//如果当前线程还需要某些条件才能重新上CPU，则暂时不放入准备队列中</span><br>    &#125;<br>    ASSERT(!list_empty(&amp;thread_ready_list));    <span class="hljs-comment">//为了避免队列里无线程可用的情况，暂时用断言来保证</span><br>    <span class="hljs-comment">//获取准备队列中的队首线程PCB，将其状态设置为running，并通过switch_to切换寄存器影响</span><br>    thread_tag = list_pop(&amp;thread_ready_list);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">next</span> =</span> (<span class="hljs-keyword">struct</span> task_struct*)((<span class="hljs-type">uint32_t</span>)thread_tag &amp; <span class="hljs-number">0xfffff000</span>);<br>    next -&gt; status = TASK_RUNNING;<br>    switch_to(cur, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>当前线程的ticks为0时，时钟中断会触发schedule函数，该函数将当前线程的generel_tag看情况判断是否重新加入就绪队列中，并把ticks重新更新为prio以便下次轮询到这个线程时能正常使用，并把该线程的状态改为准备态，将该线程从就绪队列中pop出来，把pop后就绪队列的队首的线程作为下一个要上处理器的线程next，更改next的状态为运行态，调用switch_to函数完成切换。</p><p>实现任务切换函数switch_to<br>switch.S</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]<br><span class="hljs-meta">section</span> .text<br><span class="hljs-meta">global</span> switch_to<br><span class="hljs-symbol">switch_to:</span><br>    <span class="hljs-comment">;栈中此处是返回地址</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">esp</span> + <span class="hljs-number">20</span>] <span class="hljs-comment">;得到参数cur，参数cur是当前线程的PCB地址</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">eax</span>], <span class="hljs-built_in">esp</span>  <span class="hljs-comment">;把当前栈顶指针存放到cur中，即存放到当前线程PCB的第一个元素，内核栈selt_kstack中</span><br>    <span class="hljs-comment">;--------------以上是保存当前线程的上下文，下面是恢复下一个线程的上下文-----------------</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">esp</span> + <span class="hljs-number">24</span>] <span class="hljs-comment">;得到栈中的参数next，next是下一个线程的PCB地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, [<span class="hljs-built_in">eax</span>]  <span class="hljs-comment">;PCB的第一个成员是当前线程的内核栈，此时esp将会指向下一个线程的内核栈</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">ret</span>             <span class="hljs-comment">;将当前栈顶的值作为返回地址加载到处理器的eip寄存器中，从而使下一个线程的代码恢复执行</span><br></code></pre></td></tr></table></figure><p>主要是要做到保护上下文的同时进行切换，我们举个例子来描述切换的过程，从线程cur切换到next</p><ol><li>伴随着每次的时间中断，cur的ticks–，每次发生时钟中断时，其实都要进入中断函数，也需要保护cur的上下文，因为ticks–是发生在中断函数里的，不是发生在cur的函数里，进入中断时的保护，在kernel.S中定义的中断入口程序intr%1entry里面有一些push和pop的指令完成的进入中断的上下文保护。</li><li>当cur的ticks–到0时，则触发schedule函数，进而触发switch_to函数，此时cur可能执行到某一部分便因为时间片不足，需要下处理器，因此要保护好此时的上下文环境，也就是下处理器时cur的上下文环境，以便下一次cur这个线程上处理器时能够继续无瑕疵地完成执行流，调用<code>switch_to(cur, next);</code>时会自动压入参数和返回地址，也就是按顺序压入next，cur，返回地址，然后switch_to函数里会按照ABI原则压入esi，edi，ebx，ebp寄存器，此时esp指向ebp，把此时的esp放入cur的PCB的第一个元素也就是内核栈selt_kstack中。</li><li>通过第2步操作，cur的上下文保护好了，接下来要切换到执行next，也就是恢复next的上下文。将next的PCB的内核栈selt_kstack读取出来给到esp，那么此时esp的值就是之前某个时候next时间片为0时完成第2步的上下文保护时压入的ebp，按顺序pop掉ABI规定的四个寄存器，执行ret，处理器就会跳转到上一次next切换时压入的返回地址处继续执行next的流程。</li><li>如果next是第一次执行，即之前没有过上下文保护的过程，那“将next的PCB的内核栈selt_kstack读取出来给到esp”这个操作中，内核栈selt_kstack的值就是初始化线程时候初始化的值，从初始化代码中可以知道selt_kstack初始化为线程栈的栈顶部分，因此此时esp的值就是next线程栈的栈顶，然后按顺序pop掉ABI规定的四个寄存器，执行ret，便变成了执行函数kernel_thread，这个过程和9.2小结中描述的过程是一样的。</li><li>同样的，next恢复完上下文之后便开始继续执行，当next时间片用完后也要发生切换，当慢慢地再次调度到cur线程时，也是通过cur的PCB的第一个元素也就是内核栈selt_kstack，然后将selt_kstack赋给esp，通过cur返回地址与esp的相对位置找到cur返回地址，再通过ret完成让cur重新上处理器。</li><li>真的很巧妙，每个数据结构设计的都是互相贴合的，要从全局的视角看。</li></ol>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第八章 内存管理系统</title>
    <link href="/2024/12/26/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <url>/2024/12/26/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="8-1-makefile文件简介"><a href="#8-1-makefile文件简介" class="headerlink" title="8.1 makefile文件简介"></a>8.1 makefile文件简介</h2><p>这里自己按照makefile的格式写了一个makefile，作用是方便调试，不需要每次都对每个文件一个个gcc，然后再ld，dd命令<br>直接一个make bochs就可以解决</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs makefile">BUILD = ./build<br>BOOT = ./boot<br>KERNEL = ./kernel<br>DEVICE = ./device<br>LIB = ./lib <br>USER = ./user <br>ENTRY_POINT = 0xc0001500<br>INCLUDE = -I lib/ -I kernel/ -I device/ -I <span class="hljs-keyword">include</span>/ -I lib/kernel/<br><br>CFLAGS:= -m32<br>CFLAGS+= -fno-builtin<br>CFLAGS+= -c<br>CFLAGS+= -fno-stack-protector<br><br><span class="hljs-variable">$(BUILD)</span>/boot/%.bin: <span class="hljs-variable">$(BOOT)</span>/%.S <br>@nasm -I <span class="hljs-keyword">include</span>/ -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(BUILD)</span>/kernel/%.o: <span class="hljs-variable">$(KERNEL)</span>/%.S <br>@nasm -f elf -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(BUILD)</span>/lib/%.o: lib/kernel/%.S<br>@nasm -f elf -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(BUILD)</span>/kernel/%.o: <span class="hljs-variable">$(KERNEL)</span>/%.c <br>@gcc <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(BUILD)</span>/user/%.o: ./user/%.c <br>@gcc <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(BUILD)</span>/device/%.o: <span class="hljs-variable">$(DEVICE)</span>/%.c <br>@gcc <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(BUILD)</span>/lib/%.o: lib/%.c <br>@gcc <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(BUILD)</span>/lib/%.o: lib/kernel/%.c <br>@gcc <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$(INCLUDE)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(BUILD)</span>/kernel.bin: \<br><span class="hljs-variable">$(BUILD)</span>/kernel/main.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/init.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/interrupt.o \<br><span class="hljs-variable">$(BUILD)</span>/lib/print.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/kernel.o \<br><span class="hljs-variable">$(BUILD)</span>/device/timer.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/memory.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/debug.o \<br><span class="hljs-variable">$(BUILD)</span>/lib/string.o \<br><span class="hljs-variable">$(BUILD)</span>/lib/bitmap.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/thread.o \<br><span class="hljs-variable">$(BUILD)</span>/lib/list.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/switch.o \<br><span class="hljs-variable">$(BUILD)</span>/kernel/sync.o \<br><span class="hljs-variable">$(BUILD)</span>/device/console.o \<br><span class="hljs-variable">$(BUILD)</span>/device/keyboard.o \<br><span class="hljs-variable">$(BUILD)</span>/device/ioqueue.o \<br><span class="hljs-variable">$(BUILD)</span>/user/tss.o \<br><span class="hljs-variable">$(BUILD)</span>/user/process.o \<br><span class="hljs-variable">$(BUILD)</span>/user/syscall.o \<br><span class="hljs-variable">$(BUILD)</span>/user/syscall-init.o \<br><span class="hljs-variable">$(BUILD)</span>/lib/stdio.o \<br><br>@ld -m elf_i386 -Ttext <span class="hljs-variable">$(ENTRY_POINT)</span> -e main <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> <br>dd if=/home/myos/build/kernel.bin of=/home/myos/master.img bs=512 count=200 seek=9 conv=notrunc<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: bochs</span><br><span class="hljs-section">bochs:<span class="hljs-variable">$(BUILD)</span>/kernel.bin</span><br>bochs -q<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: qemu</span><br><span class="hljs-section">qemu:<span class="hljs-variable">$(BUILD)</span>/kernel.bin</span><br>qemu-system-i386 \<br>-m 32M \<br>-boot c \<br>-hda <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>@rm -f <span class="hljs-variable">$(BUILD)</span>/device/*.o<br>@rm -f <span class="hljs-variable">$(BUILD)</span>/kernel/*.o<br>@rm -f <span class="hljs-variable">$(BUILD)</span>/lib/*.o<br>@rm -f <span class="hljs-variable">$(BUILD)</span>/user/*.o<br>@rm -f <span class="hljs-variable">$(BUILD)</span>/*.bin<br>@rm -f <span class="hljs-variable">$(BUILD)</span>/*.o<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: test</span><br><span class="hljs-section">test:</span><br>make build/boot/boot.bin<br>make build/boot/loader.bin<br>dd if=/home/myos/build/boot/boot.bin of=/home/myos/master.img bs=512 count=1 conv=notrunc<br>dd if=/home/myos/build/boot/loader.bin of=/home/myos/master.img bs=512 count=4 seek=2 conv=notrunc<br></code></pre></td></tr></table></figure><h2 id="8-2-实现assert断言"><a href="#8-2-实现assert断言" class="headerlink" title="8.2 实现assert断言"></a>8.2 实现assert断言</h2><p>断言的意思就是，断定计算机在运行到某处时，某数值的值一定是多少多少，否则报错，打印错误信息。</p><p>interrupt.c中添加了部分函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*获取当前中断状态*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_get_status</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">uint32_t</span> eflags = <span class="hljs-number">0</span>;<br>    GET_EFLAGS(eflags);<br>    <span class="hljs-keyword">return</span> (EFLAGS_IF &amp; eflags) ? INTR_ON : INTR_OFF;<br>&#125;<br><br><span class="hljs-comment">/*打开中断，返回打开中断前的状态*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_enable</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span>;</span><br>    <span class="hljs-keyword">if</span>(intr_get_status() == INTR_ON)&#123;<br>        old_status = INTR_ON;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        old_status = INTR_OFF;<br>        <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;sti&quot;</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> old_status;<br>&#125;<br><br><span class="hljs-comment">/*关闭中断，返回打开中断前的状态*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_disable</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span> <span class="hljs-title">old_status</span>;</span><br>    <span class="hljs-keyword">if</span>(intr_get_status() == INTR_ON)&#123;<br>        old_status = INTR_ON;<br>        <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;cli&quot;</span>:::<span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        old_status = INTR_OFF;<br>    &#125;<br>    <span class="hljs-keyword">return</span> old_status;<br>&#125;<br><br><span class="hljs-comment">/*设置中断状态为status*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_set_status</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> intr_status status)</span>&#123;<br>    <span class="hljs-keyword">return</span> status &amp; INTR_ON ? intr_enable() : intr_disable();<br>&#125;<br></code></pre></td></tr></table></figure><p>略过ASSERT断言函数的实现</p><h2 id="8-3-实现字符串操作函数"><a href="#8-3-实现字符串操作函数" class="headerlink" title="8.3 实现字符串操作函数"></a>8.3 实现字符串操作函数</h2><p>都是关于字符串的操作，涉及char*等<br>string.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><br><span class="hljs-comment">/*将dst_起始的size个字节都设置为value*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span>* dst_,<span class="hljs-type">uint8_t</span> value,<span class="hljs-type">uint32_t</span> size)</span><br>&#123;<br>    ASSERT(dst_ != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">uint8_t</span>* dst = (<span class="hljs-type">uint8_t</span>*) dst_;<br>    <span class="hljs-keyword">while</span>((size--) &gt; <span class="hljs-number">0</span>)<br>    *(dst++) = value;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*将src_起始的size个字节复制到dst_*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span>* dst_,<span class="hljs-type">const</span> <span class="hljs-type">void</span>* src_,<span class="hljs-type">uint32_t</span> size)</span><br>&#123;<br>    ASSERT(dst_ != <span class="hljs-literal">NULL</span> &amp;&amp; src_ != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">uint8_t</span>* dst = dst_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* src = src_;<br>    <span class="hljs-keyword">while</span>((size--) &gt; <span class="hljs-number">0</span>)<br>    *(dst++) = *(src++);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*比较a_和b_开头的size个字节，若相等则返回0*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* a_,<span class="hljs-type">const</span> <span class="hljs-type">void</span>* b_, <span class="hljs-type">uint32_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* a = a_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b = b_;<br>    ASSERT(a != <span class="hljs-literal">NULL</span> || b != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">while</span>((size--) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(*a != *b)<span class="hljs-keyword">return</span> (*a &gt; *b) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>   ++a,++b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*将字符串src_复制到dsc_*/</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dsc_,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src_)</span><br>&#123;<br>    ASSERT(dsc_ != <span class="hljs-literal">NULL</span> &amp;&amp; src_ != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">char</span>* dsc = dsc_;<br>    <span class="hljs-keyword">while</span>((*(dsc_++) = *(src_++) ));<br>    <span class="hljs-keyword">return</span> dsc;     <br>&#125;<br><br><span class="hljs-comment">/*返回字符串长度*/</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span><br>&#123;<br>    ASSERT(str != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = str;<br>    <span class="hljs-keyword">while</span>(*(ptr++));<br>    <span class="hljs-keyword">return</span> (ptr - str - <span class="hljs-number">1</span>);             <span class="hljs-comment">//例如一个字 1 &#x27;\0&#x27; ptr会指向&#x27;\0&#x27;后面一位</span><br>&#125;<br><br><span class="hljs-comment">/*比较两个字符串，若a&gt;b则返回1，相等返回0，小于则返回-1*/</span><br><span class="hljs-type">int8_t</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)</span><br>&#123;<br>    ASSERT(a != <span class="hljs-literal">NULL</span> &amp;&amp; b != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">while</span>(*a &amp;&amp; *a == *b)<br>    &#123;<br>    a++,b++;<br>    &#125;   <br>    <span class="hljs-keyword">return</span> (*a &lt; *b) ? <span class="hljs-number">-1</span> : (*a &gt; *b) ; <span class="hljs-comment">//这个表达式太猛了 用活了</span><br>&#125;<br><br><span class="hljs-comment">/*从左到右查找字符串str中首次出现字符ch的地址*/</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">strchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str,<span class="hljs-type">const</span> <span class="hljs-type">char</span> ch)</span><br>&#123;<br>    ASSERT(str != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">while</span>(*str)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(*str == ch)<span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>*)str;<br>    ++str;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/*从右到左查找字符串str中首次出现字符ch的地址*/</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">strrchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str,<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ch)</span><br>&#123;<br>    ASSERT(str != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">char</span>* last_chrptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(*str != <span class="hljs-number">0</span>)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(ch == *str)last_chrptr = (<span class="hljs-type">char</span>*)str;<br>    str++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> last_chrptr;   <br>&#125;<br><br><span class="hljs-comment">/*将src拼接到dsc后面，返回拼接后字符串的地址*/</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span>* dsc_,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* src_)</span><br>&#123;<br>    ASSERT(dsc_ != <span class="hljs-literal">NULL</span> &amp;&amp; src_ != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">char</span>* str = dsc_;<br>    <span class="hljs-keyword">while</span>(*(str++));<br>    str--;<br>    <span class="hljs-keyword">while</span>(*(str++) = *(src_++));<br>    <span class="hljs-keyword">return</span> dsc_;<br>&#125;<br><br><span class="hljs-comment">/*在字符串str中查找字符ch出现的次数*/</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">strchrs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str,<span class="hljs-type">uint8_t</span> ch)</span><br>&#123;<br>    ASSERT(str != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">uint32_t</span> ch_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*str)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(*str == ch) ++ch_cnt;<br>    ++str;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ch_cnt;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8-4-位图bitmap"><a href="#8-4-位图bitmap" class="headerlink" title="8.4 位图bitmap"></a>8.4 位图bitmap</h2><p>位图相当于资源的映射，计算机利用位图来管理容量较大的内存，每一位和被管理的单位资源都是一对一的关系<br>每个位管理1页，也就是4KB的内存<br>bitmap.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LIB_KERNEL_BITMAP</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIB_KERNEL_BITMAP</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITMAP_MASK 1</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> btmp_bytes_len;        <span class="hljs-comment">//以字节为单位的bitmap长度</span><br>    <span class="hljs-type">uint8_t</span>* bits;              <span class="hljs-comment">//位图的指针，记录位图的位置</span><br>&#125;;<br><br><span class="hljs-comment">/*初始化位图，将里面每个位都设为0*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bitmap_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp)</span>;<br><span class="hljs-comment">/*判断位图中的第bit_idx个位是否为1，是则返回true*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">bitmap_scan_test</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp, <span class="hljs-type">uint32_t</span> bit_idx)</span>;<br><span class="hljs-comment">/*在位图中申请连续cnt个位，成功则返回申请的起始下标，失败返回-1*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitmap_scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp, <span class="hljs-type">uint32_t</span> cnt)</span>;<br><span class="hljs-comment">/*将位图中的bit_idx位设置为value*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bitmap_set</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp, <span class="hljs-type">uint32_t</span> bit_idx, <span class="hljs-type">int8_t</span> value)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>bitmap.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bitmap.h&quot;</span>            <span class="hljs-comment">//函数定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span>            <span class="hljs-comment">//global.h 不清楚</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.h&quot;</span>            <span class="hljs-comment">//memset函数要用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span>         </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span>             </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><br><span class="hljs-comment">/*初始化位图，将里面每个位都设为0*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bitmap_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp)</span>&#123;<br>    <span class="hljs-built_in">memset</span>(btmp-&gt;bits, <span class="hljs-number">0</span>, btmp-&gt;btmp_bytes_len);<br>&#125;<br><br><span class="hljs-comment">/*判断位图中的第bit_idx个位是否为1，是则返回true*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">bitmap_scan_test</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp, <span class="hljs-type">uint32_t</span> bit_idx)</span>&#123;<br>    <span class="hljs-type">uint32_t</span> byte_idx = bit_idx / <span class="hljs-number">8</span>;<br>    <span class="hljs-type">uint32_t</span> bit_index = bit_idx % <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">return</span> (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_index));<br>&#125;<br><br><span class="hljs-comment">/*在位图中申请连续cnt个位，成功则返回申请的起始下标，失败返回-1*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitmap_scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp, <span class="hljs-type">uint32_t</span> cnt)</span>&#123;<br>    <span class="hljs-type">uint32_t</span> idx_byte = <span class="hljs-number">0</span>;      <span class="hljs-comment">//idx_byte存储有空闲位的字节所在数组的下标</span><br>    <span class="hljs-comment">/*在bitmap中逐个字节比较，找到空闲位所在字节*/</span><br>    <span class="hljs-keyword">while</span>( (<span class="hljs-number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len) )&#123;<br>        idx_byte++;<br>    &#125;<br>    ASSERT(idx_byte &lt; btmp-&gt;btmp_bytes_len);<br>    <span class="hljs-keyword">if</span>(idx_byte == btmp-&gt;btmp_bytes_len)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">/*在空闲位所在字节逐位比较，找到空闲位*/</span><br>    <span class="hljs-type">uint32_t</span> idx_bit = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span>( (<span class="hljs-type">uint8_t</span>)(BITMAP_MASK &lt;&lt; idx_bit) &amp; btmp-&gt;bits[idx_byte] )&#123;<br>        idx_bit++;<br>    &#125;<br>    <span class="hljs-type">int</span> bit_idx_start = idx_byte * <span class="hljs-number">8</span> + idx_bit;     <span class="hljs-comment">//空闲位的下标</span><br>    <span class="hljs-comment">/*如果申请位只需要1个，则直接返回下标即可*/</span><br>    <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> bit_idx_start;<br>    <span class="hljs-comment">/*如果申请位需要连续多个，则进行逻辑判断*/</span><br>    <span class="hljs-type">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="hljs-number">8</span>) - bit_idx_start;     <span class="hljs-comment">//记录bitmap还剩下多少个位</span><br>    <span class="hljs-type">uint32_t</span> next_bit = bit_idx_start + <span class="hljs-number">1</span>;      <span class="hljs-comment">//记录下一个位的位置</span><br>    bit_idx_start = <span class="hljs-number">-1</span>;     <span class="hljs-comment">//先置为-1，如果找不到连续cnt个位空闲，则直接返回-1</span><br>    <span class="hljs-type">uint32_t</span> count = <span class="hljs-number">1</span>;     <span class="hljs-comment">//记录已经找到的连续空闲位的数量</span><br>    <span class="hljs-keyword">while</span>(bit_left-- &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!(bitmap_scan_test(btmp, next_bit)))&#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count == cnt)&#123;<br>            bit_idx_start = next_bit - cnt + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        next_bit++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bit_idx_start;<br>&#125;<br><br><span class="hljs-comment">/*将位图中的bit_idx位设置为value*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bitmap_set</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bitmap* btmp, <span class="hljs-type">uint32_t</span> bit_idx, <span class="hljs-type">int8_t</span> value)</span>&#123;<br>    ASSERT(value == <span class="hljs-number">0</span> || value == <span class="hljs-number">1</span>);<br>    <span class="hljs-type">uint32_t</span> byte_idx = bit_idx / <span class="hljs-number">8</span>;<br>    <span class="hljs-type">uint32_t</span> bit_index = bit_idx % <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">if</span>(value)&#123;<br>        btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &lt;&lt; bit_index);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &lt;&lt; bit_index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-5-内存管理系统"><a href="#8-5-内存管理系统" class="headerlink" title="8.5 内存管理系统"></a>8.5 内存管理系统</h2><p>在分页机制下有虚拟内存和物理内存，为了有效管理他们，我们需要创建虚拟内存地址池和物理内存地址池，内存池管理的单位大小是4KB<br>注意：虚拟内存设置为4G大小，物理内存不固定，目前设置为32MB</p><p>物理内存地址池：一部分给操作系统，一部分给用户使用，因此细分为内核物理内存池、用户物理内存池<br>为了方便实现，将内核物理内存池和用户物理内存池设置为一样的大小，即平分物理内存</p><p>在memory.h定义了虚拟地址池和物理内存池</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*虚拟地址池*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtual_addr</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> <span class="hljs-title">vaddr_bitmap</span>;</span>            <span class="hljs-comment">//虚拟地址要用到的bitmap</span><br>    <span class="hljs-type">uint32_t</span> vaddr_start;   <span class="hljs-comment">//虚拟地址的起始地址</span><br>&#125;;<br><br><span class="hljs-comment">/*内存池结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bitmap</span> <span class="hljs-title">pool_bitmap</span>;</span>      <span class="hljs-comment">//内存池中用来管理内存的bitmap</span><br>    <span class="hljs-type">uint32_t</span> phy_addr_start;    <span class="hljs-comment">//本内存池所管理的物理内存的起始地址</span><br>    <span class="hljs-type">uint32_t</span> pool_size;     <span class="hljs-comment">//本内存池的字节容量</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">lock</span>;</span>       <span class="hljs-comment">//pool锁，申请内存时互斥</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>虚拟地址也需要分配，虽然多个进程的虚拟地址可以相同，但一个进程下的虚拟地址是唯一的，也需要用虚拟地址池来确保唯一性<br>这里的虚拟地址池是内核虚拟地址池</p><p>memory.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_SIZE 4096    <span class="hljs-comment">//页的大小为4096字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM_BITMAP_BASE 0xc009a000      <span class="hljs-comment">//主线程的PCB在0xc009e000，bitmap设定为支持管理512M内存，所以占4页，减去4000</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K_HEAP_START 0xc0100000     <span class="hljs-comment">//之前把第一个页表的前256项映射为了低端1M的内存，所以把堆设置在1M以上保持紧密</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span> <span class="hljs-title">kernel_pool</span>, <span class="hljs-title">user_pool</span>;</span> <span class="hljs-comment">//定义了内核物理内存池和用户物理内存池</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">virtual_addr</span> <span class="hljs-title">kernel_vaddr</span>;</span>   <span class="hljs-comment">//内核的虚拟内存池</span><br><br><span class="hljs-comment">/*初始化内核和用户的内存池*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">mem_pool_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> all_mem)</span>&#123;<br>    put_str(<span class="hljs-string">&quot;mem_pool_init start!\n&quot;</span>);<br>    <span class="hljs-type">uint32_t</span> page_table_size = PG_SIZE * <span class="hljs-number">256</span>;       <span class="hljs-comment">//页目录表和页表占用的大小，页目录表占1个页框，第0和768个页目录项映射的第一个页表占一个页框，769到1022页目录项映射了254个页框，总共256个页框</span><br>    <span class="hljs-type">uint32_t</span> used_mem = page_table_size + <span class="hljs-number">0x100000</span>; <span class="hljs-comment">//记录当前已使用的内存，低端1M加上页目录和页表占用的大小,目前2M</span><br>    <span class="hljs-type">uint32_t</span> free_mem = all_mem - used_mem;     <span class="hljs-comment">//空闲内存大小，总共可用内存大小减去已使用内存</span><br>    <span class="hljs-type">uint16_t</span> all_free_pages = free_mem / PG_SIZE;   <span class="hljs-comment">//空余的页数 = 总空余内存 / 一页的大小</span><br><br>    <span class="hljs-type">uint16_t</span> kernel_free_pages = all_free_pages /<span class="hljs-number">2</span>; <span class="hljs-comment">//内核和用户平分内存，各15M</span><br>    <span class="hljs-type">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages; <span class="hljs-comment">//万一是奇数 就会少1 减去即可</span><br><br>    <span class="hljs-type">uint32_t</span> kbm_length = kernel_free_pages / <span class="hljs-number">8</span>;    <span class="hljs-comment">//内核内存池的bitmap长度</span><br>    <span class="hljs-type">uint32_t</span> ubm_length = user_free_pages / <span class="hljs-number">8</span>;      <span class="hljs-comment">//用户内存池的bitmap长度</span><br><br>    <span class="hljs-type">uint32_t</span> kp_start = used_mem;               <span class="hljs-comment">//内核物理内存池的起始地址</span><br>    <span class="hljs-type">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;     <span class="hljs-comment">//用户物理内存池的起始地址</span><br><br>    kernel_pool.phy_addr_start = kp_start;      <span class="hljs-comment">//初始化内核内存池和用户内存池所管理的物理内存的起始地址</span><br>    user_pool.phy_addr_start = up_start;<br><br>    kernel_pool.pool_size = kernel_free_pages * PG_SIZE;        <span class="hljs-comment">//初始化内核内存池和用户内存池所管理的物理内存容量</span><br>    user_pool.pool_size = user_free_pages * PG_SIZE;<br><br>    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;        <span class="hljs-comment">//初始化内核内存池和用户内存池对应bitmap的长度</span><br>    user_pool.pool_bitmap.btmp_bytes_len = ubm_length; <br><br>    kernel_pool.pool_bitmap.bits = (<span class="hljs-type">void</span>*)MEM_BITMAP_BASE;      <span class="hljs-comment">//初始化内核内存池和用户内存池对应bitmap在内存中的位置</span><br>    user_pool.pool_bitmap.bits = (<span class="hljs-type">void</span>*)(MEM_BITMAP_BASE + kbm_length);<br><br>    put_str(<span class="hljs-string">&quot;kernel_pool_bitmap_start:&quot;</span>);<br>    put_int((<span class="hljs-type">int</span>)kernel_pool.pool_bitmap.bits);<br>    put_char(<span class="hljs-number">0x0d</span>);<br>    put_str(<span class="hljs-string">&quot;kernel_pool_phy_addr_start:&quot;</span>);<br>    put_int(kernel_pool.phy_addr_start);<br>    put_char(<span class="hljs-number">0x0d</span>);<br>    put_str(<span class="hljs-string">&quot;user_pool_bitmap_start:&quot;</span>);<br>    put_int((<span class="hljs-type">int</span>)user_pool.pool_bitmap.bits);<br>    put_char(<span class="hljs-number">0x0d</span>);<br>    put_str(<span class="hljs-string">&quot;user_pool_phy_addr_start:&quot;</span>);<br>    put_int(user_pool.phy_addr_start);<br>    put_char(<span class="hljs-number">0x0d</span>);<br><br>    bitmap_init(&amp;kernel_pool.pool_bitmap);      <span class="hljs-comment">//初始化内核内存池和用户内存池对应bitmap的数值，初始化为全0</span><br>    bitmap_init(&amp;user_pool.pool_bitmap);<br><br>    kernel_vaddr.vaddr_bitmap.bits = (<span class="hljs-type">void</span>*)(MEM_BITMAP_BASE + kbm_length + ubm_length);    <span class="hljs-comment">//初始化内核虚拟内存池，将其安排在内核物理内存池和用户物理内存池之后</span><br>    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;      <span class="hljs-comment">//初始化内核虚拟内存池bitmap长度，长度设为与内核物理内存池一样</span><br><br>    kernel_vaddr.vaddr_start = K_HEAP_START;        <span class="hljs-comment">//初始化虚拟内存池的起始地址</span><br>    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);<br>    lock_init(&amp;kernel_pool.lock);<br>    lock_init(&amp;user_pool.lock);<br>    put_str(<span class="hljs-string">&quot;mem_pool_init done\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*内存管理部分初始化入口*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">()</span><br>&#123;<br>    put_str(<span class="hljs-string">&quot;mem_init start!\n&quot;</span>);<br>    <span class="hljs-type">uint32_t</span> mem_bytes_total = (*(<span class="hljs-type">uint32_t</span>*)(<span class="hljs-number">0xb00</span>)); <span class="hljs-comment">//我们把总内存的值放在了0xb00 </span><br>    mem_pool_init(mem_bytes_total);<br>    block_desc_init(k_block_descs);<br>    put_str(<span class="hljs-string">&quot;mem_init done!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成上述操作后，内核物理内存池的位图的起始地址设置为c009A000，管理的物理内存大小为15M，管理的物理内存的起始地址为200000，用户物理内存池的位图的起始地址设置为c009A1E0，管理的物理内存大小为15M，管理的物理内存的起始地址为1100000。初始化完毕后，尝试分配内存</p><p>memory.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*内存池标记，用于判断用哪个内存池*/</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">pool_flags</span></span><br><span class="hljs-class">&#123;</span><br>    PF_KERNEL = <span class="hljs-number">1</span>,  <span class="hljs-comment">//内核内存池</span><br>    PF_USER = <span class="hljs-number">2</span>     <span class="hljs-comment">//用户内存池</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_P_1 1        <span class="hljs-comment">//页表项或页目录项的存在属性位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_P_0 0        <span class="hljs-comment">//存在属性位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_RW_R 0       <span class="hljs-comment">//读/执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_RW_W 2       <span class="hljs-comment">//读/写/执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_US_S 0       <span class="hljs-comment">//系统级</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_US_U 4       <span class="hljs-comment">//用户级</span></span><br></code></pre></td></tr></table></figure><p>memory.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*在pf标识的内存池中申请pg_cnt个虚拟页，成功则返回虚拟页的地址，失败返回NULL*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">vaddr_get</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> pool_flags pf,<span class="hljs-type">uint32_t</span> pg_cnt)</span><br>&#123;<br>    <span class="hljs-type">int</span> vaddr_start = <span class="hljs-number">0</span>,bit_idx_start = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">uint32_t</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(pf == PF_KERNEL)     <span class="hljs-comment">//内核池</span><br>    &#123;<br>    bit_idx_start = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap,pg_cnt); <span class="hljs-comment">//在bitmap中申请连续位，申请成功则返回初始位的下标</span><br>    <span class="hljs-keyword">if</span>(bit_idx_start == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(cnt &lt; pg_cnt)<br>    bitmap_set(&amp;kernel_vaddr.vaddr_bitmap,bit_idx_start + (cnt++),<span class="hljs-number">1</span>);   <span class="hljs-comment">//从bit_idx_start开始连续pg_cnt个位都设为1</span><br>    vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;   <span class="hljs-comment">//申请到的虚拟地址起始页是虚拟地址开始位置+bitmap申请到的起始位*4K</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>        <span class="hljs-comment">//用户池，未实现</span><br>    &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)vaddr_start;<br>&#125;<br><br><span class="hljs-comment">/*返回虚拟地址vaddr对应的PTE指针，该指针也用虚拟地址表示*/</span><br><span class="hljs-type">uint32_t</span>* <span class="hljs-title function_">pte_ptr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>* pte = (<span class="hljs-type">uint32_t</span>*)(<span class="hljs-number">0xffc00000</span> + ((vaddr &amp; <span class="hljs-number">0xffc00000</span>) &gt;&gt; <span class="hljs-number">10</span>) + PTE_IDX(vaddr) * <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">return</span> pte;<br>&#125;<br><br><span class="hljs-comment">/*返回虚拟地址vaddr对应的PDE指针，该指针也用虚拟地址表示*/</span><br><span class="hljs-type">uint32_t</span>* <span class="hljs-title function_">pde_ptr</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> vaddr)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>* pde = (<span class="hljs-type">uint32_t</span>*) ((<span class="hljs-number">0xfffff000</span>) + PDE_IDX(vaddr) * <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">return</span> pde;<br>&#125;<br><br><span class="hljs-comment">/*在m_pool指向的物理内存池中分配1个物理页，成功则返回分配的物理页的物理地址*/</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">palloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pool* m_pool)</span><br>&#123;<br>    <span class="hljs-type">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(bit_idx == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    bitmap_set(&amp;m_pool-&gt;pool_bitmap,bit_idx,<span class="hljs-number">1</span>);<br>    <span class="hljs-type">uint32_t</span> page_phyaddr = ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)page_phyaddr;<br>&#125;<br><br><span class="hljs-comment">/*添加虚拟地址_vaddr到物理地址_page_phyaddr的映射*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">page_table_add</span><span class="hljs-params">(<span class="hljs-type">void</span>* _vaddr,<span class="hljs-type">void</span>* _page_phyaddr)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> vaddr = (<span class="hljs-type">uint32_t</span>)_vaddr,page_phyaddr = (<span class="hljs-type">uint32_t</span>)_page_phyaddr;<br>    <span class="hljs-type">uint32_t</span>* pde = pde_ptr(vaddr);<br>    <span class="hljs-type">uint32_t</span>* pte = pte_ptr(vaddr);<br>    <br>    <span class="hljs-keyword">if</span>(*pde &amp; <span class="hljs-number">0x00000001</span>)   <span class="hljs-comment">//如果虚拟地址vaddr对应的pde存在位为1</span><br>    &#123;<br>    ASSERT(!(*pte &amp; <span class="hljs-number">0x00000001</span>));<br>    <span class="hljs-keyword">if</span>(!(*pte &amp; <span class="hljs-number">0x00000001</span>))        <span class="hljs-comment">//如果虚拟地址vaddr对应的pte不存在，则将该pte的存在位设为1，并将对物理地址的映射写入</span><br>        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        PANIC(<span class="hljs-string">&quot;pte repeat&quot;</span>);<br>        *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);<br>    &#125;<br>    &#125; <br>    <span class="hljs-keyword">else</span>        <span class="hljs-comment">//如果虚拟地址vaddr对应的pde存在位为0，即不存在</span><br>    &#123;<br>    <span class="hljs-type">uint32_t</span> pde_phyaddr = (<span class="hljs-type">uint32_t</span>)palloc(&amp;kernel_pool);      <span class="hljs-comment">//调用palloc分配一个新的物理页，该物理页用来当做新的页表，存在pde里</span><br>    *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);      <br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)((<span class="hljs-type">int</span>)pte &amp; <span class="hljs-number">0xfffff000</span>),<span class="hljs-number">0</span>,PG_SIZE);<br>    ASSERT(!(*pte &amp; <span class="hljs-number">0x00000001</span>));<br>    *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*在pf所指向的虚拟内存池子中，申请分配pg_cnt个页，成功则返回申请到的首个虚拟地址*/</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc_page</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> pool_flags pf,<span class="hljs-type">uint32_t</span> pg_cnt)</span><br>&#123;<br>    ASSERT(pg_cnt &gt; <span class="hljs-number">0</span> &amp;&amp; pg_cnt &lt; <span class="hljs-number">3840</span>);    <span class="hljs-comment">/*内核和用户平分30M内存，所以申请的页数不能超过15M对应3840页*/</span><br>    <br>    <span class="hljs-type">void</span>* vaddr_start = vaddr_get(pf,pg_cnt);   <span class="hljs-comment">/*在虚拟内存池中申请虚拟地址*/</span><br>    <span class="hljs-keyword">if</span>(vaddr_start == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <br>    <span class="hljs-type">uint32_t</span> vaddr = (<span class="hljs-type">uint32_t</span>)vaddr_start,cnt = pg_cnt;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pool</span>* <span class="hljs-title">mem_pool</span> =</span> pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool; <span class="hljs-comment">/*判断该虚拟内存池子属于内核还是用户*/</span><br>    <br>    <span class="hljs-keyword">while</span>(cnt-- &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>    <span class="hljs-type">void</span>* page_phyaddr = palloc(mem_pool);      <span class="hljs-comment">/*申请物理页，返回物理地址*/</span><br>    <span class="hljs-keyword">if</span>(page_phyaddr == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    page_table_add((<span class="hljs-type">void</span>*)vaddr,page_phyaddr);  <span class="hljs-comment">/*完成 申请的虚拟地址和申请的物理地址的映射*/</span><br>    vaddr += PG_SIZE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vaddr_start;<br>&#125;<br><br><span class="hljs-comment">/*从内核物理内存池中申请pg_cnt页内存，成功则返回其虚拟地址*/</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">get_kernel_pages</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> pg_cnt)</span><br>&#123;<br>    <span class="hljs-type">void</span>* vaddr = malloc_page(PF_KERNEL,pg_cnt);<br>    <span class="hljs-keyword">if</span>(vaddr != <span class="hljs-literal">NULL</span>)<span class="hljs-built_in">memset</span>(vaddr,<span class="hljs-number">0</span>,pg_cnt*PG_SIZE); <span class="hljs-comment">/*如果分配成功，则将分配到的物理页全清零*/</span><br>    <span class="hljs-keyword">return</span> vaddr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-6-内存管理小结v1"><a href="#8-6-内存管理小结v1" class="headerlink" title="8.6 内存管理小结v1"></a>8.6 内存管理小结v1</h2><p>利用内存池进行管理，分为物理内存池和虚拟地址内存池</p><p>物理内存池分为内核物理内存池和用户物理内存池，内核物理内存池管理的起始地址在200000，管理大小为15MB，用户物理内存池管理的起始地址在1100000，管理大小为15MB<br>虚拟地址内存池目前只设置了内核虚拟内存池，内核虚拟内存池管理的起始虚拟地址为 <code>#define K_HEAP_START 0xc0100000</code>，管理的大小目前也设置为15MB</p><p>本章完成了主要完成的函数是<code>void* get_kernel_pages(uint32_t pg_cnt)</code>，从内核物理内存池中申请pg_cnt页内存，成功则返回其虚拟地址<br>流程大致为：</p><ol><li>通过<code>static void* vaddr_get(enum pool_flags pf,uint32_t pg_cnt)</code>函数在内核虚拟内存池中申请连续页，返回申请的虚拟连续页的首地址。详细流程是通过虚拟地址池的bitmap找到连续空闲位，然后对应通过bitmap找到连续空闲虚拟页，然后返回首地址。</li><li>通过<code>void* palloc(struct pool* m_pool)</code>在m_pool指向的物理内存池中分配1个物理页，成功则返回分配的物理页的物理地址。详细流程是通过物理地址池的bitmap找到连续空闲位，然后对应通过bitmap找到连续空闲物理页，返回物理页的物理地址。</li><li>通过上述两个步骤得到虚拟地址和物理地址后，通过<code>void page_table_add(void* _vaddr,void* _page_phyaddr)</code>添加虚拟地址_vaddr到物理地址_page_phyaddr的映射，这里要注意，如果虚拟地址对应的pde本身存在，即之前某个时候已经做了pde到某个页表的映射，那么直接将物理地址写到虚拟地址对应的pte上即可，但如果虚拟地址对应的pde本身不存在，那么需要分配一个新的物理页，当做pde对应的某个页表，调用palloc即可，然后把这个新的页写在pde里当做页表的物理载体，再把物理地址写到该页对应的pte上即可。</li><li>因为一个页表管理的内存是4M，所以分配一个4KB的页时，会出现两种情况，要么pde已经映射了这个页表，要么没有映射。需要分情况处理</li><li>通过<code>void* malloc_page(enum pool_flags pf,uint32_t pg_cnt)</code>在pf所指向的虚拟内存池子中，申请分配pg_cnt个页，成功则返回申请到的首个虚拟地址，本质上是不断循环调用palloc函数，并每次都<code>page_table_add</code>完成映射</li><li><code>void* get_kernel_pages(uint32_t pg_cnt)</code>从内核物理内存池中申请pg_cnt页内存，成功则返回其虚拟地址，本质是将参数选定为内核的池，然后调用上述函数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第七章 中断</title>
    <link href="/2024/12/25/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <url>/2024/12/25/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="7-1-中断"><a href="#7-1-中断" class="headerlink" title="7.1 中断"></a>7.1 中断</h2><p>并发指的是单位时间内的累计工作量，并行指的是真正同时进行的工作量，所以单核谈并发，多核谈并行<br>运用中断能够显著提升并发，从而大幅提升整体效率<br>操作系统可以认为是中断驱动的，操作系统本身是个死循环等待某件事情发生</p><h2 id="7-2-中断分类"><a href="#7-2-中断分类" class="headerlink" title="7.2 中断分类"></a>7.2 中断分类</h2><p>中断可分为：</p><ul><li>外部中断：<ul><li>可屏蔽中断：一般是外部设备发出的中断，通过INTR引脚进入CPU，可屏蔽，即可不理会，每一种中断源都有一个中断向量号</li><li>不可屏蔽中断：通过NMI引脚进入CPU，表示系统发生了指明错误，中断向量号统一为2</li></ul></li><li>内部中断：<ul><li>软中断：软件发起，如指令<code>int3</code>  <code>int 8位立即数</code>等</li><li>异常：分为Fault、Trap、Abort</li></ul></li></ul><table><thead><tr><th>向量</th><th>助记</th><th>描述</th><th>类型</th><th>错误码</th><th>来源</th></tr></thead><tbody><tr><td>0</td><td>#DE</td><td>Divide Error</td><td>Fault</td><td>No</td><td>DIV 和 IDIV 指令。</td></tr><tr><td>1</td><td>#DB</td><td>Debug Exception</td><td>Fault&#x2F;Trap</td><td>No</td><td>指令、数据、I&#x2F;O 中断断点；单步执行；以及其他。</td></tr><tr><td>2</td><td>—</td><td>NMI Interrupt</td><td>Interrupt</td><td>No</td><td>不可屏蔽的外部中断。</td></tr><tr><td>3</td><td>#BP</td><td>Breakpoint</td><td>Trap</td><td>No</td><td>INT3 指令。</td></tr><tr><td>4</td><td>#OF</td><td>Overflow</td><td>Trap</td><td>No</td><td>INTO 指令。</td></tr><tr><td>5</td><td>#BR</td><td>BOUND Range Exceeded</td><td>Fault</td><td>No</td><td>BOUND 指令。</td></tr><tr><td>6</td><td>#UD</td><td>Invalid Opcode (Undefined Opcode)</td><td>Fault</td><td>No</td><td>UD 指令或保留指令。</td></tr><tr><td>7</td><td>#NM</td><td>Device Not Available (No Math Coprocessor)</td><td>Fault</td><td>No</td><td>浮点数运算或 WAIT&#x2F;FWAIT 指令。</td></tr><tr><td>8</td><td>#DF</td><td>Double Fault</td><td>Abort</td><td>Yes</td><td>任意可以生成异常的指令、NMI 或 INTR。</td></tr><tr><td>9</td><td>—</td><td>Coprocessor Segment Overrun (reserved)</td><td>Fault</td><td>No</td><td>浮点数指令。</td></tr><tr><td>10</td><td>#TS</td><td>Invalid TSS</td><td>Fault</td><td>Yes</td><td>任务切换或 TSS 访问。</td></tr><tr><td>11</td><td>#NP</td><td>Segment Not Present</td><td>Fault</td><td>Yes</td><td>加载段寄存器或访问系统段。</td></tr><tr><td>12</td><td>#SS</td><td>Stack-Segment Fault</td><td>Fault</td><td>Yes</td><td>栈操作和 SS 寄存器加载。</td></tr><tr><td>13</td><td>#GP</td><td>General Protection</td><td>Fault</td><td>Yes</td><td>任意内存引用和其他保护检查。</td></tr><tr><td>14</td><td>#PF</td><td>Page Fault</td><td>Fault</td><td>Yes</td><td>任意内存引用。</td></tr><tr><td>15</td><td>—</td><td>(Intel reserved. Do not use.)</td><td></td><td>No</td><td></td></tr><tr><td>16</td><td>#MF</td><td>x87 FPU Floating-Point Error (Math Fault)</td><td>Fault</td><td>No</td><td>x87 FPU 浮点数或 WAIT&#x2F;FWAIT 指令。</td></tr><tr><td>17</td><td>#AC</td><td>Alignment Check</td><td>Fault</td><td>Yes</td><td>任意内存中的数据引用。</td></tr><tr><td>18</td><td>#MC</td><td>Machine Check</td><td>Abort</td><td>No</td><td>错误代码（如果有）和来源是依赖于模型的。</td></tr><tr><td>19</td><td>#XM</td><td>SIMD Floating-Point Exception</td><td>Fault</td><td>No</td><td>SSE&#x2F;SSE2&#x2F;SSE3 浮点数指令。</td></tr><tr><td>20</td><td>#VE</td><td>Virtualization Exception</td><td>Fault</td><td>No</td><td>EPT 违规。</td></tr><tr><td>21</td><td>#CP</td><td>Control Protection Exception</td><td>Fault</td><td>Yes</td><td>RET, IRET, RSTORSSP, 和 SETSSBSY 指令可生成此异常。当 CET 间接分支跟踪启用时，如果间接调用或跳转目标缺少 ENDBRANCH 指令，也可能生成此异常。</td></tr><tr><td>22-31</td><td>—</td><td>Intel reserved. Do not use.</td><td></td><td>No</td><td></td></tr><tr><td>32-255</td><td>—</td><td>User Defined (Non-reserved) Interrupts</td><td>Interrupt</td><td></td><td>外部中断或 INT n 指令。</td></tr></tbody></table><h2 id="7-3-中断描述符表"><a href="#7-3-中断描述符表" class="headerlink" title="7.3 中断描述符表"></a>7.3 中断描述符表</h2><p>中断描述符表IDT是保护模式下用来存储中断程序入口的表，里面存储的是中断门<br><img src="/../img/20241226103000.png" title="中断门"><br><img src="/../img/v2-6dfe789253ee65dd1f9cf8b082af6aae_r.jpg" title="中断描述符表寄存器IDTR"><br>中断描述符表中每个描述符占8个字节，IDT的地址不限制，在哪都行，只要用<code>lidt</code>指令将IDT位置加载到IDTR上，就可以找到IDT的位置。</p><p>完整的中断过程分为CPU外和CPU内两部分<br>CPU外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU<br>CPU内：CPU执行该中断向量号对应的中断处理程序</p><p>先讨论CPU内发生的过程</p><ol><li>处理器根据中断向量号定位中断门描述符，找到对应中断处理程序入口，执行中断处理程序</li><li>处理器进行特权级检查，若中断由外部设备或异常通知系统，则只需要检查CPL是否权限小于目标代码段DPL即可，小于则通过；如果由软中断引发，即用户进程主动发起的中断，则需要满足CPL在中断门描述符DPL和目标代码段DPL之间</li><li>执行中断处理程序，把程序入口加载到CS:EIP中</li></ol><p>中断发生后，CPU会自动将NT、TF、IF位置0，避免中断嵌套引发一般性保护（GP）异常。<br>可以通过<code>sti</code>指令在中断中打开IF位，允许处理更高优先级的中断，然后可以通过<code>cli</code>使IF位置为0<br>TF为0表示禁止单步执行</p><p>NT位表示任务嵌套标志位，标记任务嵌套的情况，任务嵌套指CPU将当前旧任务挂起，执行新任务，新任务执行完毕后返回旧任务。<br>在执行新任务前，CPU将旧任务TSS选择子写到了新任务TSS中的“上一个任务TSS的指针”字段中，并将新任务的NT位置1，表示此任务是被别的任务嵌套使用的，这样在最后新任务执行完毕，利用iret执行返回时，如果NT为1，则从新任务TSS中的“上一个任务TSS的指针”字段中找到旧任务TSS选择子，然后执行旧任务；如果NT为0，则表示当前是正常的中断环境，执行正常的中断退出流程。</p><h2 id="7-4-中断发生时的压栈"><a href="#7-4-中断发生时的压栈" class="headerlink" title="7.4 中断发生时的压栈"></a>7.4 中断发生时的压栈</h2><p>下面看看中断发生时，寄存器的入栈情况：</p><ol><li>处理器拿CPL和目标代码段DPL对比，若CPL等级小于DPL，则发生了特权级转移，处理器将临时保存当前特权级的旧栈SS和ESP，记作SS_old和ESP_old，然后在TSS中找到转移后对应特权级的新栈，并把新栈加载到SS和ESP中，再把SS_old和ESP_old压入新栈中，以备中断返回时重新加载回旧栈。如果没有发生特权级的转移，则不需要完成上述旧栈新栈的操作。</li><li>在栈中压入EFLAGS寄存器，当前栈是新栈还是旧栈，取决第一步是否发生特权级变化</li><li>将当前的代码段CS和EIP入栈保存，以备结束后恢复</li><li>某些中断会包含错误码，因此要压入错误码，通常能够压入错误码的中断属于中断向量号在0-32之内的异常</li></ol><h2 id="7-5-可编程中断控制器8259A"><a href="#7-5-可编程中断控制器8259A" class="headerlink" title="7.5 可编程中断控制器8259A"></a>7.5 可编程中断控制器8259A</h2><p>8259A用于管理和控制可屏蔽中断，表现在屏蔽外设中断，对它们实行优先级判决，向CPU提供中断向量号等<br>外部中断有这么多，CPU不可能每个都要连接并且控制，因此需要找个“代理”，CPU通过代理进行连接，这个代理就是8259A<br>在kernel.S文件中完成中断处理程序的实现：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">%macro VECTOR <span class="hljs-number">2</span> <span class="hljs-comment">;宏定义，接收两个参数，是为了某个中断向量号而定义的中断处理程序</span><br><span class="hljs-meta">section</span> .text<br>intr<span class="hljs-subst">%1</span>entry:<br>    <span class="hljs-subst">%2</span>      <span class="hljs-comment">;有错误码的中断cpu会自动压入错误码地址，所以不用压入，执行nop，为了对齐，无错误码则压入0</span><br>    <span class="hljs-comment">;因为要从汇编跳到C语言，肯定会影响上下文的寄存器，因此要保存上下文</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">fs</span> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">gs</span> <br>    <span class="hljs-keyword">pushad</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span>        <span class="hljs-comment">;0x20是EOI命令码</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>, <span class="hljs-built_in">al</span>        <span class="hljs-comment">;向从片发送EOI命令码</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>, <span class="hljs-built_in">al</span>        <span class="hljs-comment">;向主片发送EOI命令码</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-subst">%1</span>     <span class="hljs-comment">;   压入中断向量号</span><br>    <span class="hljs-keyword">call</span> [idt_table + <span class="hljs-subst">%1</span> * <span class="hljs-number">4</span>]<span class="hljs-comment">;      调用idt_table对应的C语言版本的中断处理函数</span><br>    <span class="hljs-keyword">jmp</span> intr_exit<br><span class="hljs-meta">section</span> .data  <span class="hljs-comment">;定义数组元素，元素值为intr%1entry，存储入口地址，由于每个宏用的都是同一个section，所以会合并成一个segment，保证数组元素是连续的</span><br>    <span class="hljs-built_in">dd</span>  intr<span class="hljs-subst">%1</span>entry<br>%endmacro<br><br><span class="hljs-meta">section</span> .text<br><span class="hljs-meta">global</span> intr_exit<br><span class="hljs-symbol">intr_exit:</span><br>    <span class="hljs-comment">;恢复上下文</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span>  <span class="hljs-comment">; 跳过中断号</span><br>    <span class="hljs-keyword">popad</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">gs</span> <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">fs</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span> <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span> <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span>  <span class="hljs-comment">;跳过error_code</span><br>    <span class="hljs-keyword">iretd</span><br></code></pre></td></tr></table></figure><p>上述代码定义了一个宏定义，生成某个中断向量号的中断处理程序入口表数组，并分为了两部分，分别是.data段和.text段，这样在编译的时候，所有.data段就会被合并在一个segment里，保证数组元素使连续的，.data段里存储的是中断处理程序的入口地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;利用宏定义生成中断处理程序入口表数组</span><br>VECTOR <span class="hljs-number">0x0</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X1</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X2</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x3</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X4</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X5</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x6</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X7</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X8</span> ,ERROR_CODE<br>VECTOR <span class="hljs-number">0x9</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0XA</span> ,ERROR_CODE<br>VECTOR <span class="hljs-number">0XB</span> ,ERROR_CODE<br>VECTOR <span class="hljs-number">0XC</span> ,ERROR_CODE<br>VECTOR <span class="hljs-number">0XD</span> ,ERROR_CODE<br>VECTOR <span class="hljs-number">0XE</span> ,ERROR_CODE<br>VECTOR <span class="hljs-number">0XF</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X10</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X11</span> ,ERROR_CODE<br>VECTOR <span class="hljs-number">0x12</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X13</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X14</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0x15</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X16</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X17</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X18</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X19</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X1A</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X1B</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X1C</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X1D</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X1E</span> ,ERROR_CODE                               <span class="hljs-comment">;处理器自动推错误码</span><br>VECTOR <span class="hljs-number">0X1F</span> ,<span class="hljs-meta">ZERO</span><br>VECTOR <span class="hljs-number">0X20</span> ,<span class="hljs-meta">ZERO</span>       <span class="hljs-comment">;时钟中断</span><br>VECTOR <span class="hljs-number">0X21</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;键盘中断</span><br>VECTOR <span class="hljs-number">0X22</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;级联</span><br>VECTOR <span class="hljs-number">0X23</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;串口2</span><br>VECTOR <span class="hljs-number">0X24</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;串口1</span><br>VECTOR <span class="hljs-number">0X25</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;并口2</span><br>VECTOR <span class="hljs-number">0X26</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;软盘</span><br>VECTOR <span class="hljs-number">0X27</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;并口1</span><br>VECTOR <span class="hljs-number">0X28</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;实时时钟</span><br>VECTOR <span class="hljs-number">0X29</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;重定向</span><br>VECTOR <span class="hljs-number">0X2A</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;保留</span><br>VECTOR <span class="hljs-number">0x2B</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;保留</span><br>VECTOR <span class="hljs-number">0x2C</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;ps/2 鼠标</span><br>VECTOR <span class="hljs-number">0x2D</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;fpu 浮点单元异常</span><br>VECTOR <span class="hljs-number">0x2E</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;硬盘</span><br>VECTOR <span class="hljs-number">0x2F</span> ,<span class="hljs-meta">ZERO</span><span class="hljs-comment">;保留</span><br></code></pre></td></tr></table></figure><p>上述代码利用宏定义，生成了一个数组，该数组中每个元素存储的都是某个中断向量号对应的处理程序的入口地址</p><p>接下来要写interrupt的相关函数，先把interrupt.h写出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KERNEL_INTERRUPT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNEL_INTERRUPT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* intr_handler;<br><span class="hljs-type">void</span> <span class="hljs-title function_">idt_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">/*定义中断的两种状态*/</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">intr_status</span>&#123;</span><br>    INTR_OFF,       <span class="hljs-comment">//关闭是0</span><br>    INTR_ON     <span class="hljs-comment">//打开是1</span><br>&#125;;<br><br><span class="hljs-comment">/*获取当前中断状态*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_get_status</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">/*打开中断，返回打开中断前的状态*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_enable</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">/*关闭中断，返回打开中断前的状态*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_disable</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">/*设置中断状态为status*/</span><br><span class="hljs-keyword">enum</span> intr_status <span class="hljs-title function_">intr_set_status</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> intr_status status)</span>;<br><span class="hljs-comment">/*在中断处理程序数组第vector_no个元素中注册安装中断处理程序funciton*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">register_handler</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> vector_no, intr_handler function)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>interrupt.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;io.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_M_CTRL 0x20       <span class="hljs-comment">// 这里用的可编程中断控制器是8259A,主片的控制端口是0x20</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_M_DATA 0x21       <span class="hljs-comment">// 主片的数据端口是0x21</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_S_CTRL 0xa0       <span class="hljs-comment">// 从片的控制端口是0xa0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIC_S_DATA 0xa1       <span class="hljs-comment">// 从片的数据端口是0xa1</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_CNT 0x81       <span class="hljs-comment">//目前总共支持的中断数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFLAGS_IF   0x00000200  <span class="hljs-comment">//eflags寄存器中的if位为1</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GET_EFLAGS(EFLAG_VAR)   asm volatile (<span class="hljs-string">&quot;pushfl; popl %0&quot;</span> : <span class="hljs-string">&quot;=g&quot;</span> (EFLAG_VAR)) <span class="hljs-comment">//将此时eflag寄存器中的值传入指定参数EFLAG_VAR</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">syscall_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <span class="hljs-comment">//系统调用对应的中断入口例程</span><br><br><span class="hljs-comment">/*中断门描述符结构体*/</span><br><span class="hljs-comment">/*16位中断处理函数入口地址低16位， 16位中断处理函数代码段选择子，8位固定为0, 8位属性，16位中断处理函数入口地址高16位 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_desc</span>&#123;</span><br>    <span class="hljs-type">uint16_t</span> func_offest_low_word;<br>    <span class="hljs-type">uint16_t</span> selector;<br>    <span class="hljs-type">uint8_t</span> dcount;<br>    <span class="hljs-type">uint8_t</span> attribute;<br>    <span class="hljs-type">uint16_t</span> func_offest_high_word;<br>&#125;;<br><br><span class="hljs-type">char</span>* intr_name[IDT_DESC_CNT];      <span class="hljs-comment">//保存异常的名字</span><br>intr_handler idt_table[IDT_DESC_CNT];       <span class="hljs-comment">//中断处理程序数组,里面存放每种中断处理函数的地址</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_desc</span> <span class="hljs-title">idt</span>[<span class="hljs-title">IDT_DESC_CNT</span>];</span>  <span class="hljs-comment">//创建了一个中断描述符表IDT，里面每个元素都是八个字节的门描述符</span><br><span class="hljs-keyword">extern</span> intr_handler intr_entry_table[IDT_DESC_CNT];     <span class="hljs-comment">//声明了一个intr_handler类型的定义在kernel.S的中断处理函数入口数组</span><br><br><span class="hljs-comment">/*初始化8259A可编程中断控制器PIC*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">pic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-comment">/*初始化主片*/</span><br>   outb (PIC_M_CTRL, <span class="hljs-number">0x11</span>);   <span class="hljs-comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x20</span>);   <span class="hljs-comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x04</span>);   <span class="hljs-comment">// ICW3: IR2接从片. </span><br>   outb (PIC_M_DATA, <span class="hljs-number">0x01</span>);   <span class="hljs-comment">// ICW4: 8086模式, 正常EOI</span><br><br>   <span class="hljs-comment">/* 初始化从片 */</span><br>   outb (PIC_S_CTRL, <span class="hljs-number">0x11</span>);    <span class="hljs-comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x28</span>);    <span class="hljs-comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x02</span>);    <span class="hljs-comment">// ICW3: 设置从片连接到主片的IR2引脚</span><br>   outb (PIC_S_DATA, <span class="hljs-number">0x01</span>);    <span class="hljs-comment">// ICW4: 8086模式, 正常EOI</span><br>   <br>   <span class="hljs-comment">/*只开了键盘中断和定时器中断*/</span><br>   outb (PIC_M_DATA, <span class="hljs-number">0xfc</span>);<br>   outb (PIC_S_DATA, <span class="hljs-number">0xff</span>);<br><br>   put_str(<span class="hljs-string">&quot;pic_init done\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*创建中断门描述符*/</span><br><span class="hljs-comment">/*输入：未初始化的门描述符指针，门描述符内对应的属性，中断处理函数入口地址*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">make_idt_desc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gate_desc* p_gdesc, <span class="hljs-type">uint8_t</span> attr, intr_handler function)</span>&#123;<br>    p_gdesc -&gt; func_offest_low_word = (<span class="hljs-type">uint32_t</span>)function &amp; <span class="hljs-number">0x0000ffff</span>;<br>    p_gdesc -&gt; selector = SELECTOR_K_CODE;<br>    p_gdesc -&gt; dcount = <span class="hljs-number">0</span>;<br>    p_gdesc -&gt; attribute = attr;<br>    p_gdesc -&gt; func_offest_high_word = ((<span class="hljs-type">uint32_t</span>)function &amp; <span class="hljs-number">0xffff0000</span>) &gt;&gt; <span class="hljs-number">16</span>;<br>&#125;<br><br><span class="hljs-comment">/*初始化中断描述符表*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">idt_desc_init</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> lastindex = IDT_DESC_CNT - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; IDT_DESC_CNT; i++)&#123;<br>        make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);<br>    &#125;<br>    make_idt_desc(&amp;idt[lastindex], IDT_DESC_ATTR_DPL3,syscall_handler);<br>    put_str(<span class="hljs-string">&quot;idt_desc_init done!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*一些通用的中断对应的处理函数，一般用在异常出现时的处理*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">general_intr_handler</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> vec_nr)</span><br>&#123;<br>    <span class="hljs-comment">// IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。</span><br>    <span class="hljs-keyword">if</span> (vec_nr == <span class="hljs-number">0x27</span> || vec_nr == <span class="hljs-number">0x2f</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    set_cursor(<span class="hljs-number">0</span>); <span class="hljs-comment">// 光标设置在0号位</span><br>    <span class="hljs-type">int</span> cursor_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((cursor_pos++) &lt; <span class="hljs-number">320</span>) <span class="hljs-comment">// 一行80字 4行空格</span><br>        put_char(<span class="hljs-string">&#x27; &#x27;</span>);<br><br>    set_cursor(<span class="hljs-number">0</span>);<br>    put_str(<span class="hljs-string">&quot;!!!!!!            excetion message begin            !!!!!!\n&quot;</span>);<br>    set_cursor(<span class="hljs-number">88</span>);             <span class="hljs-comment">// 第二行第八个字开始打印</span><br>    put_str(intr_name[vec_nr]); <span class="hljs-comment">// 打印中断向量号</span><br>    <span class="hljs-keyword">if</span> (vec_nr == <span class="hljs-number">14</span>)   <span class="hljs-comment">//处理发生PageFault时的情况</span><br>    &#123;<br>        <span class="hljs-type">int</span> page_fault_vaddr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">asm</span>(<span class="hljs-string">&quot;movl %%cr2,%0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(page_fault_vaddr)); <span class="hljs-comment">// 发生PF时控制器会将产生错误的虚拟地址存到cr2寄存器中</span><br>        put_str(<span class="hljs-string">&quot;\npage fault addr is &quot;</span>);<br>        put_int(page_fault_vaddr);<br>    &#125;<br>    put_str(<span class="hljs-string">&quot;!!!!!!            excetion message end              !!!!!!\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*完成一般中断处理函数注册及异常名称注册*/</span><br><span class="hljs-comment">/*构造好intr_name中每个中断的名字，以及idt_table中每个中断对应的处理函数地址*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">exception_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;    <br>   <span class="hljs-type">int</span> i;<br>   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; IDT_DESC_CNT; i++) &#123;<br>      idt_table[i] = general_intr_handler;    <span class="hljs-comment">// 默认所有中断函数初始的处理函数为general_intr_handler。</span><br>      intr_name[i] = <span class="hljs-string">&quot;unknown&quot;</span>;    <span class="hljs-comment">// 先统一赋值为unknown </span><br>   &#125;<br>   intr_name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;#DE Divide Error&quot;</span>;<br>   intr_name[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;#DB Debug Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;NMI Interrupt&quot;</span>;<br>   intr_name[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;#BP Breakpoint Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;#OF Overflow Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;#BR BOUND Range Exceeded Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">6</span>] = <span class="hljs-string">&quot;#UD Invalid Opcode Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">7</span>] = <span class="hljs-string">&quot;#NM Device Not Available Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">8</span>] = <span class="hljs-string">&quot;#DF Double Fault Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">9</span>] = <span class="hljs-string">&quot;Coprocessor Segment Overrun&quot;</span>;<br>   intr_name[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;#TS Invalid TSS Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">11</span>] = <span class="hljs-string">&quot;#NP Segment Not Present&quot;</span>;<br>   intr_name[<span class="hljs-number">12</span>] = <span class="hljs-string">&quot;#SS Stack Fault Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">13</span>] = <span class="hljs-string">&quot;#GP General Protection Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">14</span>] = <span class="hljs-string">&quot;#PF Page-Fault Exception&quot;</span>;<br>   <span class="hljs-comment">// intr_name[15] 第15项是intel保留项，未使用</span><br>   intr_name[<span class="hljs-number">16</span>] = <span class="hljs-string">&quot;#MF x87 FPU Floating-Point Error&quot;</span>;<br>   intr_name[<span class="hljs-number">17</span>] = <span class="hljs-string">&quot;#AC Alignment Check Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">18</span>] = <span class="hljs-string">&quot;#MC Machine-Check Exception&quot;</span>;<br>   intr_name[<span class="hljs-number">19</span>] = <span class="hljs-string">&quot;#XF SIMD Floating-Point Exception&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/*完成有关中断的所有初始化工作*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">idt_init</span><span class="hljs-params">()</span>&#123;<br>    put_str(<span class="hljs-string">&quot;idt_init start\n&quot;</span>);<br>    idt_desc_init();        <span class="hljs-comment">//初始化中断描述符表</span><br>    pic_init();     <span class="hljs-comment">//初始化8259A</span><br>    <span class="hljs-comment">/*利用idtr指令加载idt*/</span><br>    <span class="hljs-comment">/*中断描述符表寄存器idtr，低16位是界限，高32位是idt基地址*/</span><br>    <span class="hljs-type">uint64_t</span> idt_operand = ((<span class="hljs-keyword">sizeof</span>(idt) - <span class="hljs-number">1</span>) | ((<span class="hljs-type">uint64_t</span>)(<span class="hljs-type">uint32_t</span>)idt &lt;&lt; <span class="hljs-number">16</span>));<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lidt %0&quot;</span> : : <span class="hljs-string">&quot;m&quot;</span> (idt_operand))</span>;<br>    put_str(<span class="hljs-string">&quot;idt_init done\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有些在global.h和io.h的通用宏<br>global.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KERNEL_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNEL_GLOBAL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL0  0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL1  1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL2  2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RPL3  3</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TI_GDT 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TI_LDT 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFLAGS_MBS(1 &lt;&lt; 1)    <span class="hljs-comment">//必须要设置</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFLAGS_IF_1(1 &lt;&lt; 9)    <span class="hljs-comment">//if为1，开中断</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFLAGS_IF_00           <span class="hljs-comment">//if为0，关中断</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFLAGS_IOPL_3(3 &lt;&lt; 12)   <span class="hljs-comment">// IOPL3</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFLAGS_IOPL_0(0 &lt;&lt; 12)   <span class="hljs-comment">//IOPL0</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void*)0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PG_SIZE 4096</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIV_ROUND_UP(X,STEP) ((X + STEP - 1) / STEP)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> default_prio   31</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_STACK3_VADDR (0xc0000000 - 0x1000)</span><br><br><span class="hljs-comment">//--------------   GDT描述符属性  ------------</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_G_4K1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_D_321</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_L0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_AVL0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_P1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_00</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_11</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_22</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_DPL_33</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_S_CODE1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_S_DATADESC_S_CODE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_S_SYS0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_TYPE_CODE8</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_TYPE_DATA 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DESC_TYPE_TSS  9</span><br><br><span class="hljs-comment">/*KERNEL段*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_CODE   ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_DATA   ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_STACK          SELECTOR_K_DATA </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_K_GS           ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><span class="hljs-comment">/*这里是TSS*/</span><br><span class="hljs-comment">/*USER段*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_U_CODE     ((5 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_U_DATA   ((6 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SELECTOR_U_STACK   SELECTOR_U_DATA</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_ATTR_HIGH   ((DESC_G_4K &lt;&lt; 7) + (DESC_D_32 &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_CODE_ATTR_LOW_DPL3    ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_CODE &lt;&lt; 4) + DESC_TYPE_CODE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GDT_DATA_ATTR_LOW_DPL3    ((DESC_P &lt;&lt; 7) + (DESC_DPL_3 &lt;&lt; 5) + (DESC_S_DATA &lt;&lt; 4) + DESC_TYPE_DATA)</span><br><br><br><br><span class="hljs-comment">//--------------   IDT描述符属性  ------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_P 1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_DPL0   0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_DPL3   3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_32_TYPE     0xE   <span class="hljs-comment">// 32位的门</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_16_TYPE     0x6   <span class="hljs-comment">// 16位的门，不用，定义它只为和32位门区分</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_ATTR_DPL0  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL0 &lt;&lt; 5) + IDT_DESC_32_TYPE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDT_DESC_ATTR_DPL3  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL3 &lt;&lt; 5) + IDT_DESC_32_TYPE)</span><br><br><br><span class="hljs-comment">//--------------   TSS描述符属性  ------------</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TSS_DESC_D 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TSS_ATTR_HIGH ((DESC_G_4K &lt;&lt; 7) + (TSS_DESC_D &lt;&lt; 6) + (DESC_L &lt;&lt; 5) + (DESC_AVL &lt;&lt; 4) + 0X0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TSS_ATTR_LOW  ((DESC_P &lt;&lt; 7) + (DESC_DPL_0 &lt;&lt; 5) + (DESC_S_SYS &lt;&lt; 4) + DESC_TYPE_TSS)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  SELECTOR_TSS  ((4 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)</span><br><br><span class="hljs-comment">/*描述符结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gdt_desc</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint16_t</span> limit_low_word;<br>    <span class="hljs-type">uint16_t</span> base_low_word;<br>    <span class="hljs-type">uint8_t</span>  base_mid_byte;<br>    <span class="hljs-type">uint8_t</span>  attr_low_byte;<br>    <span class="hljs-type">uint8_t</span>  limit_high_attr_high;<br>    <span class="hljs-type">uint8_t</span>  base_high_byte;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>io.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KERNEL_IO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNEL_IO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdint.h&quot;</span></span><br><br><span class="hljs-comment">/*向端口port写入一个字节*/</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port, <span class="hljs-type">uint8_t</span> data)</span>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;outb %b0, %w1&quot;</span> :  : <span class="hljs-string">&quot;a&quot;</span> (data), <span class="hljs-string">&quot;Nd&quot;</span> (port))</span>;<br>&#125;<br><br><span class="hljs-comment">/*将addr处起始的word_cnt个字写入端口port*/</span><br><span class="hljs-comment">/*汇编里使用outsw会将es：edi指向内存中的字数据输出到dx指定的端口*/</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outsw</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">uint32_t</span> word_cnt)</span>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;cld ; rep outsw&quot;</span> : <span class="hljs-string">&quot;+S&quot;</span> (addr), <span class="hljs-string">&quot;+c&quot;</span> (word_cnt) : <span class="hljs-string">&quot;d&quot;</span> (port))</span>;<br>&#125;<br><br><span class="hljs-comment">/* 将从端口port读入的一个字节返回 */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint8_t</span> <span class="hljs-title function_">inb</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port)</span> &#123;<br>   <span class="hljs-type">uint8_t</span> data;<br>   <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;inb %w1, %b0&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (data) : <span class="hljs-string">&quot;Nd&quot;</span> (port))</span>;<br>   <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">/* 将从端口port读入的word_cnt个字写入addr */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">insw</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port, <span class="hljs-type">void</span>* addr, <span class="hljs-type">uint32_t</span> word_cnt)</span> &#123;<br>   <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;cld; rep insw&quot;</span> : <span class="hljs-string">&quot;+D&quot;</span> (addr), <span class="hljs-string">&quot;+c&quot;</span> (word_cnt) : <span class="hljs-string">&quot;d&quot;</span> (port) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>创建文件init.c，以后所有初始化函数都放在这个文件中<br>init.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*负责初始化所有模块*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_all</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    put_str(<span class="hljs-string">&quot;init_all\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-6-总结一下目前中断的流程（以时钟中断为例）"><a href="#7-6-总结一下目前中断的流程（以时钟中断为例）" class="headerlink" title="7.6 总结一下目前中断的流程（以时钟中断为例）"></a>7.6 总结一下目前中断的流程（以时钟中断为例）</h2><ol><li>首先调用 <code>idt_init();</code> 函数，完成中断的初始化工作：<ul><li>调用 <code>idt_desc_init()</code> ，初始化中断描述符表<ul><li>利用for循环，遍历当前允许的中断个数，创建中断描述符</li><li>每个for中调用 <code>make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function)</code> 函数，在idt[i]处创建对应的中断描述符，描述符的DPL设置为0，对应的中断处理程序入口地址为intr_entry_table[i]，也就是在kernel.S中设置的数组元素</li><li>暂且将所有中断设置为DPL为0，以后用户进程会特殊设置系统调用的中断</li><li>执行完这个函数后，达到的效果是，在interrupt.c开头设置的静态全局变量 <code>static struct gate_desc idt[IDT_DESC_CNT]</code> idt数组即中断描述符表存储了已经初始化好的各个中断描述符，每个中断描述符设置了对应的DPL和中断程序入口</li></ul></li><li>调用 <code>exception_init</code>，完成一般中断处理函数注册及异常名称注册，构造好intr_name中每个中断的名字，以及idt_table中每个中断对应的处理函数地址<ul><li>注意，在kernel.S中的intr_entry_table[i]实际上是个伪入口，只完成了函数调用前的入栈保护和一些调用后的出栈恢复操作，在这里面实际上还有个 <code>call [idt_table + %1 * 4]</code> ，这里的数组idt_table才是真正的每个中断函数的处理逻辑</li><li>for循环遍历，先默认所有中断函数初始的处理函数为 general_intr_handler ，也就是for循环设置数组 idt_table 里每个元素为函数general_intr_handler</li><li>然后逐一初始化一堆中断函数的名字</li></ul></li><li>调用 <code>pic_init()</code> 初始化8259A<ul><li>初始化8259A的主片和从片，具体参考8259A手册</li><li>控制打开某些中断                                ，目前打开了定时器中断和键盘中断</li></ul></li><li>利用idtr指令加载idt，其实就是把定义的数组idt以符合idtr的形式加载进去，<code>asm volatile(&quot;lidt %0&quot; : : &quot;m&quot; (idt_operand));</code></li></ul></li><li>然后通过<code>sti</code>指令打开中断</li><li>打开中断后，时钟中断会每隔一段时间触发一次，8259A将中断号发送给CPU，CPU读取中断号后，在idtr中找到idt，根据中断号在idt中找到对应的中断门描述符，在对应的中断门描述符中找到中断处理程序目标代码段的段选择子和偏移地址，其实就是找到kernel.S中定义的中断处理程序入口地址intr_entry_table[i]，在里面完成环境的备份后，通过idt_table数组，找到对应的中断处理程序，执行完毕后iret，一步一步返回到中断前的状态。</li></ol><h2 id="7-7-可编程计数器-定时器8253的原理"><a href="#7-7-可编程计数器-定时器8253的原理" class="headerlink" title="7.7 可编程计数器&#x2F;定时器8253的原理"></a>7.7 可编程计数器&#x2F;定时器8253的原理</h2><p>相当于外部设备，原理的话也记不住，要用到的时候再查，利用timer可以控制时钟中断的频率，目前设置为100Hz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;io.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;timer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;debug.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;interrupt.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IRQ0_FREQUENCY 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_FREQUENCY        1193180</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNTER0_VALUEINPUT_FREQUENCY / IRQ0_FREQUENCY</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNTER0_PORT0X40</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNTER0_NO 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNTER_MODE2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_WRITE_LATCH3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIT_COUNTROL_PORT0x43</span><br><br><span class="hljs-type">uint32_t</span> ticks;     <span class="hljs-comment">//ticks是内核开启时钟中断以来总共的滴答数</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">frequency_set</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> counter_port ,<span class="hljs-type">uint8_t</span> counter_no,<span class="hljs-type">uint8_t</span> rwl,<span class="hljs-type">uint8_t</span> counter_mode,<span class="hljs-type">uint16_t</span> counter_value)</span><br>&#123;<br>    outb(PIT_COUNTROL_PORT,(<span class="hljs-type">uint8_t</span>) (counter_no &lt;&lt; <span class="hljs-number">6</span> | rwl &lt;&lt; <span class="hljs-number">4</span> | counter_mode &lt;&lt; <span class="hljs-number">1</span>));<br>    outb(counter_port,(<span class="hljs-type">uint8_t</span>)counter_value);<br>    outb(counter_port,(<span class="hljs-type">uint8_t</span>)counter_value &gt;&gt; <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125; <br><br><span class="hljs-comment">/*时钟的中断处理函数*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">intr_timer_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>* <span class="hljs-title">cur_thread</span> =</span> running_thread();  <span class="hljs-comment">//获取当前线程的PCB</span><br>    ASSERT(cur_thread -&gt; stack_magic == <span class="hljs-number">0x19870916</span>);        <span class="hljs-comment">//判断该线程的线程栈是否有溢出</span><br>    cur_thread -&gt; elapsed_ticks++;      <span class="hljs-comment">//让当前线程占用cpu的总时间++</span><br>    ticks++;        <span class="hljs-comment">//ticks是内核开启时钟中断以来总共的滴答数</span><br>    <span class="hljs-comment">//如果当前线程的tick用完了，则下CPU，进入调度函数，如果没用完，则继续该线程，并让该线程的tick自减</span><br>    <span class="hljs-keyword">if</span>(cur_thread -&gt; ticks == <span class="hljs-number">0</span>)&#123;<br>        schedule();<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cur_thread -&gt; ticks--;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">timer_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    put_str(<span class="hljs-string">&quot;timer_init start!\n&quot;</span>);<br>    frequency_set(COUNTER0_PORT,COUNTER0_NO,READ_WRITE_LATCH,COUNTER_MODE,COUNTER0_VALUE);<br>    register_handler(<span class="hljs-number">0x20</span>, intr_timer_handler);      <span class="hljs-comment">//注册时钟中断处理程序的代码</span><br>    put_str(<span class="hljs-string">&quot;timer_init done!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第六章 完善内核</title>
    <link href="/2024/12/25/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2024/12/25/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="6-1-汇编和C混合编程"><a href="#6-1-汇编和C混合编程" class="headerlink" title="6.1 汇编和C混合编程"></a>6.1 汇编和C混合编程</h2><ol><li>单独的汇编文件和单独的C文件分别编译成目标文件后，一起链接成可执行程序。</li><li>在C语言中嵌入汇编代码，直接编译生成可执行程序。</li></ol><h2 id="6-2-操控显卡实现打印函数"><a href="#6-2-操控显卡实现打印函数" class="headerlink" title="6.2 操控显卡实现打印函数"></a>6.2 操控显卡实现打印函数</h2><p>大致方法为，在地址寄存器中指定寄存器的索引值，用来确定所操作的寄存器是哪个，然后在数据寄存器中对该索引的寄存器进行读写操作<br>print.S:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">TI_GDT <span class="hljs-built_in">equ</span> <span class="hljs-number">0</span><br>RPL0 <span class="hljs-built_in">equ</span> <span class="hljs-number">0</span><br>SELECTOR_VIDEO <span class="hljs-built_in">equ</span> (<span class="hljs-number">0x0003</span> &lt;&lt; <span class="hljs-number">3</span>) + TI_GDT + RPL0    <span class="hljs-comment">;设置video段的段选择子</span><br><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]<br><span class="hljs-meta">section</span> .data<br>put_int_buffer  <span class="hljs-built_in">dq</span>  <span class="hljs-number">0</span><span class="hljs-comment">;  定义8个字节的缓冲区用于数字到字符的转换</span><br><br><span class="hljs-meta">section</span> .text<br><span class="hljs-comment">;--------------------------------put_char--------------------------</span><br><span class="hljs-meta">global</span> put_char<br><span class="hljs-symbol">put_char:</span><br>    <span class="hljs-keyword">pushad</span>      <span class="hljs-comment">;备份32位的寄存器，包括eax，ecx，edx，ebx，esp，ebp，esi，edi</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, SELECTOR_VIDEO<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">;让段寄存器gs存放video段的段选择子</span><br>    <span class="hljs-comment">;获取光标位置</span><br>    <span class="hljs-comment">;获取光标高8位位置</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0e</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>  <span class="hljs-comment">;向CRT的0x03d4地址寄存器写入0x0e</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span>   <span class="hljs-comment">;再从CRT的0x03d5数据寄存器中读取光标高8位存入al</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-built_in">al</span>  <span class="hljs-comment">;将光标高8位存入ah</span><br>    <span class="hljs-comment">;获取光标低8位位置</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>  <span class="hljs-comment">;向CRT的0x03d4地址寄存器写入0x0f</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span>   <span class="hljs-comment">;再从CRT的0x03d5数据寄存器中读取光标低8位存入al</span><br>    <span class="hljs-comment">;将光标存入bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">ax</span><br>    <span class="hljs-comment">;在栈中获取要打印的字符，调用put_char会将打印的字符压入栈中，再压函数返回地址（4字节），上面又进行了pushad压了32字节</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, [<span class="hljs-built_in">esp</span> + <span class="hljs-number">36</span>]     <span class="hljs-comment">;因此esp + 36指向要打印的字符（1个字节），其实就存在cl里面</span><br>    <span class="hljs-comment">;判断回车换行与退格</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0x0d</span>    <br>    <span class="hljs-keyword">jz</span> .is_carriage_return  <span class="hljs-comment">;如果是回车，则跳转</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0x0a</span><br>    <span class="hljs-keyword">jz</span> .is_line_feed        <span class="hljs-comment">;如果是换行，则跳转</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0x08</span><br>    <span class="hljs-keyword">jz</span> .is_backspace        <span class="hljs-comment">;如果是退格，则跳转</span><br>    <span class="hljs-keyword">jmp</span> .put_other          <span class="hljs-comment">;如果都不是，则跳转</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  .is_backspace:</span>        <br>    <span class="hljs-comment">;实现退格</span><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">bx</span>      <span class="hljs-comment">;bx存储了光标的位置，让光标位置自减</span><br>    <span class="hljs-keyword">shl</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>   <span class="hljs-comment">;让bx左移1位，乘2，即光标在内存的位置</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-number">0x20</span>      <span class="hljs-comment">;让该处的字符显示为空格</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>      <span class="hljs-comment">;让bx++，此时bx指向该处字符的属性</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-number">0x07</span>      <span class="hljs-comment">;让该处的字符属性为默认黑底白字的0x07</span><br>    <span class="hljs-keyword">shr</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>   <span class="hljs-comment">;让bx右移1位，除以2，即光标的位置，此时光标位置被更新为退格后的位置，且该位置显示空格</span><br>    <span class="hljs-keyword">jmp</span> set_cursor     <span class="hljs-comment">;更新光标位置</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  .put_other:</span><br>    <span class="hljs-comment">;打印可见字符</span><br>    <span class="hljs-keyword">shl</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">;bx乘2变为光标在内存的位置</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-number">0x07</span><br>    <span class="hljs-keyword">shr</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">;让光标恢复之前位置</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>          <span class="hljs-comment">;光标指向下一个位置</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2000</span><br>    <span class="hljs-keyword">jl</span> set_cursor  <span class="hljs-comment">;若光标位置&lt;80*25=2000，则说明屏幕未满，可以直接跳转到更新光标位置，如果屏幕满了，则滚屏</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  .is_carriage_return:</span><br><span class="hljs-symbol">  .is_line_feed:</span><br>    <span class="hljs-comment">;回车换行处理</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">dx</span>      <span class="hljs-comment">;清空dx，dx存放被除数</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>, <span class="hljs-number">80</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">si</span>          <span class="hljs-comment">;光标位置除以80取余存在dx</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">dx</span>      <span class="hljs-comment">;光标位置回到行头</span><br><span class="hljs-symbol">  .is_carriage_return_end:</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">80</span>      <span class="hljs-comment">;光标位置跳转到下一行</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2000</span>    <span class="hljs-comment">;比较是否屏幕满了</span><br><span class="hljs-symbol">  .is_line_feed_end:</span><br>    <span class="hljs-keyword">jl</span> set_cursor  <span class="hljs-comment">;没满则更新光标位置，满了则滚屏</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  .roll_screen:</span><br>    <span class="hljs-comment">;滚屏</span><br>    <span class="hljs-keyword">cld</span>     <span class="hljs-comment">;清除方向位</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">960</span>        <span class="hljs-comment">;将前24行的数据往上搬运一行，(1920*2)/4=960</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0xc00b80a0</span> <span class="hljs-comment">;第1行地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>, <span class="hljs-number">0xc00b8000</span> <span class="hljs-comment">;第0行地址</span><br>    <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsd</span>   <span class="hljs-comment">;将数据从源地址（由DS:ESI寄存器指定）复制到目标地址（由ES:EDI寄存器指定），执行复制操作后，ESI和EDI寄存器的值会根据方向标志位（DF）的值自动增加</span><br>    <span class="hljs-comment">;将最后一行填充为空白</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">3840</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">80</span><br><span class="hljs-symbol">  .cls:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">ebx</span>], <span class="hljs-number">0x0720</span><span class="hljs-comment">;  0720是黑底白字的空格</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">loop</span> .cls<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1920</span><br><br><span class="hljs-meta">global</span> set_cursor<br><span class="hljs-symbol">set_cursor:</span><br>    <span class="hljs-comment">;将光标值设置为bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0e</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">bh</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x03d5</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">bl</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br><span class="hljs-symbol">  .put_char_done:</span><br>    <span class="hljs-keyword">popad</span><br>    <span class="hljs-keyword">ret</span><br><br><span class="hljs-comment">;-----------------------------------------put_str-----------------------------</span><br><span class="hljs-meta">global</span> put_str   <br><span class="hljs-symbol">put_str:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">xor</span>  <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span>                 <span class="hljs-comment">;一般用ebp来寻值 esp上面有个4字节的返回地址 就没有了</span><br>    <span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ebx</span>,[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">16</span>]            <span class="hljs-comment">;指针4字节+12字节寄存器</span><br><span class="hljs-symbol"> .put_char_loop:</span>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">ebx</span>]<br>    <span class="hljs-keyword">cmp</span>  <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">je</span>  .str_end<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">call</span> put_char<br>    <span class="hljs-keyword">add</span>  <span class="hljs-built_in">esp</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">inc</span>  <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">jmp</span> .put_char_loop<br><span class="hljs-symbol"> .str_end:</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">ret</span><br><br><span class="hljs-meta">global</span> put_int<br><span class="hljs-symbol">put_int:</span><br>    <span class="hljs-keyword">pushad</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,[<span class="hljs-built_in">esp</span>+<span class="hljs-number">36</span>]        <span class="hljs-comment">;32字节+4返回地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>,<span class="hljs-number">7</span>               <span class="hljs-comment">;put_int_buffer偏移量</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-number">8</span>               <span class="hljs-comment">;循环八次</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,put_int_buffer<br><span class="hljs-symbol"> .16based_4bits:</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">0xF</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">0x9</span>             <br>    <span class="hljs-keyword">jg</span>  .is_A2F             <span class="hljs-comment">;进入A～F ASCII码处理</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>,<span class="hljs-string">&#x27;0&#x27;</span>             <span class="hljs-comment">;得0~9的ascii</span><br>    <span class="hljs-keyword">jmp</span> .store    <br><span class="hljs-symbol"> .is_A2F:</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">10</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>,<span class="hljs-string">&#x27;A&#x27;</span>             <span class="hljs-comment">;减去10等于A～F的字符序 + &#x27;A&#x27;得ascii   </span><br><span class="hljs-symbol"> .store:</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-built_in">edi</span>],<span class="hljs-built_in">dl</span>        <span class="hljs-comment">;偏移量 倒序储存在buf</span><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">edi</span>                 <span class="hljs-comment">;-1</span><br>    <span class="hljs-keyword">shr</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">loop</span> .16based_4bits    <span class="hljs-comment">;8个16进制ascii入账 且还是大端序 妙</span><br><span class="hljs-symbol"> .ready_to_print:</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">edi</span>                 <span class="hljs-comment">;减去8次成-1了 先循环+1次</span><br><span class="hljs-symbol"> .skip_prefix_0:</span>            <span class="hljs-comment">;处理前缀0</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edi</span>,<span class="hljs-number">8</span>               <span class="hljs-comment">;edi偏移量 8的时候表示第九个字符</span><br>    <span class="hljs-keyword">je</span>  .full0              <span class="hljs-comment">;全是0 </span><br><span class="hljs-symbol"> .go_on_skip:</span>   <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,[put_int_buffer+<span class="hljs-built_in">edi</span>]<br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>,<span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-keyword">je</span>  .skip_prefix_0      <span class="hljs-comment">;跳转回去看看是不是最后一个数字了</span><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">edi</span>                 <span class="hljs-comment">;不是的0的话 就到下面打印字符时间</span><br>    <span class="hljs-keyword">jmp</span> .put_each_num<br><span class="hljs-symbol"> .full0:</span><br>    <span class="hljs-keyword">mov</span>  <span class="hljs-built_in">cl</span>,<span class="hljs-string">&#x27;0&#x27;</span><br><span class="hljs-symbol"> .put_each_num:</span><br>    <span class="hljs-keyword">mov</span>  <span class="hljs-built_in">cl</span>,[put_int_buffer+<span class="hljs-built_in">edi</span>]<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">call</span> put_char<br>    <span class="hljs-keyword">add</span>  <span class="hljs-built_in">esp</span>,<span class="hljs-number">4</span><br>    <span class="hljs-keyword">inc</span>  <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">cmp</span>  <span class="hljs-built_in">edi</span>,<span class="hljs-number">8</span><br>    <span class="hljs-keyword">jge</span> .end<br>    <span class="hljs-keyword">jmp</span> .put_each_num<br><span class="hljs-symbol"> .end:</span><br>    <span class="hljs-keyword">popad</span> <br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h2 id="6-3-内联汇编"><a href="#6-3-内联汇编" class="headerlink" title="6.3 内联汇编"></a>6.3 内联汇编</h2><p>内联汇编也就是GCC编译器支持在C语言下直接嵌入汇编代码<br>我们平常使用的汇编语言大多是Intel语法，与微软系统DOS和WINDOWS有关<br>Linux使用的汇编是AT&amp;T语法</p><p>AT&amp;T语法的一些特殊点：</p><ol><li>寄存器前面有前缀%</li><li>源操作数在左边，目的操作数在右边</li><li>指令的最后一个字母表示操作数的大小</li><li>立即数有前缀%</li></ol><p>最简单的内联形式是基本内联汇编，格式为：<br><code>asm [volatile] (&quot;汇编代码&quot;)</code><br>但是在基本内联汇编中，若要引用C变量，只能将它定义为全局变量。</p><p>扩展内联汇编，格式为：<br><code>asm [volatile] (&quot;assembly code&quot; : output : input : clobber/modify)</code></p><ul><li>assembly code：和基本内联汇编一样，还是用户的汇编代码</li><li>output：用来指定汇编代码的数据如何输出给C代码使用，有约束</li><li>input：用来指定C中数据如何输入给汇编使用，有约束</li><li>clobber&#x2F;modify：一般不用</li></ul><p>例如：<br><code>asm (&quot;addl %%ebx, %%eax&quot; : &quot;=a&quot; (out_sum) : &quot;a&quot; (in_a), &quot;b&quot; (in_b));</code> 等价于<br><code>asm (&quot;addl %2, %1&quot; : &quot;=a&quot; (out_sum) : &quot;a&quot; (in_a), &quot;b&quot; (in_b));</code><br>其中”&#x3D;a”是只写的意思，”a”是约束在eax寄存器，”b”是约束在ebx寄存器</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第五章 保护模式进阶</title>
    <link href="/2024/12/23/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <url>/2024/12/23/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="5-1-获取物理内存容量"><a href="#5-1-获取物理内存容量" class="headerlink" title="5.1 获取物理内存容量"></a>5.1 获取物理内存容量</h2><p>在linux中有多种获取容量的方法，如果其中一种方法失败，就会尝试调用别的方法，很多都是通过BIOS中断进行检测，但BIOS中断是实模式下的方法，因此只能在进入保护模式前调用，所以需要在进入保护模式前检测完内存容量。<br>具体检测方式分为三种，具体详情可参考<a href="https://blog.csdn.net/weixin_43903639/article/details/129834247">这里</a></p><p>在进入保护模式前补充代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;----------------------------------loader_start----------------------------</span><br><span class="hljs-symbol">loader_start:</span><br>    <span class="hljs-comment">;进入保护模式之前，需要先检测内存</span><br>    <span class="hljs-comment">;先执行中断0x15子功能0xe820，遍历主机上的所有内存</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,LOADER_BASE_ADDR<span class="hljs-comment">;设置栈顶为LOADER_BASE_ADDR</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ebx</span>    <span class="hljs-comment">;第一次调用时，ebx一定要置为0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">;将段寄存器es置为0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>, ards_buf    <span class="hljs-comment">;ed：di是ards结构的缓冲区</span><br><span class="hljs-symbol">  .e820_mem_get_loop:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x0000e820</span>   <span class="hljs-comment">;eax存放子功能号</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0x534d4150</span> <span class="hljs-comment">;edx固定签名  </span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">20</span>         <span class="hljs-comment">;ecx存放ards结构体的大小，默认是20字节</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x15</span>        <span class="hljs-comment">;调用0x15中断</span><br>    <span class="hljs-keyword">jc</span> .e820_failed_so_try_e801     <span class="hljs-comment">;CF=1表示出错则尝试下一个检测内存的方法，即0xe801中断</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>, <span class="hljs-built_in">cx</span>      <span class="hljs-comment">;让es：di的di指针指向下一个新的ards结构位置</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">word</span> [ards_nr]      <span class="hljs-comment">;ards数量+1</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">0</span>      <br>    <span class="hljs-keyword">jnz</span> .e820_mem_get_loop      <span class="hljs-comment">;如果ebx不为0，说明还有结构体没返回，则继续循环，如果为0，说明下一个结构体为0，即遍历完了</span><br>    <span class="hljs-comment">;做一个简单的查找，找到内存上限最大的那个ards，并把内存上限存到total_mem_bytes</span><br>    <span class="hljs-comment">;对BaseAddrLow + LengthLow 的值进行判断，该值表示对应ards对应的内存上限</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, [ards_nr]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,ards_buf<br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">edx</span><br><span class="hljs-symbol">  .find_max_mem_area:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebx</span>]<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebx</span> + <span class="hljs-number">8</span>]<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">20</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">jge</span> .next_ards<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">  .next_ards:</span><br>    <span class="hljs-keyword">loop</span> .find_max_mem_area<br>    <span class="hljs-keyword">jmp</span> .mem_get_ok<br>  <br>  <span class="hljs-comment">;如果0xe820不成功，则尝试0xe801</span><br><span class="hljs-symbol">  .e820_failed_so_try_e801:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xe801</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x15</span><br>    <span class="hljs-keyword">jc</span> .e801_failed_so_try_88<br>    <span class="hljs-comment">; 1. 先算低于15MB的内存</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">0x400</span><br>    <span class="hljs-keyword">mul</span> <span class="hljs-built_in">cx</span>          <span class="hljs-comment">;1024字节*ax,乘积的低位放在ax，高位放在dx</span><br>    <span class="hljs-keyword">shl</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">16</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x0000FFFF</span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0x100000</span>       <span class="hljs-comment">;加上1MB的内存空缺</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">edx</span>    <br>    <span class="hljs-comment">; 2.接着算16MB以上的内存 以字节为单位</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">0x10000</span><br>    <span class="hljs-keyword">mul</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">jmp</span> .mem_get_ok<br><br>  <span class="hljs-comment">;如果0xe801失败了，则尝试0x88</span><br><span class="hljs-symbol">  .e801_failed_so_try_88:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x88</span><br>     <span class="hljs-keyword">int</span> <span class="hljs-number">0x15</span><br>     <span class="hljs-keyword">jc</span> .error_hlt<br>     <span class="hljs-keyword">and</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x0000FFFF</span><br>     <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0x400</span>                                        <br>     <span class="hljs-keyword">mul</span> <span class="hljs-built_in">cx</span><br>     <span class="hljs-keyword">shl</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">16</span><br>     <span class="hljs-keyword">or</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">eax</span> <br>     <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">0x100000</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  .error_hlt:</span><br>    <span class="hljs-keyword">jmp</span> $<br><span class="hljs-comment">;将内存上限赋给total_mem_bytes</span><br><span class="hljs-symbol">  .mem_get_ok:</span><br>    <span class="hljs-keyword">mov</span> [total_mem_bytes], <span class="hljs-built_in">edx</span><br></code></pre></td></tr></table></figure><h2 id="5-2-页表"><a href="#5-2-页表" class="headerlink" title="5.2 页表"></a>5.2 页表</h2><p>分页机制<strong>建立在分段机制</strong>上，经过段部件生成的线性地址，如果分页机制没打开，则直接映射为物理地址，如果分页地址已打开，则通过页部件检索页表找到对应的物理地址。</p><h3 id="5-2-1-为什么要分页"><a href="#5-2-1-为什么要分页" class="headerlink" title="5.2.1 为什么要分页"></a>5.2.1 为什么要分页</h3><p>分页机制通过将内存分为固定大小的页面（通常是4KB）来简化内存管理。每个页面大小固定，操作系统只需要跟踪页面的分配情况，而不需要像分段机制那样处理可变大小的内存段。分段机制要求操作系统处理不同大小的段，并根据每个段的具体需求进行内存分配。这种不定长的段可能会导致<strong>内存碎片</strong>，尤其是在系统运行一段时间后，内存管理变得更加复杂。</p><p>分页机制非常适合实现 虚拟内存。操作系统可以将一个进程的地址空间划分为多个固定大小的页面，并根据需要将这些页面映射到物理内存中的任意位置。分页机制使得操作系统能够将进程的<strong>虚拟地址空间和物理内存分开</strong>，从而可以实现 <strong>内存隔离 和 程序共享</strong>。</p><p>分页机制通过 页表 管理虚拟地址到物理地址的映射。页表是一种非常简单且高效的数据结构，它将虚拟地址分为两部分：页号和页内偏移。页表的查找过程和操作是直接和<strong>快速</strong>的。页表通常较小，内存开销较低。</p><h3 id="5-2-2-页表具体结构"><a href="#5-2-2-页表具体结构" class="headerlink" title="5.2.2 页表具体结构"></a>5.2.2 页表具体结构</h3><p>32位系统中，利用二级页表进行分页：</p><ol><li>分为页目录和页表，页目录有1024项，叫做页目录项PDE，每个页目录项对应一个页表，每个页表有1024项，叫做页表项。</li><li>每个页目录项有32位，即4个字节，低12位是属性，高24位是该页目录项对应页表的地址。</li><li>所以，页目录本身需要占据4096即4KB的内存空间。</li><li>每个页表项有32位，即4个字节，低12位是属性，高24位是该页表项对应的物理页的地址。</li><li>所以，页表本身需要占据4096即4KB的内存空间。</li><li>所以，一个PTE映射一个物理页即4KB，一个页表映射1024个物理页即4M，一个页目录映射1024个页表即4G。</li><li>32位的虚拟地址，高10位在页目录中找对应页目录项的下标，找到后根据该PDE的高20位找到对应页表。</li><li>32位的虚拟地址，中10位在上一步找到的页表中找对应页表项的下标，找到后根据该PTE的高20位找到对应物理页。</li><li>32位的虚拟地址，低12位在上一步找到的物理页中充当偏移地址，找到4KB的物理页对应的字节。</li></ol><p><img src="/../img/20241223201027.png" title="页目录和页表表项结构"></p><h3 id="5-2-3-如何启动分页机制"><a href="#5-2-3-如何启动分页机制" class="headerlink" title="5.2.3 如何启动分页机制"></a>5.2.3 如何启动分页机制</h3><ol><li>准备好页目录和页表</li><li>将页目录地址写入控制寄存器cr3</li><li>寄存器cr0的PG位置1</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;----------------------------------------创建页目录和页表-----------------------------------</span><br><span class="hljs-symbol">setup_page:</span><br>    <span class="hljs-comment">;将页目录项清空</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">0x1000</span>     <span class="hljs-comment">;循环4096次，因为页目录有1024项，每项占4字节</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">  .clear_page_dir:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="hljs-built_in">esi</span>], <span class="hljs-number">0</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">loop</span> .clear_page_dir<br>    <span class="hljs-comment">;创建页目录项PDE</span><br><span class="hljs-symbol">  .create_pde:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, PAGE_DIR_TABLE_POS<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x1000</span>     <span class="hljs-comment">;eax存放第一个页表的地址</span><br>    <span class="hljs-comment">;设定特殊的页目录项，0,768,1023</span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>, PG_P | PG_RW_W | PG_US_U <br>    <span class="hljs-keyword">mov</span> [PAGE_DIR_TABLE_POS+<span class="hljs-number">0x0</span>],<span class="hljs-built_in">eax</span>       <span class="hljs-comment">;把页目录的第0项和第768项对应的页表设置为最低端的物理内存              </span><br>    <span class="hljs-keyword">mov</span> [PAGE_DIR_TABLE_POS+<span class="hljs-number">0xc00</span>],<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x1000</span>      <br>    <span class="hljs-keyword">mov</span> [PAGE_DIR_TABLE_POS+<span class="hljs-number">4092</span>],<span class="hljs-built_in">eax</span>       <span class="hljs-comment">;虚拟内存最后一个页目录项，指向页目录本身，为了可以通过虚拟地址访问页表本身</span><br>    <span class="hljs-comment">;创建内核对应页表的映射</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, PAGE_DIR_TABLE_POS<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x1000</span>         <span class="hljs-comment">;此时eax存放的是第一个页表的位置</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">256</span>            <span class="hljs-comment">;由于内核应该是小于1M，一个页表项有4KB，所以暂时先设置256个页表项</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, PG_P | PG_RW_W | PG_US_U <br><span class="hljs-symbol">  .create_kernel_pte:</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">eax</span> + <span class="hljs-built_in">esi</span>*<span class="hljs-number">4</span>], <span class="hljs-built_in">ebx</span>      <span class="hljs-comment">;将页表对应的值设置为，也可以说映射到对应的内存起点</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">0x1000</span>          <span class="hljs-comment">;页的大小为4KB，所以在映射下一个页时，应该加4096</span><br>    <span class="hljs-keyword">loop</span> .create_kernel_pte         <span class="hljs-comment">;循环，直到把第一个页表的前256个页表项都映射到内存0-1M处</span><br>    <span class="hljs-comment">;创建页目录第768项之后的映射关系</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, PAGE_DIR_TABLE_POS<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x2000</span>     <span class="hljs-comment">;eax存了第二个页表地址</span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>, PG_P | PG_RW_W | PG_US_U<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, PAGE_DIR_TABLE_POS<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">254</span>        <span class="hljs-comment">;一共有1024个页目录项，最后一个特殊，则要循环1024-1-769=254</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">769</span>        <span class="hljs-comment">;从第769个目录项开始</span><br><span class="hljs-symbol">  .create_kernel_pde:</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">ebx</span> + <span class="hljs-built_in">esi</span>*<span class="hljs-number">4</span>], <span class="hljs-built_in">eax</span>      <span class="hljs-comment">;从第769个目录项映射第2个页表，以此递推</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x1000</span><br>    <span class="hljs-keyword">loop</span> .create_kernel_pde<br><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>我们模仿linux，虚拟空间的最高1GB给操作系统，供所有用户共享，低3GB给进程，属于每个进程私有<br>上述代码完成了如下映射：</p><ol><li>页目录项0 映射 第1个页表         </li><li>页目录项c00，即768 映射 第1个页表</li><li>页目录项769到1022 映射 第2到254个页表</li><li>最后一个页目录项 映射 页目录本身基地址</li><li>第一个页表映射为低端0-1M的内存，还有3M未作映射</li></ol><p><strong>为什么页目录项0和768都要映射到第一个页表？</strong>  原因是我们在加载内核前，运行的都是Loader，它本身代码都在1MB以内，必须保证之前段机制下的线性地址和分页后的虚拟地址对应的物理地址一致，所以用页目录项0来保证loader在分页机制下依然可以使用。我们是把操作系统放在物理地址低端1M以内的，但设置的虚拟空间3G以上存放操作系统，所以要将虚拟地址3G以上1M映射到物理地址低端1M以内，即页目录项768要映射到第一个页表。<br><strong>为什么最后一个页目录项 映射 页目录本身基地址？</strong>  方便用虚拟地址来找到页表的位置</p><p><img src="/../img/20241223202440.png" title="当前页目录和页表在内存的位置"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;----------------------------------------打开分页-----------------------------------</span><br>    <span class="hljs-comment">;创建页目录以及对应页表的映射</span><br>    <span class="hljs-keyword">call</span> setup_page<br>    <span class="hljs-comment">;将当前段描述符地址以及偏移量写入内存gdt_ptr</span><br>    <span class="hljs-keyword">sgdt</span> [gdt_ptr]<br>    <span class="hljs-comment">;gdt是六个字节大小，前两个字节是偏移量，后面四个字节是基址，将gdt基址放到ebx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [gdt_ptr + <span class="hljs-number">2</span>]<br>    <span class="hljs-comment">;更改视频段的段基址，改到3GB以上    </span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span> + <span class="hljs-number">0x18</span> + <span class="hljs-number">4</span>], <span class="hljs-number">0xc0000000</span><br>    <span class="hljs-comment">;把gdt的基址也搬到3GB以上</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">dword</span> [gdt_ptr + <span class="hljs-number">2</span>], <span class="hljs-number">0xc0000000</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">0xc0000000</span><br>    <span class="hljs-comment">;将页表基址放到cr3，打开cr0，开启页表</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, PAGE_DIR_TABLE_POS<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr3</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cr0</span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x80000000</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">lgdt</span> [gdt_ptr]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">160</span>], <span class="hljs-string">&#x27;V&#x27;</span><br>    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">jmp</span> SELECTOR_CODE:enter_kernel<br></code></pre></td></tr></table></figure><p>运行bochs，输入info tab，查看当前GDT表的映射<br><img src="/../img/14a85b2f67e64e6c1251de12c580544b.png" title="当前GDT表的映射"></p><h3 id="5-2-4-快表TLB"><a href="#5-2-4-快表TLB" class="headerlink" title="5.2.4 快表TLB"></a>5.2.4 快表TLB</h3><p>分页机制虽然很灵活，但是从一个虚拟地址映射到物理地址，还是需要经过很复杂的过程，而且处理器的速度和内存的速度不是一个级别，页表存储在内存中，处理器会被迫等待内存的响应造成时间的浪费。<br>因此，处理器专门准备了一个高速缓存，专门存放虚拟地址页框和物理地址页框对应的映射关系，这个缓存叫TLB，俗称快表。<br>TLB中存储的是虚拟页框到物理页框的映射结果，还有一些属性位。<br>TLB需要开发人员手动更新，尽管TLB不可见，但依然有两种方法简介更新：</p><ul><li>重新加载cr3，会使整个TLB失效</li><li>利用指令invlpg([虚拟地址])，可以单独刷新TLB中某个虚拟地址对应的条目，将来在内存管理中会涉及到这个操作。</li></ul><h2 id="5-3-加载内核"><a href="#5-3-加载内核" class="headerlink" title="5.3 加载内核"></a>5.3 加载内核</h2><p>从这里开始脱离汇编，利用c语言进行内核的编写。<br>利用gcc的命令将c文件编译为可重定位文件.o 例如<code>gcc -c -o kernel/main.bin kernel/main.c</code><br>利用ld指令，例如<code>ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin</code>，将内核链接到虚拟地址0xc0001500处，入口函数为main<br>利用dd命令，例如<code>dd if=/home/myos/build/kernel.bin of=/home/myos/master.img bs=512 count=200 seek=9 conv=notrunc</code>，将内核代码复制到硬盘的第10个扇区处</p><p>需要利用elf文件的特性进行解码，内核文件先被加载到内存的0x70000处，再根据elf格式将内核映像的代码放到0x1500处，elf格式以后再研究，实际上就是跳过elf文件头，根据elf文件头的信息找到不同的segment，再遍历每个segment并将每个segment加载到对应的虚拟内存的位置</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;----------------------- 初始化内核 把缓冲区的内核代码放到0x1500区域 ------------------------------------------</span><br><span class="hljs-comment">;这个地方主要对elf文件头部分用的很多</span><br><span class="hljs-comment">;可以参照着书上给的格式 来比较对比</span><br><span class="hljs-symbol">kernel_init:</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>   <span class="hljs-comment">;全部清零</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">edx</span><br>    <br>    <span class="hljs-comment">;这里稍微解释一下 因为0x70000 为64kb*7=448kb 而我们的内核映射区域是4MB 而在虚拟地址4MB以内的都可以当作1:1映射</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,[KERNEL_BIN_BASE_ADDR+<span class="hljs-number">28</span>]<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>,KERNEL_BIN_BASE_ADDR                               <span class="hljs-comment">;ebx当前位置为程序段表</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,[KERNEL_BIN_BASE_ADDR+<span class="hljs-number">42</span>]         <span class="hljs-comment">;获取程序段表每个条目描述符字节大小</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,[KERNEL_BIN_BASE_ADDR+<span class="hljs-number">44</span>]                         <span class="hljs-comment">;一共有几个段</span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">     </span><br><span class="hljs-symbol"> .get_each_segment:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">0</span>],PT_NULL<br>    <span class="hljs-keyword">je</span> .PTNULL                                                 <span class="hljs-comment">;空即跳转即可 不进行mem_cpy</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,[<span class="hljs-built_in">ebx</span>+<span class="hljs-number">8</span>]<br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">0xc0001500</span><br>    <span class="hljs-keyword">jb</span> .PTNULL<br>    <br>        <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">16</span>]                                        <span class="hljs-comment">;ebx+16在存储的数是filesz  可以翻到Loader刚开始</span><br>                                                               <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,[<span class="hljs-built_in">ebx</span>+<span class="hljs-number">4</span>]                                            <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>,KERNEL_BIN_BASE_ADDR<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>                                                   <span class="hljs-comment">;p_offset 在文件中的偏移位置    源位置         </span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dword</span> [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">8</span>]                                         <span class="hljs-comment">;目标位置</span><br>     <br>    <span class="hljs-keyword">call</span> mem_cpy<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">12</span>                                                 <span class="hljs-comment">;把三个参数把栈扔出去 等于恢复栈指针</span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol"> .PTNULL:</span><br>    <span class="hljs-keyword">add</span>  <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">edx</span>                                               <span class="hljs-comment">;edx是一个描述符字节大小</span><br>    <span class="hljs-keyword">loop</span> .get_each_segment                                     <span class="hljs-comment">;继续进行外层循环    </span><br>    <span class="hljs-keyword">ret</span><br><span class="hljs-symbol">                                        </span><br><span class="hljs-symbol">mem_cpy:</span><br>    <span class="hljs-keyword">cld</span>                                                        <span class="hljs-comment">;向高地址自动加数字 cld std 向低地址自动移动</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>                                                   <span class="hljs-comment">;保存ebp 因为访问的时候通过ebp 良好的编程习惯保存相关寄存器</span><br>    <span class="hljs-keyword">mov</span>  <span class="hljs-built_in">ebp</span>,<span class="hljs-built_in">esp</span> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span>                                                   <span class="hljs-comment">;外层循环还要用 必须保存 外层eax存储着还有几个段</span><br>    <br>                                                               <span class="hljs-comment">;分析一下为什么是 8 因为进入的时候又重新push了ebp 所以相对应的都需要+4</span><br>                                                               <span class="hljs-comment">;并且进入函数时 还Push了函数返回地址 所以就那么多了</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>,[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">8</span>]                                            <span class="hljs-comment">;目的指针 edi存储的是目的位置 4+4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>,[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">12</span>]                                           <span class="hljs-comment">;源指针   源位置             8+4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">16</span>]                                           <span class="hljs-comment">;与Movsb好兄弟 互相搭配      12+4</span><br>    <br>    <br>    <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                                                  <span class="hljs-comment">;一个一个字节复制</span><br>       <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span> <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>将main函数的栈顶设置为0xc009f000</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;------------------------------- 跳转到内核区------------------------------------------------   </span><br><span class="hljs-symbol">enter_kernel:</span><br>    <span class="hljs-keyword">call</span> kernel_init          <span class="hljs-comment">;根据我们的1M以下的内存分布区 综合考虑出的数据</span><br>    <span class="hljs-keyword">mov</span>  <span class="hljs-built_in">esp</span>,<span class="hljs-number">0xc009f000</span>             <span class="hljs-comment">;作为main主线程的PCB的栈顶，PCB占一页，所以主线程PCB起始地址为0xc009e000</span><br>    <span class="hljs-keyword">jmp</span>  KERNEL_ENTER_ADDR<br></code></pre></td></tr></table></figure><h2 id="5-4-特权级的深入浅出"><a href="#5-4-特权级的深入浅出" class="headerlink" title="5.4 特权级的深入浅出"></a>5.4 特权级的深入浅出</h2><h3 id="5-4-1-特权级的那点事"><a href="#5-4-1-特权级的那点事" class="headerlink" title="5.4.1 特权级的那点事"></a>5.4.1 特权级的那点事</h3><ol><li>访问者的特权级可以变，受访者的特权级不能变</li><li>整个计算机世界的特权级检查，都是发生在访问者访问受访者的那一刹那</li></ol><h3 id="5-4-2-TSS简介"><a href="#5-4-2-TSS简介" class="headerlink" title="5.4.2 TSS简介"></a>5.4.2 TSS简介</h3><p>TSS，即任务状态段，是处理器原本想实现多任务的一种方式，但是后来都没有使用这种方式进行多任务处理<br>TSS是每个任务都有的机构，它用于一个任务的标识，相当于任务的身份证。<br><img src="/../img/20160924135346461.png" title="32位TSS结构"></p><ol><li>任务在进行特权级变换时，本质上是处理器当前特权级在变换。</li><li>处理器在不同特权级时，应该使用不同特权级的栈。</li><li>特权级转移分为两类：一类是通过中断门、调用门等手段实现低特权级向高特权级的转移，另一类则是由调用返回指令从高特权级返回到低特权级，这是唯一一种能让特权级降级的方式。</li><li>当处理器由低权级转到高权级时，会自动到对应TSS找到对应高权级的栈，并且会将自己本身的栈（低权级）压入栈中，这样到后面高权级转到低权级时，便可以找到低权级的栈在哪。</li></ol><h3 id="5-4-3-CPL和DPL入门"><a href="#5-4-3-CPL和DPL入门" class="headerlink" title="5.4.3 CPL和DPL入门"></a>5.4.3 CPL和DPL入门</h3><p>RPL，请求特权级，在段选择子的第0到1位中。<br>只有指令才具有请求、访问其他资源的能力，指令又存在于代码段，因此就用代码段寄存器CS中选择子的RPL位表示代码请求别人资源能力的等级。<br>代码段寄存器CS和指令指针寄存器EIP中指向的指令便是当前处理器正在运行的代码，因此，CS.RPL不仅称为请求特权级，也是处理器当前特权级。</p><p>DPL，段描述符特权级，存储在不同段的段描述符的DPL字段上。</p><p>CPL，处理器当前的特权级，在任意时刻，当前特权级CPL保存在CS选择子中的RPL字段上。<br>其实只有CS选择子中的RPL字段与CPL有关系，其他选择子的RPL和CPL都没有关系。</p><p>访问者任何时候都不允许访问比自己特权更高的资源，无论受访资源是数据还是代码。（只是原则上而已）<br>受访者是数据段时，访问者的权限应大于等于数据段的DPL。<br>受访者是代码段时，访问者的权限应等于代码段的DPL，即平级访问。</p><p>处理器提供了多种方式用于从低权级的代码转移到高权级的代码，其中一个就是一致性代码段。<br>一致性代码段的定义在段描述符中，如果S为0即非系统段，则type里的C字段若为1，则为一致性代码段。<br>一致性代码段要求，若自己是转移后的代码段，则自己的特权级一定要大于等于转移前的特权级，一致性代码段的一大特点是转移后的特权级不以转移后的代码段为主，而是以转移前为主，即转移后本身的CPL不变。</p><p>代码段可以有一致性和非一致性 ， 但数据段只有非一致性，即数据段不允许被比本数据段特权级更低的代码段访问。</p><h3 id="5-4-4-门与RPL"><a href="#5-4-4-门与RPL" class="headerlink" title="5.4.4 门与RPL"></a>5.4.4 门与RPL</h3><p>门结构就是记录一段程序起始地址的描述符，分为任务门、中断门、陷阱门、调用门，实际上我们只使用了中断门。<br>利用门可以实现从低权级的代码段转向高权级的代码段，当前的CPL一定要大于等于门描述符的DPL，且一定要小于等于目标代码段的DPL。</p><p>特权级检查实际上就是让CPU检查CPL与RPL的等级是否都大于DPL，两者必须同时满足。</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第四章 保护模式入门</title>
    <link href="/2024/12/23/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2024/12/23/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-保护模式"><a href="#4-1-保护模式" class="headerlink" title="4.1 保护模式"></a>4.1 保护模式</h2><h3 id="4-1-1-为什么要有保护模式"><a href="#4-1-1-为什么要有保护模式" class="headerlink" title="4.1.1 为什么要有保护模式"></a>4.1.1 为什么要有保护模式</h3><p>32位的CPU可以兼容实模式和保护模式。</p><ol><li>实模式下操作系统内核和用户处于同一等级</li><li>用户指向的地址都是真实的地址，即一一映射</li><li>用户可以自由更改段基址，可以访问所有内存</li><li>以上三点属于安全缺陷。</li><li>访问超过64KB的内存则需要更改段基址</li><li>共20条地址线，最大使用内存为1M</li></ol><h3 id="4-1-2-保护模式有什么"><a href="#4-1-2-保护模式有什么" class="headerlink" title="4.1.2 保护模式有什么"></a>4.1.2 保护模式有什么</h3><ol><li>地址线扩展到32位，可以访问4GB的内存</li><li>通用寄存器等扩展到32位，但段寄存器保持16位就够了</li><li>段描述符</li><li>指令扩展，寻址扩展，运行模式反转</li><li>通过<code>[bits 32]</code>告诉编译器将之后的代码编译为32位的机器码</li></ol><h3 id="4-1-3-打开保护模式的3个步骤"><a href="#4-1-3-打开保护模式的3个步骤" class="headerlink" title="4.1.3 打开保护模式的3个步骤"></a>4.1.3 打开保护模式的3个步骤</h3><ol><li>打开A20线</li><li>加载gdt，gdt是全局描述符表</li><li>将cr0的pe位置为1</li></ol><h2 id="4-2-全局描述符表"><a href="#4-2-全局描述符表" class="headerlink" title="4.2 全局描述符表"></a>4.2 全局描述符表</h2><p>保护模式下，内存段不再是通过段寄存器加载段基址就可以使用，还需要很多额外的信息，全局描述符表（GDT）相当于保护模式下内存段的登记表</p><h3 id="4-2-1-段描述符"><a href="#4-2-1-段描述符" class="headerlink" title="4.2.1 段描述符"></a>4.2.1 段描述符</h3><p>段描述符专门用来描述一个内存段<br><img src="/../img/803de1573406001061536d589f7fa8b5.png" title="段描述符格式"></p><ul><li>段描述符占8个字节</li><li>segment limit：段界限共20位，表示段边界的扩展最值，单位要么是字节，要么是4KB</li><li>base address：段基址</li><li>G：为0表示粒度为1字节，为1表示粒度为4KB</li><li>S：为0表示系统段（也就是各种门），为1表示非系统段（也可以说是数据段）</li><li>P：present，表示段是否存在于内存，存在则为1，否则为0。P字段由CPU负责检查，若为0会抛出异常，异常处理程序由程序员编写。</li><li>L：表示是否为64位代码段，我们目前环境是32位，置0即可</li><li>AVL：avaluable，是否可用，为1则可用</li><li>DPL：描述符的特权级，以后详述</li><li>Type：根据是否为系统段，Type有不同的含义，主要关注非系统的的type<br><img src="/../img/b373b459b532fb173e40af172c7afc75.png" title="代码段和数据段段描述符类型"></li></ul><h3 id="4-2-2-全局描述符表GDT"><a href="#4-2-2-全局描述符表GDT" class="headerlink" title="4.2.2 全局描述符表GDT"></a>4.2.2 全局描述符表GDT</h3><p>一个段描述符只用来描述一个内存段，代码段、栈段、数据段等很多内存段都各自需要段描述符，因此需要一个地方存储这些段描述符，这个地方就是全局描述符表GDT，其实就是个数组，数组中每个元素都是8字节的段描述符，全局体现在GDT是各个程序公用的<br>GDT最多存储8192个段描述符</p><h3 id="4-2-3-GDTR寄存器"><a href="#4-2-3-GDTR寄存器" class="headerlink" title="4.2.3 GDTR寄存器"></a>4.2.3 GDTR寄存器</h3><p>GDT也是放在内存中的，但是如何找到GDT？通过专门的GDTR寄存器，CPU便可找到GDT<br><img src="/../img/f4655dce9d916c19a687e12797106c76.png" title="GDTR寄存器"><br>GDTR是一个48位的寄存器，低16位是GDT数组的界限，也就是GDT数组的大小-1，高32位是GDT数组在内存中的起始地址。</p><p>我们需要将内存中的某个位置设定为GDT的起始地址，并在该位置开始定义所需要的段描述符<br>再通过<code>lgdt 48位内存数据</code>指令，将GDT的起始地址和界限加载到GDTR中，这样“全局”的作用才能真正体现。</p><h3 id="4-2-4-段选择子"><a href="#4-2-4-段选择子" class="headerlink" title="4.2.4 段选择子"></a>4.2.4 段选择子</h3><p><img src="/../img/7b0cae74bbf7125b005d886b1e18a8f3.png" title="段选择子"><br>实模式下，段寄存器存储的是段基址，保护模式下，段寄存器存储的是段选择子<br>段选择子类似于一个有属性的索引，属性部分为：</p><ul><li>低2位，RPL，即请求特权级</li><li>第三位，TI，为0表示在GDT中索引，为1表示在LDT中索引，LDT是局部描述符表<br>索引体现在：</li><li>高13位，表示对GDT中第几个段描述符的索引，2^13&#x3D;8192，刚好8192个段描述符</li></ul><h2 id="4-3-进入保护模式"><a href="#4-3-进入保护模式" class="headerlink" title="4.3 进入保护模式"></a>4.3 进入保护模式</h2><p>目前系统状态：BIOS-&gt;MBR 0x7c00-&gt;Loader 0x900<br>Loader.S：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">%include</span> <span class="hljs-string">&quot;boot.inc&quot;</span><br><span class="hljs-meta">SECTION</span> loader vstart=LOADER_BASE_ADDR  <span class="hljs-comment">;0x900</span><br>LOADER_STACK_TOP <span class="hljs-built_in">equ</span> LOADER_BASE_ADDR   <span class="hljs-comment">;设置程序的栈区，但其实用不到</span><br><span class="hljs-keyword">jmp</span> loader_start    <span class="hljs-comment">;跳转到代码区执行，下面的存放数据区来构建gdt,jmp指令占3个字节</span><br></code></pre></td></tr></table></figure><p>接下来定义需要的数据，包括短描述符，段选择子，gdtr需要存储的48位数据等</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;-----------------------------------数据存放-----------------------------------</span><br><span class="hljs-comment">;定义GDT的第一个段描述符，默认64位全0</span><br><span class="hljs-symbol">GDT_BASE:</span>   <span class="hljs-built_in">dd</span> <span class="hljs-number">0x00000000</span><br>            <span class="hljs-built_in">dd</span> <span class="hljs-number">0x00000000</span><br><span class="hljs-comment">;定义GDT的第二个段描述符，这里设置为代码段描述符</span><br><span class="hljs-symbol">CODE_DESC:</span>  <span class="hljs-built_in">dd</span> <span class="hljs-number">0x0000ffff</span><br>            <span class="hljs-built_in">dd</span> DESC_CODE_HIGH4<br><span class="hljs-comment">;定义GDT的第三个段描述符，这里设置为代码段描述符</span><br><span class="hljs-symbol">DATA_STACK_DESC:</span>    <span class="hljs-built_in">dd</span> <span class="hljs-number">0x0000ffff</span><br>                    <span class="hljs-built_in">dd</span> DESC_DATA_HIGH4<br><span class="hljs-comment">;定义GDT的第四个段描述符，这里设置为屏幕段描述符</span><br><span class="hljs-comment">;0xB8000 到0xBFFFF为文字模式显示内存，为了方便操作，这里不采用平坦模型，将段基址设为0xb8000，段大小为0x7fff</span><br><span class="hljs-comment">;粒度为4K，因此段界限等于0x7fff/4k=7</span><br><span class="hljs-symbol">VIDEO_DESC:</span> <span class="hljs-built_in">dd</span> <span class="hljs-number">0x80000007</span><br>            <span class="hljs-built_in">dd</span> DESC_VIDEO_HIGH4<br><span class="hljs-comment">;设置GDT的大小和limit</span><br>GDT_SIZE    <span class="hljs-built_in">equ</span> $ - GDT_BASE<br>GDT_LIMIT   <span class="hljs-built_in">equ</span> GDT_SIZE - <span class="hljs-number">1</span><br><span class="hljs-comment">;预留60个 四字型 描述符，方便以后扩展</span><br><span class="hljs-built_in">times</span> <span class="hljs-number">59</span> <span class="hljs-built_in">dq</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">times</span> <span class="hljs-number">5</span> <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>        <span class="hljs-comment">;文件开头在内存的0x900开始，到这里一共占用了3+4*8+59*8+5=512个字节,即0x200个字节</span><br><br>total_mem_bytes <span class="hljs-built_in">dd</span> <span class="hljs-number">0</span>    <span class="hljs-comment">;此时total_mem_bytes在内存中的位置是0x900+0x200=0xb00，total_mem_bytes以下的字节才可能可以用，以上的字节一定不能用</span><br><br><span class="hljs-comment">;定义段选择子</span><br>SELECTOR_CODE        <span class="hljs-built_in">equ</span> (<span class="hljs-number">0X0001</span>&lt;&lt;<span class="hljs-number">3</span>) + TI_GDT + RPL0    <br>SELECTOR_DATA  <span class="hljs-built_in">equ</span> (<span class="hljs-number">0X0002</span>&lt;&lt;<span class="hljs-number">3</span>) + TI_GDT + RPL0<br>SELECTOR_VIDEO       <span class="hljs-built_in">equ</span> (<span class="hljs-number">0X0003</span>&lt;&lt;<span class="hljs-number">3</span>) + TI_GDT + RPL0<br><span class="hljs-comment">;定义gdt指针，2字节gdt界限放在前面 4字节gdt地址放在后面，共48位</span><br>gdt_ptr <span class="hljs-built_in">dw</span> GDT_LIMIT<br>        <span class="hljs-built_in">dd</span> GDT_BASE<br><span class="hljs-comment">;buf记录内存大小的缓冲区</span><br>ards_buf <span class="hljs-built_in">times</span> <span class="hljs-number">244</span> <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-comment">;nr记录20字节结构体ARDS的个数</span><br>ards_nr <span class="hljs-built_in">dw</span> <span class="hljs-number">0</span><br><span class="hljs-comment">;loadermsg 加载区显示字符</span><br>loadermsg <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;into loader&#x27;</span><br></code></pre></td></tr></table></figure><p>上述代码设置了4个段描述符，分别是默认段描述符全0，代码段描述符，数据段描述符（同时也作为栈段描述符），显存段描述符<br>值得注意，我们采用平坦模型，因此这里的代码段和数据段描述符都是DPL为0，基地址为0，上限为4GB，即覆盖所有内存，这样做的意义是因为后期有了页表的出现，则使用页表更好管理内存，因此只利用段描述符中的属性位进行程序设计。<br>Linux所有的段（用户代码段、用户数据段、内核代码段、内核数据段）的线性地址都是从 0x00000000 开始，所以，在 Linux 操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核;例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;------------------------------------设置进入保护模式---------------------------------</span><br><span class="hljs-comment">; 1 打开A20 gate</span><br><span class="hljs-comment">; 2 加载gdt</span><br><span class="hljs-comment">; 3 将cr0 的 pe位置1</span><br><br><span class="hljs-comment">;打开A20门</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span>                 <br><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010b</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span><br><br><span class="hljs-comment">;加载gdt</span><br><span class="hljs-keyword">lgdt</span> [gdt_ptr]<br><br><span class="hljs-comment">;将cr0 的 pe位置1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span>                <span class="hljs-comment">;cr0寄存器第0位设置位1</span><br><span class="hljs-keyword">or</span>  <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x00000001</span>              <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span><br></code></pre></td></tr></table></figure><p>设置后gdt后，按照上述三个步骤即可让cpu切换至保护模式。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;----------------------------------------已经打开保护模式了-----------------------------------</span><br><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> SELECTOR_CODE:p_mode_start                       <span class="hljs-comment">;刷新流水线</span><br><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]<br><span class="hljs-symbol">p_mode_start:</span> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,SELECTOR_DATA<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>,LOADER_STACK_TOP<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,SELECTOR_VIDEO<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>,<span class="hljs-built_in">ax</span><br></code></pre></td></tr></table></figure><p>流水线知识暂不详谈<br>利用<code>[bits 32]</code>告诉编译器已经进入保护模式，接下来的指令都应该用32位<br>进入保护模式后，段寄存器存储的应该是选择子，所以用数据段选择子初始化所有段寄存器，并将gs段寄存器初始化为显存段的段选择子</p><h2 id="4-4-流水线相关知识"><a href="#4-4-流水线相关知识" class="headerlink" title="4.4 流水线相关知识"></a>4.4 流水线相关知识</h2><h3 id="4-4-1-什么叫做流水线"><a href="#4-4-1-什么叫做流水线" class="headerlink" title="4.4.1 什么叫做流水线"></a>4.4.1 什么叫做流水线</h3><p>举个简单的例子描述流水线：</p><ol><li>现在需要一直往墙上锤钉子，每锤一颗钉子，需要有两个步骤，第一步，取钉子，第二步，锤钉子</li><li>如果只有一个人，那么只能不断地取，锤，取，锤，假设每个操作都花费1秒，那么一分钟只能锤30钉子。如果有两个人，完全并行操作，显然一分钟能锤30*2&#x3D;60个钉子。</li><li>假设，一个人只能做一件事，不能既取钉子又锤钉子，就需要用到流水线的思想完成一个伪并行。</li><li>第一秒，A取钉子，B什么都不干；第二秒，B把A取的钉子锤下去，A继续取下一个钉子；第三秒，B继续把A取的钉子锤下去，A继续取下一个钉子……以此类推，最后一分钟内可以锤59个钉子，之后的每一分钟都可以锤60个钉子，利用流水线完成了伪并行。</li></ol><p>CPU执行一条指令，需要经过三个步骤，这三个步骤可以理解为由三个部件来完成，分别是：取指（控制单元），译码（译码器），执行（指令执行单元EU）。<br>CPU中对时间的度量单位是时钟周期。</p><p>CPU为了加快处理指令，也是采用流水线的方式执行。我们可以发现，流水线中区分的部分越多，各部分的时间越短，一定时间内完成的总任务量就越多，上述只是最原始的三级流水线，现在的CPU有的达到32级流水线。</p><h3 id="4-4-2-jmp-dword-SELECTOR-CODE-p-mode-start指令的意义"><a href="#4-4-2-jmp-dword-SELECTOR-CODE-p-mode-start指令的意义" class="headerlink" title="4.4.2 jmp dword SELECTOR_CODE:p_mode_start指令的意义"></a>4.4.2 jmp dword SELECTOR_CODE:p_mode_start指令的意义</h3><p>我们来看实模式跳转到保护模式的部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nasm">jmp dword SELECTOR_CODE:p_mode_start       <br>[bits 32]<br>p_mode_start: <br></code></pre></td></tr></table></figure><p>明明顺序执行就可以，但还是加了<code>jmp dword SELECTOR_CODE:p_mode_start</code>这行代码，不会显得多余吗？原因如下：</p><ol><li>更新段描述符缓冲寄存器：32为CPU在实模式下不是变成了16位CPU，只是可以兼容16位的指令而已。例如，16位CPU访问内存时是把段基址左移4位+段内偏移地址形成的，而32位CPU在实模式下是把段基址左移4位后放到段描述符缓冲寄存器中，再用该寄存器的值与段内偏移地址相加得到结果，实模式下段描述符缓冲寄存器只有低20位有效，高16位为0，因此如果进入保护模式后，段描述符缓存寄存器的值肯定是错的，需要更新。</li><li>由1可知，该行命令的SELECTOR_CODE被存入CS寄存器，可以将32位下正确的段描述符存入缓冲寄存器</li><li>清空流水线：根据前述对流水线的描述，在CPU执行一个指令时，该指令后面的部分指令其实已经上了流水线了，因此在这个实模式到保护模式的分界点，就会出现一条流水线上既有16位指令又有32位指令的存在，会引起指令错误。因此可以通过jmp指令，完成刷新流水线的功能。</li></ol><h2 id="4-5-保护模式后，未开启分页前，内存的访问流程"><a href="#4-5-保护模式后，未开启分页前，内存的访问流程" class="headerlink" title="4.5 保护模式后，未开启分页前，内存的访问流程"></a>4.5 保护模式后，未开启分页前，内存的访问流程</h2><ol><li>选择想要访问的段的选择子</li><li>将选择子放入段寄存器中</li><li>处理器检查TI，判断应该在gdtr中找到GDT还是ldtr中找到LDT进行索引</li><li>处理器检查RPL，与对应段的段描述符的DPL对比判断权限是否允许</li><li>处理器检查选择子的索引值，判断该索引值是否在GDT的下标中找得到，即是否为0或是否超过下标最大值</li><li>处理器判断对应段选择子与段寄存器是否匹配，如只具备可执行属性的代码段只能加载到CS段寄存器中</li><li>检查完毕都没问题，处理器将选择子正式放入段寄存器</li><li>通过选择子找到gdtr&#x2F;ldtr，再找到GDT&#x2F;LDT，再根据索引值找到对应下标的段选择子，再根据段选择子内的段基址进行内存的寻址。</li></ol><p>从上述可看出，段描述符虽然可以有保护作用，但是寻址一次很麻烦。</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第三章 完善MBR</title>
    <link href="/2024/12/23/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2024/12/23/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-实模式下的寄存器"><a href="#3-1-实模式下的寄存器" class="headerlink" title="3.1 实模式下的寄存器"></a>3.1 实模式下的寄存器</h2><p>CPU中的寄存器大致可分为两类：</p><ul><li>供内部使用，对程序员不可见：如全局描述符表寄存器GDTR,中断描述符表寄存器IDTR,任务寄存器TR等</li><li>对程序员可见，可直接操作：在实模式下默认的寄存器都是16位宽，可分为段寄存器和通用寄存器</li></ul><p>段寄存器：</p><ul><li>在实模式下，段寄存器用来存储段基址，作用是指定一片内存的起始地址。实模式下要乘以16</li><li>在保护模式下，段寄存器存储的是选择子，作用也是指定一片内存的起始地址。</li><li>CS代码段寄存器，DS数据段寄存器，ES附加段寄存器，FS附加段寄存器，GS附加段寄存器，SS栈段寄存器</li><li>采用直接寻址如[0x1234]时，默认段寄存器为CS，除非指明了[fs:0x1234]，采用基址寻址时，操作数可用bx寄存器或bp寄存器，bx默认段寄存器DS，bp默认段寄存器为SS。</li></ul><p>通用寄存器：<br><img src="/../img/f9fb637d2b5ecada0f2b43a3fe5c3dd2.png" title="通用寄存器介绍"></p><h2 id="3-2-利用IO接口控制显卡"><a href="#3-2-利用IO接口控制显卡" class="headerlink" title="3.2 利用IO接口控制显卡"></a>3.2 利用IO接口控制显卡</h2><p>IO接口是连接CPU和硬件的桥梁，在主板上由南桥芯片和北桥芯片负责，端口是IO接口给CPU的接口。IA32体系中，由于存储端口号的寄存器是16位，因此最大有65535个端口。<br>CPU提供专门的指令in和out进行端口读写，例如<code>in al, dx</code> <code>out dx, al</code><br>助记：左边是目的操作数，右边是源操作数，dx只作端口号使用，al或ax可存储数据使用</p><p>MBR中直接操控显存：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0xb800</span> <span class="hljs-comment">; ax为文本信号起始区</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>     <span class="hljs-comment">; ds = ax = 0xb800 寄存器寻址默认段寄存器为ds</span><br><br><span class="hljs-comment">;设置屏幕模式为文本模式，清除屏幕</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">3</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span> <br><br><span class="hljs-comment">;直接操作显存部分,输出Booting!,立即数寻址默认段寄存器为ds，</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x00</span>],<span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-comment">;低位字节储存ascii字符 小端储存内存顺序相反</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x01</span>],<span class="hljs-number">0x07</span>    <span class="hljs-comment">;背景储存在第二个字节</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x02</span>],<span class="hljs-string">&#x27;o&#x27;</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x03</span>],<span class="hljs-number">0x07</span>    <span class="hljs-comment">;默认属性黑底白字</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x04</span>],<span class="hljs-string">&#x27;o&#x27;</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x05</span>],<span class="hljs-number">0x07</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x06</span>],<span class="hljs-string">&#x27;t&#x27;</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x07</span>],<span class="hljs-number">0x07</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x08</span>],<span class="hljs-string">&#x27;i&#x27;</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x09</span>],<span class="hljs-number">0x07</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0A</span>],<span class="hljs-string">&#x27;n&#x27;</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0B</span>],<span class="hljs-number">0x07</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0C</span>],<span class="hljs-string">&#x27;g&#x27;</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0D</span>],<span class="hljs-number">0x07</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0E</span>],<span class="hljs-string">&#x27;!&#x27;</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [<span class="hljs-number">0x0F</span>],<span class="hljs-number">0x07</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">;让段寄存器回到0!!</span><br></code></pre></td></tr></table></figure><p>需要注意，显存每个字符需要两个字节，低字节是字符的ASCII码，高字节是字符的属性，如颜色、背景等</p><h2 id="3-3-让MBR读取硬盘"><a href="#3-3-让MBR读取硬盘" class="headerlink" title="3.3 让MBR读取硬盘"></a>3.3 让MBR读取硬盘</h2><p>目前硬盘结构每个扇区占512字节，而扇区0存储了MBR的代码，MBR的代码会被BIOS从硬盘加载到内存0x7c00处，但MBR固定512字节，能够完成的事情不多，因此在这里完成了基本的寄存器初始化以及打印显存引导信息后，需要把控制权移交到别处完成更多指令，这个“别处”就是以后要写的Loader.S，我们把它放到硬盘的第二扇区，中间空了扇区1是因为想隔开MBR和Loader。</p><p>MBR是BIOS加载到内存的，但Loader没法被BIOS加载到内存，因此这部分工作需要由MBR完成。</p><p>硬盘控制器属于IO接口，我们需要读写硬盘控制器的端口<br>硬盘控制机主要端口寄存器:</p><table><thead><tr><th><strong>IO端口</strong></th><th><strong>端口用途</strong></th><th><strong>Primary通道</strong></th><th><strong>Secondary通道</strong></th><th><strong>读操作时</strong></th><th><strong>写操作时</strong></th></tr></thead><tbody><tr><td>0x1f0</td><td>Data</td><td>0x1f0</td><td>0x170</td><td>Data</td><td>Data</td></tr><tr><td>0x1f1</td><td>Error</td><td>0x1f1</td><td>0x171</td><td>Error</td><td>Features</td></tr><tr><td>0x1f2</td><td>Sector count</td><td>0x1f2</td><td>0x172</td><td>Sector count</td><td>Sector count</td></tr><tr><td>0x1f3</td><td>LBA low</td><td>0x1f3</td><td>0x173</td><td>LBA low</td><td>LBA low</td></tr><tr><td>0x1f4</td><td>LBA mid</td><td>0x1f4</td><td>0x174</td><td>LBA mid</td><td>LBA mid</td></tr><tr><td>0x1f5</td><td>LBA high</td><td>0x1f5</td><td>0x175</td><td>LBA high</td><td>LBA high</td></tr><tr><td>0x1f6</td><td>Device</td><td>0x1f6</td><td>0x176</td><td>Device</td><td>Device</td></tr><tr><td>0x1f7</td><td>Status</td><td>0x1f7</td><td>0x177</td><td>Status</td><td>Command</td></tr><tr><td>0x3f6</td><td>Alternate status</td><td>0x3f6</td><td>0x376</td><td>Alternate status</td><td>Device Control</td></tr></tbody></table><p>MBR中读取硬盘：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">    <span class="hljs-keyword">mov</span>  <span class="hljs-built_in">eax</span>, LOADER_START_SECTOR     <span class="hljs-comment">;起始扇区号，2</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, LOADER_BASE_ADDR        <span class="hljs-comment">;要写入的内存地址，0x900</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">4</span>       <span class="hljs-comment">;读取的扇区数量</span><br>    <span class="hljs-keyword">call</span> read_disk<br><br>    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">jmp</span> LOADER_BASE_ADDR<span class="hljs-comment">;       系统跳转到内存0x900处进行loader</span><br><br><span class="hljs-comment">; eax=要读取的LBA起始扇区号， bx=读取扇区后要写入的内存地址， cx=读取的扇区数</span><br><span class="hljs-symbol">read_disk:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">eax</span>    <span class="hljs-comment">;备份eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>, <span class="hljs-built_in">cx</span>      <span class="hljs-comment">;备份cx</span><br>    <span class="hljs-comment">;读写硬盘</span><br>    <span class="hljs-comment">;第1步：设置要读取的扇区数量</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f2</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">cl</span>      <span class="hljs-comment">;删了可以吗?</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">esi</span><br>    <span class="hljs-comment">;第2步，将要读的起始扇区的地址存入对应端口</span><br>        <span class="hljs-comment">;低8位，0x1f3</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f3</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>        <span class="hljs-comment">;中8位，0x1f4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">8</span><br>    <span class="hljs-keyword">shr</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f4</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>        <span class="hljs-comment">;高8位，0x1f5</span><br>    <span class="hljs-keyword">shr</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f5</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>        <span class="hljs-comment">;最高的4位对应device寄存器的低4位，采用主盘LBA模式的话，device高4位是1110</span><br>    <span class="hljs-keyword">shr</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0xe0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f6</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>    <span class="hljs-comment">;第3步，向0x1f7端口写入读命令，0x20</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f7</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>    <span class="hljs-comment">;第4步，读取0x1f7端口，检测硬盘状态</span><br><span class="hljs-symbol">  .noready:</span><br>    <span class="hljs-keyword">nop</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x88</span>    <span class="hljs-comment">;第3位为1说明硬盘准备好数据传输，第7位为1说明硬盘繁忙</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x08</span><br>    <span class="hljs-keyword">jnz</span> .noready<br>    <span class="hljs-comment">;第5步，从0x1f0端口即data寄存器读取数据</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">di</span>  <span class="hljs-comment">;di是要读取的扇区数</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">256</span><br>    <span class="hljs-keyword">mul</span> <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-built_in">ax</span>  <span class="hljs-comment">;将要读取的次数存到cx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f0</span><br><span class="hljs-symbol">  .keep_read:</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">loop</span> .keep_read<br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>通过<code>call read_disk</code>然后<code>jmp LOADER_BASE_ADDR</code>，LOADER_BASE_ADDR设定为0x900，CPU将离开MBR区域，跳转到起始内存地址为0x900的Loader区域。</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第二章 编写MBR主引导记录</title>
    <link href="/2024/12/21/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2024/12/21/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="2-1-计算机的启动过程"><a href="#2-1-计算机的启动过程" class="headerlink" title="2.1 计算机的启动过程"></a>2.1 计算机的启动过程</h2><p>操作系统可以存储在硬盘上，软盘上，甚至U盘上，但CPU被设计成只能执行内存上的程序，因此需要把操作系统加载到内存上。</p><p>简单描述：主机上电，第一个执行的程序是BIOS，BIOS将MBR加载到内存0x7c00处，执行MBR，直到跳转至Loader，执行Loader，直到完成实模式到保护模式的跳转，并进入内核。</p><h2 id="2-2-什么是BIOS"><a href="#2-2-什么是BIOS" class="headerlink" title="2.2 什么是BIOS"></a>2.2 什么是BIOS</h2><p>全称，基本输入输出系统，是计算机上电执行的第一个程序。</p><h3 id="2-2-1-实模式的1MB内存布局"><a href="#2-2-1-实模式的1MB内存布局" class="headerlink" title="2.2.1 实模式的1MB内存布局"></a>2.2.1 实模式的1MB内存布局</h3><p><img src="/../img/5ae7e0414b7ea26b47afee774a6add0d.jpg" title="实模式的1MB内存布局"><br>要点：</p><ul><li>中断向量表IVT：在最低的1KB内存中，里面存储了不同中断向量号对应的入口程序，程序的具体内容不是存储在内存或者硬盘中的，是存储在固件中的，可能是闪存或BIOS芯片。</li><li>可用区域有：0x500-0x7bff约30KB  0x7e00-0x9fbff约608KB</li><li>MBR：起始地址在0x7c00，固定大小512字节</li><li>文本模式显存：0xb8000，占32KB</li><li>系统BIOS范围：0xF0000-0xFFFFF共640KB，其中0xFFFF0-0xFFFFF是BIOS入口地址。</li></ul><h3 id="2-2-2-地址总线"><a href="#2-2-2-地址总线" class="headerlink" title="2.2.2 地址总线"></a>2.2.2 地址总线</h3><p>以16位系统为例，其地址总线是20位，地址范围是1MB，访问内存的上限取决于地址总线而不是物理内存的上限，32位系统的地址总线是32位，范围是4GB，就算插入4GB的内存条，我们可用的内存也只有3.8G左右，因为地址总线需要预留一些地址用于访问外设。</p><h3 id="2-2-3-BIOS的苏醒过程"><a href="#2-2-3-BIOS的苏醒过程" class="headerlink" title="2.2.3 BIOS的苏醒过程"></a>2.2.3 BIOS的苏醒过程</h3><ol><li>BIOS被存储到只读存储器ROM里，ROM不可擦除，这一部分被映射到低端1MB内存的顶部，即0xF0000-0xFFFFF。</li><li>程序一上电，cpu的cs:ip被强制初始化到0xf000:0xfff0处，系统一开始处于实模式，寄存器默认16位，地址总线是20位，访问内存上限为1MB，实模式下内存访问的计算为：段基地址左移4位+偏移地址，因此0xf000:0xfff0对应为0xffff0。因此程序上电，CPU强制执行0xffff0处指令，此处指令占16字节，为jmp f000:e05b，即0xfe05b，BIOS代码真正开始执行的地方。</li><li>BIOS开始检测内存、显存等一系列外设信息，初始化部分硬件，在内存0x000-0x3ff中建立IVT并填写中断例程入口。</li><li>BIOS从CMOS芯片中读取预设的OS启动顺序（例如硬盘、U盘、光驱），假设当BIOS选择硬盘作为引导设备时，首先定位MBR的位置，再调用磁盘服务中断INT 13H，将硬盘的第一个扇区读取到物理内存起始地址为0x7c00处，并验证最后两个字节是否为0x55AA，若无效则尝试下一个引导设备，若有效则跳转到0x7c00处开始执行MBR的代码。</li></ol><h3 id="2-2-4-为什么是0x7c00"><a href="#2-2-4-为什么是0x7c00" class="headerlink" title="2.2.4 为什么是0x7c00"></a>2.2.4 为什么是0x7c00</h3><p>不为什么，历史遗留问题，没必要细究</p><h2 id="2-3-MBR"><a href="#2-3-MBR" class="headerlink" title="2.3 MBR"></a>2.3 MBR</h2><h3 id="2-3-1-什么叫MBR"><a href="#2-3-1-什么叫MBR" class="headerlink" title="2.3.1 什么叫MBR"></a>2.3.1 什么叫MBR</h3><ol><li>MBR叫主引导扇区，是BIOS执行到最后跳转的地方，其中包括内容有：<br> 446字节的引导程序以及参数<br> 64字节的分区表<br> 2字节的结束标记，即魔数0x55 0xaa</li><li>MBR一般位于硬盘的0盘0道1扇区</li><li>通过MBR开始引导计算机</li></ol><h3 id="2-3-2-开始写MBR"><a href="#2-3-2-开始写MBR" class="headerlink" title="2.3.2 开始写MBR"></a>2.3.2 开始写MBR</h3><p>boot.S:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">SECTION</span> MBR vstart=<span class="hljs-number">0x7c00</span> <span class="hljs-comment">;起始地址编译在0x7c00</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">fs</span>,<span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">0x7c00</span><br>    <span class="hljs-comment">;这个时候 ds = es = ss = 0 栈指针指向MBR开始位置</span><br><br><br>    <span class="hljs-comment">;ah = 0x06 al = 0x00 想要调用int 0x06的BIOS提供的中断对应的函数 即向上移动即完成清屏功能</span><br>    <span class="hljs-comment">;cx dx 分别存储左上角与右下角的左边 详情看int 0x06函数调用</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0x600</span> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0x700</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0x184f</span><br>    <br>    <span class="hljs-comment">;调用BIOS中断</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span> <br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">3</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment">;获取光标位置 需要打印信息</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,message<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>,<span class="hljs-built_in">ax</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">5</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0x1301</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0x71</span><span class="hljs-comment">;白底蓝字好cooi</span><br>    <br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x10</span> <span class="hljs-comment">;写字符串</span><br>    <br>    <span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">;无限循环 一直跳转到当前命令位置</span><br>    <br>    <span class="hljs-comment">;字符串声明 db == define byte dw == define word ascii一个字符占一个字节</span><br>    message <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;1 MBR&quot;</span> <br>    <br>    <span class="hljs-comment">;预留两个字节 其余空余的全部用0填满 为使检测当前扇区最后两字节为0x55 0xaa 检测是否为有效扇区</span><br>    <span class="hljs-comment">;510 = 512字节-2预留字节  再减去（当前位置偏移量-段开始位置偏移量）求出来的是剩余空间</span><br>    <span class="hljs-built_in">times</span> <span class="hljs-number">510</span> - ($ - $$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span> <br>    <span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p>要点：</p><ol><li>利用了BIOS中断int 0x10进行打印（还未利用显卡驱动）</li><li><code>SECTION MBR vstart=0x7c00</code>告诉编译器将该段程序编译在0x7c00处</li><li><code>times 510 - ($ - $$) db 0</code>填充空余的部分，保证该段程序加上后面的魔数0x55，0xaa是512字节。</li></ol><h3 id="2-3-3-编译MBR，存到硬盘"><a href="#2-3-3-编译MBR，存到硬盘" class="headerlink" title="2.3.3 编译MBR，存到硬盘"></a>2.3.3 编译MBR，存到硬盘</h3><ol><li>内存里加载的程序都是二进制文件，而我们写的代码还没有经过编译成bin文件，需要利用指令<code>nasm -o boot.bin boot.S</code>进行编译。</li><li>理论上计算机会将硬盘的0盘0道1扇区的MBR加载到内存0x7c00处，我们的环境是在Ubuntu上的，文件boot.S和boot.bin都是在Ubuntu系统上，需要利用bochs创建镜像硬盘镜像，并利用dd命令将boot.bin复制到硬盘镜像的第一个扇区处，模拟成实际的环境，这样cpu才找得到MBR并把它加载到由bochs模拟的内存上。</li><li>目前镜像硬盘设置为60M，内存设置为32M</li><li>dd命令示例：<code>dd if=/home/cooiboi/bochs/mbr.bin of=/home/cooiboi/bochs/hd60M.img bs=512 count=1 conv=notrunc</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 第一章 环境部署</title>
    <link href="/2024/12/21/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2024/12/21/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%9D%20%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>需要写C文件和汇编文件，C文件利用GCC编译，汇编文件用NASM编译</p><h3 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h3><p>GCC（GNU Compiler Collection）是一个由GNU项目开发和维护的编译器集合，它支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada和Go等。</p><p>我们利用GCC将c文件经过预处理、编译、汇编生成目标文件.o文件，.o文件包含了编译器生成的机器代码，但尚未被链接成最终的可执行文件。</p><h3 id="NASM编译器"><a href="#NASM编译器" class="headerlink" title="NASM编译器"></a>NASM编译器</h3><p>NASM（Netwide Assembler）是一个开源的汇编器，主要用于编写和编译x86和x86-64架构的汇编代码。它以其简洁的语法、易用性和对新处理器指令的支持而闻名。</p><p>我们利用nasm将.S汇编文件汇编成目标文件.o文件。</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>利用Vmware装Ubuntu系统，在Ubuntu上进行开发</p><h2 id="硬件模拟器Bochs"><a href="#硬件模拟器Bochs" class="headerlink" title="硬件模拟器Bochs"></a>硬件模拟器Bochs</h2><p>Bochs是一个开源的x86硬件模拟器，它能够模拟整个PC硬件环境，包括CPU、内存、显卡、硬盘、网络等设备</p><p>利用Bochs配置硬件环境，可以在bochsrc的配置文件里进行配置，如内存大小</p><p>Bochs另一个重要功能是创建虚拟硬盘，操作系统无论如何也是存储在硬盘上的，因此肯定需要一个虚拟硬盘作为载体。</p><p>应该也可以用qemu，但我不会</p><h2 id="远程开发Vscode"><a href="#远程开发Vscode" class="headerlink" title="远程开发Vscode"></a>远程开发Vscode</h2><p>利用windows环境下的vscode，远程ssh连接虚拟机上的Ubuntu系统，方便开发。</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“从零搭建操作系统” 前言</title>
    <link href="/2024/12/21/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E2%80%9D%20%E5%89%8D%E8%A8%80/"/>
    <url>/2024/12/21/%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E2%80%9D%20%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="2024-12-21"><a href="#2024-12-21" class="headerlink" title="2024.12.21"></a>2024.12.21</h3><p>跟随《操作系统真象还原》这本书学习，共15章，目前已学完12章，随着对操作系统的深入感觉知识体系过于混乱，决定从头梳理前12章的内容，并记录在blog。</p><p>后三章分别是编写硬盘驱动程序，文件系统，系统交互（fork、shell、pipe等），逐渐偏向用户开发而不是内核开发，先吃透内核开发免得和用户开发混在一起。</p><p>冬至快乐！</p><h3 id="2024-12-23"><a href="#2024-12-23" class="headerlink" title="2024.12.23"></a>2024.12.23</h3><p>前三章暂时不细究，细究的话太多硬件知识基础知识，有点像八股，这次复习重点偏向内核。</p><p>与内核相关的，前三章整体的作用是BIOS-&gt;MBR-&gt;Loader</p><p>需要注意，有些知识如汇编的知识，section，硬盘结构，处理器架构等知识也应该很重要，以后要回来复习。</p><p>第四章跳过了处理器微架构和流水线的知识，以后再补。</p><h3 id="2024-12-25"><a href="#2024-12-25" class="headerlink" title="2024.12.25"></a>2024.12.25</h3><p>完成第五章的复习，跳过了ELF格式的解码以及一些特权级、调用门的介绍<br>要出差，无语。</p><p>第六章没什么特别难的，主要是实现打印函数操控显卡，以及内联汇编的一些知识</p><p>明天再写第七章吧，中断还是比较重要的</p><h3 id="2024-12-26"><a href="#2024-12-26" class="headerlink" title="2024.12.26"></a>2024.12.26</h3><p>完成第七章中断的复习，对8259A和8253两个芯片的复习没有很深，因为感觉这种芯片的使用记不住，只能现用现查<br>大概总结了中断的逻辑，今天就到这<br>明天出差no</p><h3 id="2025-1-2"><a href="#2025-1-2" class="headerlink" title="2025.1.2"></a>2025.1.2</h3><p>新年好<br>出差、跨年回来，重新着手完成了第八章的复习，这一章重点在于后面的内存管理，主要是对各种池如物理内存池虚拟内存池等的应用，但目前只完成了内核内存的分配函数，用户内存的分配比较复杂，以后讨论</p><h3 id="2025-1-3"><a href="#2025-1-3" class="headerlink" title="2025.1.3"></a>2025.1.3</h3><p>完成第九章的复习，多线程的切换对不同栈的设定，以及上下文的保护和恢复真的很巧妙，每次看都会觉得操作系统设计的精密</p><h3 id="2025-1-5"><a href="#2025-1-5" class="headerlink" title="2025.1.5"></a>2025.1.5</h3><p>完成第十章和第十一章的复习<br>第十章就是锁比较重点，主要需要理解信号量；键盘驱动大致看看就行，但是环形缓冲区涉及生产者-消费者原理，可以留意一下。<br>第十一章就很难，用户进程的实现，感觉好像还是有一些地方没搞懂，夸张，实现内核线程已经很麻烦了，结果用户进程更麻烦，不一步一步推导根本看不懂</p><h3 id="2025-1-6"><a href="#2025-1-6" class="headerlink" title="2025.1.6"></a>2025.1.6</h3><p>先再次总结了一下第十一章，进一步地，考虑有三个任务，分别是内核线程A，用户进程B，内核线程C，调度的时候是栈是如何切换的，就这一个问题捋清楚都花了将近两个小时，现在是大致都清楚了，但细节太多，估计以后还需要再复习巩固。</p><h3 id="2025-1-7"><a href="#2025-1-7" class="headerlink" title="2025.1.7"></a>2025.1.7</h3><p>完成第12章的复习，这一章主要是前面部分对系统调用的实现进行了了解，同时完善了堆内存管理，实现了对小内存块的动态分配与释放，涉及到了新的概念arena和内存块</p><h3 id="2025-1-8"><a href="#2025-1-8" class="headerlink" title="2025.1.8"></a>2025.1.8</h3><p>今天开始第13章的学习，接下来只剩下三章了，学习进度可能会放缓，每天学一点，需要把额外的时间拿来刷题，看八股和学c++</p><h3 id="2025-1-9"><a href="#2025-1-9" class="headerlink" title="2025.1.9"></a>2025.1.9</h3><p>小学了一下硬盘驱动的知识，开始写硬盘驱动的代码</p><h3 id="2025-1-10"><a href="#2025-1-10" class="headerlink" title="2025.1.10"></a>2025.1.10</h3><p>发现硬盘驱动代码有点复杂，这属于linux驱动的方面，但我想先把内核的逻辑学完，所以先跑通硬盘驱动就好，具体代码的逻辑看看能不能跳过，先去看文件系统，实在不行再回头看硬盘驱动代码</p><p>下午开始第十四章 文件系统的学习，这一章工作量巨大，估计要持续一段时间了</p><h3 id="2025-1-13"><a href="#2025-1-13" class="headerlink" title="2025.1.13"></a>2025.1.13</h3><p>不行，文件系统工作量也太大了，选择先过一遍代码并把每个功能都跑通，代码细节先忽略</p><h3 id="2025-1-15"><a href="#2025-1-15" class="headerlink" title="2025.1.15"></a>2025.1.15</h3><p>赶在回家前爆肝看完了这本书，有点可惜的是后面的exec，pipe等几个函数没能实现，学艺不精吧，以后再实现了</p>]]></content>
    
    
    <categories>
      
      <category>从零搭建操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
